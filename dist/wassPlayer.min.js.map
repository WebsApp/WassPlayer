{"version":3,"sources":["wassPlayer.js","node_modules/rangetouch/dist/rangetouch.mjs","src/js/utils/animation.js","src/js/utils/is.js","src/js/utils/browser.js","src/js/utils/objects.js","src/js/utils/elements.js","src/js/support.js","src/js/utils/events.js","src/js/utils/promise.js","src/js/utils/style.js","src/js/html5.js","src/js/utils/arrays.js","src/js/utils/strings.js","src/js/utils/i18n.js","src/js/storage.js","src/js/utils/fetch.js","src/js/utils/load-sprite.js","src/js/utils/time.js","src/js/controls.js","src/js/utils/urls.js","src/js/captions.js","src/js/config/defaults.js","src/js/config/states.js","src/js/config/types.js","src/js/console.js","src/js/fullscreen.js","src/js/utils/load-image.js","src/js/ui.js","src/js/listeners.js","src/js/media.js","src/js/plugins/preview-thumbnails.js","src/js/source.js","src/js/wassPlayer.js","src/js/utils/numbers.js"],"names":["navigator","global","factory","exports","module","define","amd","globalThis","self","WassPlayer","this","_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","protoProps","staticProps","prototype","_defineProperty","obj","value","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","push","apply","_objectSpread2","arguments","source","forEach","getOwnPropertyDescriptors","defineProperties","_slicedToArray","arr","Array","isArray","_arrayWithHoles","Symbol","iterator","_arr","_n","_d","_e","undefined","_s","_i","next","done","err","_iterableToArrayLimit","_unsupportedIterableToArray","_nonIterableRest","_toConsumableArray","_arrayLikeToArray","_arrayWithoutHoles","iter","from","_iterableToArray","_nonIterableSpread","o","minLen","n","toString","call","slice","constructor","name","test","len","arr2","e","t","r","defaults","addCSS","thumbWidth","watch","matches","document","querySelectorAll","includes","getConstructor","instanceOf","isNullOrUndefined","isObject","isString","String","isNodeList","NodeList","is","Element","Event","round","concat","match","Math","max","getDecimalPlaces","parseFloat","toFixed","element","events","type","RangeTouch","querySelector","rangeTouch","config","init","enabled","style","userSelect","webKitUserSelect","touchAction","listeners","set","changedTouches","getAttribute","s","u","c","getBoundingClientRect","a","width","clientX","left","disabled","preventDefault","get","bubbles","dispatchEvent","trigger","MutationObserver","addedNodes","observe","body","childList","subtree","map","documentElement","input","Boolean","isFunction","Function","isEmpty","is$1","Number","isNaN","KeyboardEvent","TextTrack","kind","Promise","then","window","URL","string","startsWith","hostname","transitionEndEvent","createElement","WebkitTransition","MozTransition","OTransition","transition","find","event","repaint","delay","setTimeout","hidden","offsetHeight","browser","isIE","documentMode","isEdge","userAgent","isWebkit","isIPhone","platform","isIos","getDeep","path","split","reduce","extend","_len","sources","_key","shift","assign","wrap","elements","wrapper","targets","reverse","index","child","cloneNode","parent","parentNode","sibling","nextSibling","appendChild","insertBefore","setAttributes","attributes","entries","_ref","_ref3","_ref4","setAttribute","text","innerText","insertElement","removeElement","removeChild","emptyElement","childNodes","lastChild","replaceElement","newChild","oldChild","replaceChild","getAttributesFromSelector","sel","existingAttributes","existing","selector","trim","className","replace","parts","charAt","class","id","toggleHidden","hide","toggleClass","force","method","classList","contains","hasClass","webkitMatchesSelector","mozMatchesSelector","msMatchesSelector","getElements","container","getElement","setFocus","tabFocus","focus","preventScroll","classNames","range","defaultCodecs","audio/ogg","audio/wav","video/webm","video/mp4","video/ogg","support","audio","video","check","provider","playsinline","canPlayInline","api","ui","rangeInput","pip","webkitSetPresentationMode","pictureInPictureEnabled","disablePictureInPicture","airplay","WebKitPlaybackTargetAvailabilityEvent","mime","mediaType","isHTML5","media","canPlayType","textTracks","touch","transitions","reducedMotion","matchMedia","supportsPassiveListeners","supported","options","addEventListener","removeEventListener","toggleListener","callback","_this","toggle","passive","capture","eventListeners","on","off","once","_this2","onceCallback","args","triggerEvent","detail","CustomEvent","plyr","unbindListeners","item","ready","_this3","resolve","silencePromise","validateRatio","every","reduceAspectRatio","ratio","_ratio","height","divider","getDivider","w","h","getAspectRatio","parse","embed","_this$media","videoWidth","videoHeight","setAspectRatio","isVideo","_ref2","padding","paddingBottom","isVimeo","vimeo","premium","offsetWidth","parseInt","getComputedStyle","offset","transform","videoFixedRatio","html5","getSources","getQualityOptions","quality","forced","setup","player","speed","onChange","_player$media","currentTime","paused","preload","readyState","playbackRate","src","play","load","cancelRequests","blankVideo","debug","log","dedupe","array","indexOf","replaceAll","RegExp","toTitleCase","toUpperCase","substr","toLowerCase","toPascalCase","getHTML","innerHTML","resources","youtube","i18n","{seektime}","seekTime","{title}","title","k","v","Storage","storage","store","localStorage","getItem","json","JSON","setItem","stringify","removeItem","fetch","url","responseType","reject","request","XMLHttpRequest","responseText","response","Error","status","open","send","loadSprite","prefix","hasId","exists","getElementById","update","data","insertAdjacentElement","useStorage","cached","content","result","catch","getHours","trunc","getMinutes","getSeconds","formatTime","time","displayHours","inverted","format","hours","mins","secs","controls","getIconUrl","cors","iconUrl","location","host","svg4everybody","findElements","selectors","buttons","pause","restart","rewind","fastForward","mute","settings","captions","fullscreen","progress","inputs","seek","volume","display","buffer","duration","seekTooltip","tooltip","error","warn","toggleNativeControls","createIcon","namespace","iconPath","iconPrefix","icon","createElementNS","aria-hidden","focusable","use","setAttributeNS","createLabel","attr","join","createBadge","badge","menu","createButton","buttonType","toCamelCase","label","labelPressed","iconPressed","some","control","button","createRange","min","step","autocomplete","role","aria-label","aria-valuemin","aria-valuemax","aria-valuenow","updateRangeFill","createProgress","suffixKey","played","suffix","createTime","attrs","bindMenuItemShortcuts","menuItem","which","stopPropagation","isRadioButton","showMenuPanel","nextElementSibling","firstElementChild","previousElementSibling","lastElementChild","focusFirstMenuItem","createMenuItem","list","_ref$badge","_ref$checked","checked","aria-checked","flex","children","node","bind","currentTrack","forceHours","updateTimeDisplay","updateVolume","setRange","muted","pressed","updateProgress","_this4","current","val","getElementsByTagName","nodeValue","setProgress","buffered","percent","setProperty","updateSeekTooltip","_this5","tooltips","visible","show","clientRect","pageX","timeUpdate","invert","invertTime","seeking","durationUpdate","pow","hasDuration","displayDuration","toggleMenuButton","setting","updateSetting","pane","panels","default","getLabel","setQualityMenu","_this6","checkMenu","getBadge","sort","b","sorting","setCaptionsMenu","_this7","tracks","getTracks","track","toggled","language","unshift","setSpeedMenu","_this8","minimumSpeed","maximumSpeed","values","popup","p","firstItem","toggleMenu","composedPath","isMenuItem","getMenuSize","tab","clone","position","opacity","removeAttribute","scrollWidth","scrollHeight","_this9","size","restore","propertyName","setDownloadUrl","download","create","_this10","defaultAttributes","progressContainer","aria-haspopup","aria-controls","aria-expanded","inner","home","backButton","href","urls","isEmbed","inject","_this11","floor","random","seektime","addProperty","controlPressed","_this$config","labels","parseUrl","safe","parser","isYouTube","insertAfter","protocol","blob","createObjectURL","languages","userLanguage","active","trackEvents","_this$captions","meta","currentTrackNode","languageExists","mode","updateCues","setLanguage","activeClass","findTrack","enableTextTrack","has","sortIsDefault","sorted","getCurrentTrack","cues","activeCues","cue","getCueAsHTML","cueText","caption","autoplay","autopause","toggleInvert","clickToPlay","hideControls","resetOnEnd","disableContextMenu","loop","selected","keyboard","focused","fallback","iosNative","seekLabel","unmute","enableCaptions","disableCaptions","enterFullscreen","exitFullscreen","frameTitle","menuBack","normal","start","end","all","reset","advertisement","qualityBadge","2160","1440","1080","720","576","480","editable","embedContainer","poster","posterEnabled","playing","stopped","loading","hover","isTouch","uiSupported","noTransition","previewThumbnails","thumbContainer","thumbContainerShown","imageContainer","timeContainer","scrubbingContainer","scrubbingContainerShown","providers","types","noop","Console","console","Fullscreen","property","scrollPosition","x","y","forceFallback","closest","el","parentElement","nodeType","trapFocus","scrollX","scrollY","scrollTo","overflow","viewport","head","hasProperty","cleanupViewport","part","keyCode","activeElement","first","last","shiftKey","native","webkitEnterFullscreen","toggleFallback","requestFullscreen","navigationUI","webkitExitFullscreen","action","cancelFullScreen","exit","enter","fullscreenElement","shadowRoot","getRootNode","fullscreenEnabled","webkitFullscreenEnabled","mozFullScreenEnabled","msFullscreenEnabled","pre","loadImage","minWidth","image","Image","handler","onload","onerror","naturalWidth","addStyleHook","build","checkPlaying","setTitle","setPoster","iframe","togglePoster","enable","backgroundImage","backgroundSize","toggleControls","checkLoading","clearTimeout","timers","controlsElement","recentTouchSeek","lastSeekTime","Date","now","migrateStyles","getPropertyValue","removeProperty","Listeners","lastKey","focusTimer","lastKeyDown","handleKey","setTabFocus","firstTouch","code","repeat","altKey","ctrlKey","metaKey","togglePlay","increaseVolume","decreaseVolume","forward","toggleCaptions","usingNative","timeStamp","wasKeyDown","setPlayerSize","measure","rect","resized","_player$fullscreen","isEnter","_setPlayerSize","firstChild","_getAspectRatio$call2","videoX","videoY","maxWidth","margin","setGutter","isAudio","ended","proxy","proxyEvents","_event$detail","defaultHandler","customHandlerKey","customHandler","returned","hasCustomHandler","inputEvent","currentTarget","attribute","hasAttribute","seekTo","loaded","startMove","endMove","startScrubbing","endScrubbing","webkitDirectionInvertedFromDevice","_map2","deltaX","deltaY","direction","sign","abs","fitRatio","outer","PreviewThumbnails","thumbnails","lastMouseMoveTime","mouseDown","loadedImages","thumb","scrubbing","getThumbnails","render","determineContainerAutoSizing","sortAndResolve","promises","getThumbnail","vttDataString","processedList","thumbnail","frames","frame","line","startTime","lineSplit","_lineSplit","_lineSplit$1$split2","matchTimes","endTime","urlPrefix","substring","lastIndexOf","tempImage","naturalHeight","percentage","mousePosX","showImageAtCurrentTime","toggleThumbContainer","toggleScrubbingContainer","ceil","lastTime","remove","setScrubbingContainerSize","setThumbContainerSizeAndPos","thumbNum","findIndex","hasThumb","qualityIndex","showingThumb","thumbFilename","thumbUrl","currentImageElement","dataset","filename","showImage","removeOldImages","loadingImage","usingSprites","previewImage","showingThumbFilename","newImage","setImageSizeAndOffset","currentImageContainer","preloadNearby","getHigherQuality","currentImage","tagName","removeDelay","deleting","oldThumbFilename","thumbnailsClone","foundOne","newThumbFilename","thumbURL","currentQualityIndex","previewImageHeight","thumbContainerHeight","clearShowing","clientHeight","clientWidth","sizeSpecifiedInCSS","thumbAspectRatio","thumbHeight","setThumbContainerPos","seekbarRect","wassPlayerRect","minVal","maxVal","right","previewPos","_fitRatio","multiplier","top","currentScrubbingImageElement","currentThumbnailImageElement","insertElements","change","destroy","_sources$","_sources$$provider","crossorigin","failed","jQuery","WeakMap","wassPlayer","original","search","truthy","searchParams","tabindex","stop","webkitShowPlaybackTargetPicker","isHidden","hiding","eventName","soft","inputIsValid","fauxDuration","realDuration","Infinity","mozHasAudio","webkitAudioDecodedByteCount","audioTracks","clamp","updateStorage","prev","curr","currentSrc","requestPictureInPicture","exitPictureInPicture","webkitPresentationMode","pictureInPictureElement","inline"],"mappings":"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","file":"wassPlayer.min.js","sourcesContent":["typeof navigator === \"object\" && (function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n  typeof define === 'function' && define.amd ? define('WassPlayer', factory) :\n  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.WassPlayer = factory());\n}(this, (function () { 'use strict';\n\n  function _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError(\"Cannot call a class as a function\");\n    }\n  }\n\n  function _defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  function _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    return Constructor;\n  }\n\n  function _defineProperty(obj, key, value) {\n    if (key in obj) {\n      Object.defineProperty(obj, key, {\n        value: value,\n        enumerable: true,\n        configurable: true,\n        writable: true\n      });\n    } else {\n      obj[key] = value;\n    }\n\n    return obj;\n  }\n\n  function ownKeys(object, enumerableOnly) {\n    var keys = Object.keys(object);\n\n    if (Object.getOwnPropertySymbols) {\n      var symbols = Object.getOwnPropertySymbols(object);\n      if (enumerableOnly) symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n      keys.push.apply(keys, symbols);\n    }\n\n    return keys;\n  }\n\n  function _objectSpread2(target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i] != null ? arguments[i] : {};\n\n      if (i % 2) {\n        ownKeys(Object(source), true).forEach(function (key) {\n          _defineProperty(target, key, source[key]);\n        });\n      } else if (Object.getOwnPropertyDescriptors) {\n        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n      } else {\n        ownKeys(Object(source)).forEach(function (key) {\n          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n        });\n      }\n    }\n\n    return target;\n  }\n\n  function _slicedToArray(arr, i) {\n    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n  }\n\n  function _toConsumableArray(arr) {\n    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n  }\n\n  function _arrayWithoutHoles(arr) {\n    if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n  }\n\n  function _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n  }\n\n  function _iterableToArray(iter) {\n    if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n  }\n\n  function _iterableToArrayLimit(arr, i) {\n    if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  function _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n  }\n\n  function _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n\n    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n    return arr2;\n  }\n\n  function _nonIterableSpread() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  function _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  function _classCallCheck$1(e, t) {\n    if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n  }\n\n  function _defineProperties$1(e, t) {\n    for (var n = 0; n < t.length; n++) {\n      var r = t[n];\n      r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(e, r.key, r);\n    }\n  }\n\n  function _createClass$1(e, t, n) {\n    return t && _defineProperties$1(e.prototype, t), n && _defineProperties$1(e, n), e;\n  }\n\n  function _defineProperty$1(e, t, n) {\n    return t in e ? Object.defineProperty(e, t, {\n      value: n,\n      enumerable: !0,\n      configurable: !0,\n      writable: !0\n    }) : e[t] = n, e;\n  }\n\n  function ownKeys$1(e, t) {\n    var n = Object.keys(e);\n\n    if (Object.getOwnPropertySymbols) {\n      var r = Object.getOwnPropertySymbols(e);\n      t && (r = r.filter(function (t) {\n        return Object.getOwnPropertyDescriptor(e, t).enumerable;\n      })), n.push.apply(n, r);\n    }\n\n    return n;\n  }\n\n  function _objectSpread2$1(e) {\n    for (var t = 1; t < arguments.length; t++) {\n      var n = null != arguments[t] ? arguments[t] : {};\n      t % 2 ? ownKeys$1(Object(n), !0).forEach(function (t) {\n        _defineProperty$1(e, t, n[t]);\n      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : ownKeys$1(Object(n)).forEach(function (t) {\n        Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t));\n      });\n    }\n\n    return e;\n  }\n\n  var defaults = {\n    addCSS: !0,\n    thumbWidth: 15,\n    watch: !0\n  };\n\n  function matches(e, t) {\n    return function () {\n      return Array.from(document.querySelectorAll(t)).includes(this);\n    }.call(e, t);\n  }\n\n  function trigger(e, t) {\n    if (e && t) {\n      var n = new Event(t, {\n        bubbles: !0\n      });\n      e.dispatchEvent(n);\n    }\n  }\n\n  var getConstructor = function getConstructor(e) {\n    return null != e ? e.constructor : null;\n  },\n      instanceOf = function instanceOf(e, t) {\n    return !!(e && t && e instanceof t);\n  },\n      isNullOrUndefined = function isNullOrUndefined(e) {\n    return null == e;\n  },\n      isObject = function isObject(e) {\n    return getConstructor(e) === Object;\n  },\n      isNumber = function isNumber(e) {\n    return getConstructor(e) === Number && !Number.isNaN(e);\n  },\n      isString = function isString(e) {\n    return getConstructor(e) === String;\n  },\n      isBoolean = function isBoolean(e) {\n    return getConstructor(e) === Boolean;\n  },\n      isFunction = function isFunction(e) {\n    return getConstructor(e) === Function;\n  },\n      isArray = function isArray(e) {\n    return Array.isArray(e);\n  },\n      isNodeList = function isNodeList(e) {\n    return instanceOf(e, NodeList);\n  },\n      isElement = function isElement(e) {\n    return instanceOf(e, Element);\n  },\n      isEvent = function isEvent(e) {\n    return instanceOf(e, Event);\n  },\n      isEmpty = function isEmpty(e) {\n    return isNullOrUndefined(e) || (isString(e) || isArray(e) || isNodeList(e)) && !e.length || isObject(e) && !Object.keys(e).length;\n  },\n      is = {\n    nullOrUndefined: isNullOrUndefined,\n    object: isObject,\n    number: isNumber,\n    string: isString,\n    boolean: isBoolean,\n    function: isFunction,\n    array: isArray,\n    nodeList: isNodeList,\n    element: isElement,\n    event: isEvent,\n    empty: isEmpty\n  };\n\n  function getDecimalPlaces(e) {\n    var t = \"\".concat(e).match(/(?:\\.(\\d+))?(?:[eE]([+-]?\\d+))?$/);\n    return t ? Math.max(0, (t[1] ? t[1].length : 0) - (t[2] ? +t[2] : 0)) : 0;\n  }\n\n  function round(e, t) {\n    if (1 > t) {\n      var n = getDecimalPlaces(t);\n      return parseFloat(e.toFixed(n));\n    }\n\n    return Math.round(e / t) * t;\n  }\n\n  var RangeTouch = function () {\n    function e(t, n) {\n      _classCallCheck$1(this, e), is.element(t) ? this.element = t : is.string(t) && (this.element = document.querySelector(t)), is.element(this.element) && is.empty(this.element.rangeTouch) && (this.config = _objectSpread2$1({}, defaults, {}, n), this.init());\n    }\n\n    return _createClass$1(e, [{\n      key: \"init\",\n      value: function value() {\n        e.enabled && (this.config.addCSS && (this.element.style.userSelect = \"none\", this.element.style.webKitUserSelect = \"none\", this.element.style.touchAction = \"manipulation\"), this.listeners(!0), this.element.rangeTouch = this);\n      }\n    }, {\n      key: \"destroy\",\n      value: function value() {\n        e.enabled && (this.config.addCSS && (this.element.style.userSelect = \"\", this.element.style.webKitUserSelect = \"\", this.element.style.touchAction = \"\"), this.listeners(!1), this.element.rangeTouch = null);\n      }\n    }, {\n      key: \"listeners\",\n      value: function value(e) {\n        var t = this,\n            n = e ? \"addEventListener\" : \"removeEventListener\";\n        [\"touchstart\", \"touchmove\", \"touchend\"].forEach(function (e) {\n          t.element[n](e, function (e) {\n            return t.set(e);\n          }, !1);\n        });\n      }\n    }, {\n      key: \"get\",\n      value: function value(t) {\n        if (!e.enabled || !is.event(t)) return null;\n        var n,\n            r = t.target,\n            i = t.changedTouches[0],\n            o = parseFloat(r.getAttribute(\"min\")) || 0,\n            s = parseFloat(r.getAttribute(\"max\")) || 100,\n            u = parseFloat(r.getAttribute(\"step\")) || 1,\n            c = r.getBoundingClientRect(),\n            a = 100 / c.width * (this.config.thumbWidth / 2) / 100;\n        return 0 > (n = 100 / c.width * (i.clientX - c.left)) ? n = 0 : 100 < n && (n = 100), 50 > n ? n -= (100 - 2 * n) * a : 50 < n && (n += 2 * (n - 50) * a), o + round(n / 100 * (s - o), u);\n      }\n    }, {\n      key: \"set\",\n      value: function value(t) {\n        e.enabled && is.event(t) && !t.target.disabled && (t.preventDefault(), t.target.value = this.get(t), trigger(t.target, \"touchend\" === t.type ? \"change\" : \"input\"));\n      }\n    }], [{\n      key: \"setup\",\n      value: function value(t) {\n        var n = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : {},\n            r = null;\n        if (is.empty(t) || is.string(t) ? r = Array.from(document.querySelectorAll(is.string(t) ? t : 'input[type=\"range\"]')) : is.element(t) ? r = [t] : is.nodeList(t) ? r = Array.from(t) : is.array(t) && (r = t.filter(is.element)), is.empty(r)) return null;\n\n        var i = _objectSpread2$1({}, defaults, {}, n);\n\n        if (is.string(t) && i.watch) {\n          var o = new MutationObserver(function (n) {\n            Array.from(n).forEach(function (n) {\n              Array.from(n.addedNodes).forEach(function (n) {\n                is.element(n) && matches(n, t) && new e(n, i);\n              });\n            });\n          });\n          o.observe(document.body, {\n            childList: !0,\n            subtree: !0\n          });\n        }\n\n        return r.map(function (t) {\n          return new e(t, n);\n        });\n      }\n    }, {\n      key: \"enabled\",\n      get: function get() {\n        return \"ontouchstart\" in document.documentElement;\n      }\n    }]), e;\n  }();\n\n  // ==========================================================================\n  // Type checking utils\n  // ==========================================================================\n  var getConstructor$1 = function getConstructor(input) {\n    return input !== null && typeof input !== 'undefined' ? input.constructor : null;\n  };\n\n  var instanceOf$1 = function instanceOf(input, constructor) {\n    return Boolean(input && constructor && input instanceof constructor);\n  };\n\n  var isNullOrUndefined$1 = function isNullOrUndefined(input) {\n    return input === null || typeof input === 'undefined';\n  };\n\n  var isObject$1 = function isObject(input) {\n    return getConstructor$1(input) === Object;\n  };\n\n  var isNumber$1 = function isNumber(input) {\n    return getConstructor$1(input) === Number && !Number.isNaN(input);\n  };\n\n  var isString$1 = function isString(input) {\n    return getConstructor$1(input) === String;\n  };\n\n  var isBoolean$1 = function isBoolean(input) {\n    return getConstructor$1(input) === Boolean;\n  };\n\n  var isFunction$1 = function isFunction(input) {\n    return getConstructor$1(input) === Function;\n  };\n\n  var isArray$1 = function isArray(input) {\n    return Array.isArray(input);\n  };\n\n  var isWeakMap = function isWeakMap(input) {\n    return instanceOf$1(input, WeakMap);\n  };\n\n  var isNodeList$1 = function isNodeList(input) {\n    return instanceOf$1(input, NodeList);\n  };\n\n  var isElement$1 = function isElement(input) {\n    return instanceOf$1(input, Element);\n  };\n\n  var isTextNode = function isTextNode(input) {\n    return getConstructor$1(input) === Text;\n  };\n\n  var isEvent$1 = function isEvent(input) {\n    return instanceOf$1(input, Event);\n  };\n\n  var isKeyboardEvent = function isKeyboardEvent(input) {\n    return instanceOf$1(input, KeyboardEvent);\n  };\n\n  var isCue = function isCue(input) {\n    return instanceOf$1(input, window.TextTrackCue) || instanceOf$1(input, window.VTTCue);\n  };\n\n  var isTrack = function isTrack(input) {\n    return instanceOf$1(input, TextTrack) || !isNullOrUndefined$1(input) && isString$1(input.kind);\n  };\n\n  var isPromise = function isPromise(input) {\n    return instanceOf$1(input, Promise) && isFunction$1(input.then);\n  };\n\n  var isEmpty$1 = function isEmpty(input) {\n    return isNullOrUndefined$1(input) || (isString$1(input) || isArray$1(input) || isNodeList$1(input)) && !input.length || isObject$1(input) && !Object.keys(input).length;\n  };\n\n  var isUrl = function isUrl(input) {\n    // Accept a URL object\n    if (instanceOf$1(input, window.URL)) {\n      return true;\n    } // Must be string from here\n\n\n    if (!isString$1(input)) {\n      return false;\n    } // Add the protocol if required\n\n\n    var string = input;\n\n    if (!input.startsWith('http://') || !input.startsWith('https://')) {\n      string = \"http://\".concat(input);\n    }\n\n    try {\n      return !isEmpty$1(new URL(string).hostname);\n    } catch (e) {\n      return false;\n    }\n  };\n\n  var is$1 = {\n    nullOrUndefined: isNullOrUndefined$1,\n    object: isObject$1,\n    number: isNumber$1,\n    string: isString$1,\n    boolean: isBoolean$1,\n    function: isFunction$1,\n    array: isArray$1,\n    weakMap: isWeakMap,\n    nodeList: isNodeList$1,\n    element: isElement$1,\n    textNode: isTextNode,\n    event: isEvent$1,\n    keyboardEvent: isKeyboardEvent,\n    cue: isCue,\n    track: isTrack,\n    promise: isPromise,\n    url: isUrl,\n    empty: isEmpty$1\n  };\n\n  // ==========================================================================\n  var transitionEndEvent = function () {\n    var element = document.createElement('span');\n    var events = {\n      WebkitTransition: 'webkitTransitionEnd',\n      MozTransition: 'transitionend',\n      OTransition: 'oTransitionEnd otransitionend',\n      transition: 'transitionend'\n    };\n    var type = Object.keys(events).find(function (event) {\n      return element.style[event] !== undefined;\n    });\n    return is$1.string(type) ? events[type] : false;\n  }(); // Force repaint of element\n\n  function repaint(element, delay) {\n    setTimeout(function () {\n      try {\n        // eslint-disable-next-line no-param-reassign\n        element.hidden = true; // eslint-disable-next-line no-unused-expressions\n\n        element.offsetHeight; // eslint-disable-next-line no-param-reassign\n\n        element.hidden = false;\n      } catch (e) {// Do nothing\n      }\n    }, delay);\n  }\n\n  // ==========================================================================\n  // Browser sniffing\n  // Unfortunately, due to mixed support, UA sniffing is required\n  // ==========================================================================\n  var browser = {\n    isIE:\n    /* @cc_on!@ */\n     !!document.documentMode,\n    isEdge: window.navigator.userAgent.includes('Edge'),\n    isWebkit: 'WebkitAppearance' in document.documentElement.style && !/Edge/.test(navigator.userAgent),\n    isIPhone: /(iPhone|iPod)/gi.test(navigator.platform),\n    isIos: /(iPad|iPhone|iPod)/gi.test(navigator.platform)\n  };\n\n  function cloneDeep(object) {\n    return JSON.parse(JSON.stringify(object));\n  } // Get a nested value in an object\n\n  function getDeep(object, path) {\n    return path.split('.').reduce(function (obj, key) {\n      return obj && obj[key];\n    }, object);\n  } // Deep extend destination object with N more objects\n\n  function extend() {\n    var target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    for (var _len = arguments.length, sources = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      sources[_key - 1] = arguments[_key];\n    }\n\n    if (!sources.length) {\n      return target;\n    }\n\n    var source = sources.shift();\n\n    if (!is$1.object(source)) {\n      return target;\n    }\n\n    Object.keys(source).forEach(function (key) {\n      if (is$1.object(source[key])) {\n        if (!Object.keys(target).includes(key)) {\n          Object.assign(target, _defineProperty({}, key, {}));\n        }\n\n        extend(target[key], source[key]);\n      } else {\n        Object.assign(target, _defineProperty({}, key, source[key]));\n      }\n    });\n    return extend.apply(void 0, [target].concat(sources));\n  }\n\n  function wrap(elements, wrapper) {\n    // Convert `elements` to an array, if necessary.\n    var targets = elements.length ? elements : [elements]; // Loops backwards to prevent having to clone the wrapper on the\n    // first element (see `child` below).\n\n    Array.from(targets).reverse().forEach(function (element, index) {\n      var child = index > 0 ? wrapper.cloneNode(true) : wrapper; // Cache the current parent and sibling.\n\n      var parent = element.parentNode;\n      var sibling = element.nextSibling; // Wrap the element (is automatically removed from its current\n      // parent).\n\n      child.appendChild(element); // If the element had a sibling, insert the wrapper before\n      // the sibling to maintain the HTML structure; otherwise, just\n      // append it to the parent.\n\n      if (sibling) {\n        parent.insertBefore(child, sibling);\n      } else {\n        parent.appendChild(child);\n      }\n    });\n  } // Set attributes\n\n  function setAttributes(element, attributes) {\n    if (!is$1.element(element) || is$1.empty(attributes)) {\n      return;\n    } // Assume null and undefined attributes should be left out,\n    // Setting them would otherwise convert them to \"null\" and \"undefined\"\n\n\n    Object.entries(attributes).filter(function (_ref) {\n      var _ref2 = _slicedToArray(_ref, 2),\n          value = _ref2[1];\n\n      return !is$1.nullOrUndefined(value);\n    }).forEach(function (_ref3) {\n      var _ref4 = _slicedToArray(_ref3, 2),\n          key = _ref4[0],\n          value = _ref4[1];\n\n      return element.setAttribute(key, value);\n    });\n  } // Create a DocumentFragment\n\n  function createElement(type, attributes, text) {\n    // Create a new <element>\n    var element = document.createElement(type); // Set all passed attributes\n\n    if (is$1.object(attributes)) {\n      setAttributes(element, attributes);\n    } // Add text node\n\n\n    if (is$1.string(text)) {\n      element.innerText = text;\n    } // Return built element\n\n\n    return element;\n  } // Inaert an element after another\n\n  function insertAfter(element, target) {\n    if (!is$1.element(element) || !is$1.element(target)) {\n      return;\n    }\n\n    target.parentNode.insertBefore(element, target.nextSibling);\n  } // Insert a DocumentFragment\n\n  function insertElement(type, parent, attributes, text) {\n    if (!is$1.element(parent)) {\n      return;\n    }\n\n    parent.appendChild(createElement(type, attributes, text));\n  } // Remove element(s)\n\n  function removeElement(element) {\n    if (is$1.nodeList(element) || is$1.array(element)) {\n      Array.from(element).forEach(removeElement);\n      return;\n    }\n\n    if (!is$1.element(element) || !is$1.element(element.parentNode)) {\n      return;\n    }\n\n    element.parentNode.removeChild(element);\n  } // Remove all child elements\n\n  function emptyElement(element) {\n    if (!is$1.element(element)) {\n      return;\n    }\n\n    var length = element.childNodes.length;\n\n    while (length > 0) {\n      element.removeChild(element.lastChild);\n      length -= 1;\n    }\n  } // Replace element\n\n  function replaceElement(newChild, oldChild) {\n    if (!is$1.element(oldChild) || !is$1.element(oldChild.parentNode) || !is$1.element(newChild)) {\n      return null;\n    }\n\n    oldChild.parentNode.replaceChild(newChild, oldChild);\n    return newChild;\n  } // Get an attribute object from a string selector\n\n  function getAttributesFromSelector(sel, existingAttributes) {\n    // For example:\n    // '.test' to { class: 'test' }\n    // '#test' to { id: 'test' }\n    // '[data-test=\"test\"]' to { 'data-test': 'test' }\n    if (!is$1.string(sel) || is$1.empty(sel)) {\n      return {};\n    }\n\n    var attributes = {};\n    var existing = extend({}, existingAttributes);\n    sel.split(',').forEach(function (s) {\n      // Remove whitespace\n      var selector = s.trim();\n      var className = selector.replace('.', '');\n      var stripped = selector.replace(/[[\\]]/g, ''); // Get the parts and value\n\n      var parts = stripped.split('=');\n\n      var _parts = _slicedToArray(parts, 1),\n          key = _parts[0];\n\n      var value = parts.length > 1 ? parts[1].replace(/[\"']/g, '') : ''; // Get the first character\n\n      var start = selector.charAt(0);\n\n      switch (start) {\n        case '.':\n          // Add to existing classname\n          if (is$1.string(existing.class)) {\n            attributes.class = \"\".concat(existing.class, \" \").concat(className);\n          } else {\n            attributes.class = className;\n          }\n\n          break;\n\n        case '#':\n          // ID selector\n          attributes.id = selector.replace('#', '');\n          break;\n\n        case '[':\n          // Attribute selector\n          attributes[key] = value;\n          break;\n      }\n    });\n    return extend(existing, attributes);\n  } // Toggle hidden\n\n  function toggleHidden(element, hidden) {\n    if (!is$1.element(element)) {\n      return;\n    }\n\n    var hide = hidden;\n\n    if (!is$1.boolean(hide)) {\n      hide = !element.hidden;\n    } // eslint-disable-next-line no-param-reassign\n\n\n    element.hidden = hide;\n  } // Mirror Element.classList.toggle, with IE compatibility for \"force\" argument\n\n  function toggleClass(element, className, force) {\n    if (is$1.nodeList(element)) {\n      return Array.from(element).map(function (e) {\n        return toggleClass(e, className, force);\n      });\n    }\n\n    if (is$1.element(element)) {\n      var method = 'toggle';\n\n      if (typeof force !== 'undefined') {\n        method = force ? 'add' : 'remove';\n      }\n\n      element.classList[method](className);\n      return element.classList.contains(className);\n    }\n\n    return false;\n  } // Has class name\n\n  function hasClass(element, className) {\n    return is$1.element(element) && element.classList.contains(className);\n  } // Element matches selector\n\n  function matches$1(element, selector) {\n    var _Element = Element,\n        prototype = _Element.prototype;\n\n    function match() {\n      return Array.from(document.querySelectorAll(selector)).includes(this);\n    }\n\n    var method = prototype.matches || prototype.webkitMatchesSelector || prototype.mozMatchesSelector || prototype.msMatchesSelector || match;\n    return method.call(element, selector);\n  } // Closest ancestor element matching selector (also tests element itself)\n\n  function closest(element, selector) {\n    var _Element2 = Element,\n        prototype = _Element2.prototype; // https://developer.mozilla.org/en-US/docs/Web/API/Element/closest#Polyfill\n\n    function closestElement() {\n      var el = this;\n\n      do {\n        if (matches$1.matches(el, selector)) return el;\n        el = el.parentElement || el.parentNode;\n      } while (el !== null && el.nodeType === 1);\n\n      return null;\n    }\n\n    var method = prototype.closest || closestElement;\n    return method.call(element, selector);\n  } // Find all elements\n\n  function getElements(selector) {\n    return this.elements.container.querySelectorAll(selector);\n  } // Find a single element\n\n  function getElement(selector) {\n    return this.elements.container.querySelector(selector);\n  } // Set focus and tab focus class\n\n  function setFocus() {\n    var element = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    var tabFocus = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n    if (!is$1.element(element)) {\n      return;\n    } // Set regular focus\n\n\n    element.focus({\n      preventScroll: true\n    }); // If we want to mimic keyboard focus via tab\n\n    if (tabFocus) {\n      toggleClass(element, this.config.classNames.tabFocus);\n    }\n  }\n\n  var defaultCodecs = {\n    'audio/ogg': 'vorbis',\n    'audio/wav': '1',\n    'video/webm': 'vp8, vorbis',\n    'video/mp4': 'avc1.42E01E, mp4a.40.2',\n    'video/ogg': 'theora'\n  }; // Check for feature support\n\n  var support = {\n    // Basic support\n    audio: 'canPlayType' in document.createElement('audio'),\n    video: 'canPlayType' in document.createElement('video'),\n    // Check for support\n    // Basic functionality vs full UI\n    check: function check(type, provider, playsinline) {\n      var canPlayInline = browser.isIPhone && playsinline && support.playsinline;\n      var api = support[type] || provider !== 'html5';\n      var ui = api && support.rangeInput && (type !== 'video' || !browser.isIPhone || canPlayInline);\n      return {\n        api: api,\n        ui: ui\n      };\n    },\n    // Picture-in-picture support\n    // Safari & Chrome only currently\n    pip: function () {\n      if (browser.isIPhone) {\n        return false;\n      } // Safari\n      // https://developer.apple.com/documentation/webkitjs/adding_picture_in_picture_to_your_safari_media_controls\n\n\n      if (is$1.function(createElement('video').webkitSetPresentationMode)) {\n        return true;\n      } // Chrome\n      // https://developers.google.com/web/updates/2018/10/watch-video-using-picture-in-picture\n\n\n      if (document.pictureInPictureEnabled && !createElement('video').disablePictureInPicture) {\n        return true;\n      }\n\n      return false;\n    }(),\n    // Airplay support\n    // Safari only currently\n    airplay: is$1.function(window.WebKitPlaybackTargetAvailabilityEvent),\n    // Inline playback support\n    // https://webkit.org/blog/6784/new-video-policies-for-ios/\n    playsinline: 'playsInline' in document.createElement('video'),\n    // Check for mime type support against a player instance\n    // Credits: http://diveintohtml5.info/everything.html\n    // Related: http://www.leanbackplayer.com/test/h5mt.html\n    mime: function mime(input) {\n      if (is$1.empty(input)) {\n        return false;\n      }\n\n      var _input$split = input.split('/'),\n          _input$split2 = _slicedToArray(_input$split, 1),\n          mediaType = _input$split2[0];\n\n      var type = input; // Verify we're using HTML5 and there's no media type mismatch\n\n      if (!this.isHTML5 || mediaType !== this.type) {\n        return false;\n      } // Add codec if required\n\n\n      if (Object.keys(defaultCodecs).includes(type)) {\n        type += \"; codecs=\\\"\".concat(defaultCodecs[input], \"\\\"\");\n      }\n\n      try {\n        return Boolean(type && this.media.canPlayType(type).replace(/no/, ''));\n      } catch (e) {\n        return false;\n      }\n    },\n    // Check for textTracks support\n    textTracks: 'textTracks' in document.createElement('video'),\n    // <input type=\"range\"> Sliders\n    rangeInput: function () {\n      var range = document.createElement('input');\n      range.type = 'range';\n      return range.type === 'range';\n    }(),\n    // Touch\n    // NOTE: Remember a device can be mouse + touch enabled so we check on first touch event\n    touch: 'ontouchstart' in document.documentElement,\n    // Detect transitions support\n    transitions: transitionEndEvent !== false,\n    // Reduced motion iOS & MacOS setting\n    // https://webkit.org/blog/7551/responsive-design-for-motion/\n    reducedMotion: 'matchMedia' in window && window.matchMedia('(prefers-reduced-motion)').matches\n  };\n\n  // https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md\n  // https://www.youtube.com/watch?v=NPM6172J22g\n\n  var supportsPassiveListeners = function () {\n    // Test via a getter in the options object to see if the passive property is accessed\n    var supported = false;\n\n    try {\n      var options = Object.defineProperty({}, 'passive', {\n        get: function get() {\n          supported = true;\n          return null;\n        }\n      });\n      window.addEventListener('test', null, options);\n      window.removeEventListener('test', null, options);\n    } catch (e) {// Do nothing\n    }\n\n    return supported;\n  }(); // Toggle event listener\n\n\n  function toggleListener(element, event, callback) {\n    var _this = this;\n\n    var toggle = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    var passive = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n    var capture = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n\n    // Bail if no element, event, or callback\n    if (!element || !('addEventListener' in element) || is$1.empty(event) || !is$1.function(callback)) {\n      return;\n    } // Allow multiple events\n\n\n    var events = event.split(' '); // Build options\n    // Default to just the capture boolean for browsers with no passive listener support\n\n    var options = capture; // If passive events listeners are supported\n\n    if (supportsPassiveListeners) {\n      options = {\n        // Whether the listener can be passive (i.e. default never prevented)\n        passive: passive,\n        // Whether the listener is a capturing listener or not\n        capture: capture\n      };\n    } // If a single node is passed, bind the event listener\n\n\n    events.forEach(function (type) {\n      if (_this && _this.eventListeners && toggle) {\n        // Cache event listener\n        _this.eventListeners.push({\n          element: element,\n          type: type,\n          callback: callback,\n          options: options\n        });\n      }\n\n      element[toggle ? 'addEventListener' : 'removeEventListener'](type, callback, options);\n    });\n  } // Bind event handler\n\n  function on(element) {\n    var events = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n    var callback = arguments.length > 2 ? arguments[2] : undefined;\n    var passive = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n    var capture = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n    toggleListener.call(this, element, events, callback, true, passive, capture);\n  } // Unbind event handler\n\n  function off(element) {\n    var events = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n    var callback = arguments.length > 2 ? arguments[2] : undefined;\n    var passive = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n    var capture = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n    toggleListener.call(this, element, events, callback, false, passive, capture);\n  } // Bind once-only event handler\n\n  function once(element) {\n    var _this2 = this;\n\n    var events = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n    var callback = arguments.length > 2 ? arguments[2] : undefined;\n    var passive = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n    var capture = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n\n    var onceCallback = function onceCallback() {\n      off(element, events, onceCallback, passive, capture);\n\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      callback.apply(_this2, args);\n    };\n\n    toggleListener.call(this, element, events, onceCallback, true, passive, capture);\n  } // Trigger event\n\n  function triggerEvent(element) {\n    var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n    var bubbles = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    var detail = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n    // Bail if no element\n    if (!is$1.element(element) || is$1.empty(type)) {\n      return;\n    } // Create and dispatch the event\n\n\n    var event = new CustomEvent(type, {\n      bubbles: bubbles,\n      detail: _objectSpread2(_objectSpread2({}, detail), {}, {\n        plyr: this\n      })\n    }); // Dispatch the event\n\n    element.dispatchEvent(event);\n  } // Unbind all cached event listeners\n\n  function unbindListeners() {\n    if (this && this.eventListeners) {\n      this.eventListeners.forEach(function (item) {\n        var element = item.element,\n            type = item.type,\n            callback = item.callback,\n            options = item.options;\n        element.removeEventListener(type, callback, options);\n      });\n      this.eventListeners = [];\n    }\n  } // Run method when / if player is ready\n\n  function ready() {\n    var _this3 = this;\n\n    return new Promise(function (resolve) {\n      return _this3.ready ? setTimeout(resolve, 0) : on.call(_this3, _this3.elements.container, 'ready', resolve);\n    }).then(function () {});\n  }\n\n  /**\n   * Silence a Promise-like object.\n   * This is useful for avoiding non-harmful, but potentially confusing \"uncaught\n   * play promise\" rejection error messages.\n   * @param  {Object} value An object that may or may not be `Promise`-like.\n   */\n\n  function silencePromise(value) {\n    if (is$1.promise(value)) {\n      value.then(null, function () {});\n    }\n  }\n\n  function validateRatio(input) {\n    if (!is$1.array(input) && (!is$1.string(input) || !input.includes(':'))) {\n      return false;\n    }\n\n    var ratio = is$1.array(input) ? input : input.split(':');\n    return ratio.map(Number).every(is$1.number);\n  }\n  function reduceAspectRatio(ratio) {\n    if (!is$1.array(ratio) || !ratio.every(is$1.number)) {\n      return null;\n    }\n\n    var _ratio = _slicedToArray(ratio, 2),\n        width = _ratio[0],\n        height = _ratio[1];\n\n    var getDivider = function getDivider(w, h) {\n      return h === 0 ? w : getDivider(h, w % h);\n    };\n\n    var divider = getDivider(width, height);\n    return [width / divider, height / divider];\n  }\n  function getAspectRatio(input) {\n    var parse = function parse(ratio) {\n      return validateRatio(ratio) ? ratio.split(':').map(Number) : null;\n    }; // Try provided ratio\n\n\n    var ratio = parse(input); // Get from config\n\n    if (ratio === null) {\n      ratio = parse(this.config.ratio);\n    } // Get from embed\n\n\n    if (ratio === null && !is$1.empty(this.embed) && is$1.array(this.embed.ratio)) {\n      ratio = this.embed.ratio;\n    } // Get from HTML5 video\n\n\n    if (ratio === null && this.isHTML5) {\n      var _this$media = this.media,\n          videoWidth = _this$media.videoWidth,\n          videoHeight = _this$media.videoHeight;\n      ratio = reduceAspectRatio([videoWidth, videoHeight]);\n    }\n\n    return ratio;\n  } // Set aspect ratio for responsive container\n\n  function setAspectRatio(input) {\n    if (!this.isVideo) {\n      return {};\n    }\n\n    var wrapper = this.elements.wrapper;\n    var ratio = getAspectRatio.call(this, input);\n\n    var _ref = is$1.array(ratio) ? ratio : [0, 0],\n        _ref2 = _slicedToArray(_ref, 2),\n        w = _ref2[0],\n        h = _ref2[1];\n\n    var padding = 100 / w * h;\n    wrapper.style.paddingBottom = \"\".concat(padding, \"%\"); // For Vimeo we have an extra <div> to hide the standard controls and UI\n\n    if (this.isVimeo && !this.config.vimeo.premium && this.supported.ui) {\n      var height = 100 / this.media.offsetWidth * parseInt(window.getComputedStyle(this.media).paddingBottom, 10);\n      var offset = (height - padding) / (height / 50);\n      this.media.style.transform = \"translateY(-\".concat(offset, \"%)\");\n    } else if (this.isHTML5) {\n      wrapper.classList.toggle(this.config.classNames.videoFixedRatio, ratio !== null);\n    }\n\n    return {\n      padding: padding,\n      ratio: ratio\n    };\n  }\n\n  // ==========================================================================\n  var html5 = {\n    getSources: function getSources() {\n      var _this = this;\n\n      if (!this.isHTML5) {\n        return [];\n      }\n\n      var sources = Array.from(this.media.querySelectorAll('source')); // Filter out unsupported sources (if type is specified)\n\n      return sources.filter(function (source) {\n        var type = source.getAttribute('type');\n\n        if (is$1.empty(type)) {\n          return true;\n        }\n\n        return support.mime.call(_this, type);\n      });\n    },\n    // Get quality levels\n    getQualityOptions: function getQualityOptions() {\n      // Whether we're forcing all options (e.g. for streaming)\n      if (this.config.quality.forced) {\n        return this.config.quality.options;\n      } // Get sizes from <source> elements\n\n\n      return html5.getSources.call(this).map(function (source) {\n        return Number(source.getAttribute('size'));\n      }).filter(Boolean);\n    },\n    setup: function setup() {\n      if (!this.isHTML5) {\n        return;\n      }\n\n      var player = this; // Set speed options from config\n\n      player.options.speed = player.config.speed.options; // Set aspect ratio if fixed\n\n      if (!is$1.empty(this.config.ratio)) {\n        setAspectRatio.call(player);\n      } // Quality\n\n\n      Object.defineProperty(player.media, 'quality', {\n        get: function get() {\n          // Get sources\n          var sources = html5.getSources.call(player);\n          var source = sources.find(function (s) {\n            return s.getAttribute('src') === player.source;\n          }); // Return size, if match is found\n\n          return source && Number(source.getAttribute('size'));\n        },\n        set: function set(input) {\n          if (player.quality === input) {\n            return;\n          } // If we're using an an external handler...\n\n\n          if (player.config.quality.forced && is$1.function(player.config.quality.onChange)) {\n            player.config.quality.onChange(input);\n          } else {\n            // Get sources\n            var sources = html5.getSources.call(player); // Get first match for requested size\n\n            var source = sources.find(function (s) {\n              return Number(s.getAttribute('size')) === input;\n            }); // No matching source found\n\n            if (!source) {\n              return;\n            } // Get current state\n\n\n            var _player$media = player.media,\n                currentTime = _player$media.currentTime,\n                paused = _player$media.paused,\n                preload = _player$media.preload,\n                readyState = _player$media.readyState,\n                playbackRate = _player$media.playbackRate; // Set new source\n\n            player.media.src = source.getAttribute('src'); // Prevent loading if preload=\"none\" and the current source isn't loaded (#1044)\n\n            if (preload !== 'none' || readyState) {\n              // Restore time\n              player.once('loadedmetadata', function () {\n                player.speed = playbackRate;\n                player.currentTime = currentTime; // Resume playing\n\n                if (!paused) {\n                  silencePromise(player.play());\n                }\n              }); // Load new source\n\n              player.media.load();\n            }\n          } // Trigger change event\n\n\n          triggerEvent.call(player, player.media, 'qualitychange', false, {\n            quality: input\n          });\n        }\n      });\n    },\n    // Cancel current network requests\n    // See https://github.com/sampotts/WassPlayer/issues/174\n    cancelRequests: function cancelRequests() {\n      if (!this.isHTML5) {\n        return;\n      } // Remove child sources\n\n\n      removeElement(html5.getSources.call(this)); // Set blank video src attribute\n      // This is to prevent a MEDIA_ERR_SRC_NOT_SUPPORTED error\n      // Info: http://stackoverflow.com/questions/32231579/how-to-properly-dispose-of-an-html5-video-and-close-socket-or-connection\n\n      this.media.setAttribute('src', this.config.blankVideo); // Load the new empty source\n      // This will cancel existing requests\n      // See https://github.com/sampotts/WassPlayer/issues/174\n\n      this.media.load(); // Debugging\n\n      this.debug.log('Cancelled network requests');\n    }\n  };\n\n  // ==========================================================================\n\n  function dedupe(array) {\n    if (!is$1.array(array)) {\n      return array;\n    }\n\n    return array.filter(function (item, index) {\n      return array.indexOf(item) === index;\n    });\n  } // Get the closest value in an array\n\n  function closest$1(array, value) {\n    if (!is$1.array(array) || !array.length) {\n      return null;\n    }\n\n    return array.reduce(function (prev, curr) {\n      return Math.abs(curr - value) < Math.abs(prev - value) ? curr : prev;\n    });\n  }\n\n  // ==========================================================================\n\n  function getPercentage(current, max) {\n    if (current === 0 || max === 0 || Number.isNaN(current) || Number.isNaN(max)) {\n      return 0;\n    }\n\n    return (current / max * 100).toFixed(2);\n  } // Replace all occurances of a string in a string\n\n  var replaceAll = function replaceAll() {\n    var input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n    var find = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n    var replace = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n    return input.replace(new RegExp(find.toString().replace(/([.*+?^=!:${}()|[\\]/\\\\])/g, '\\\\$1'), 'g'), replace.toString());\n  }; // Convert to title case\n\n  var toTitleCase = function toTitleCase() {\n    var input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n    return input.toString().replace(/\\w\\S*/g, function (text) {\n      return text.charAt(0).toUpperCase() + text.substr(1).toLowerCase();\n    });\n  }; // Convert string to pascalCase\n\n  function toPascalCase() {\n    var input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n    var string = input.toString(); // Convert kebab case\n\n    string = replaceAll(string, '-', ' '); // Convert snake case\n\n    string = replaceAll(string, '_', ' '); // Convert to title case\n\n    string = toTitleCase(string); // Convert to pascal case\n\n    return replaceAll(string, ' ', '');\n  } // Convert string to pascalCase\n\n  function toCamelCase() {\n    var input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n    var string = input.toString(); // Convert to pascal case\n\n    string = toPascalCase(string); // Convert first character to lowercase\n\n    return string.charAt(0).toLowerCase() + string.slice(1);\n  } // Remove HTML from a string\n\n  function getHTML(element) {\n    var wrapper = document.createElement('div');\n    wrapper.appendChild(element);\n    return wrapper.innerHTML;\n  }\n\n  var resources = {\n    pip: 'PIP',\n    airplay: 'AirPlay',\n    html5: 'HTML5',\n    vimeo: 'Vimeo',\n    youtube: 'YouTube'\n  };\n  var i18n = {\n    get: function get() {\n      var key = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n      var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (is$1.empty(key) || is$1.empty(config)) {\n        return '';\n      }\n\n      var string = getDeep(config.i18n, key);\n\n      if (is$1.empty(string)) {\n        if (Object.keys(resources).includes(key)) {\n          return resources[key];\n        }\n\n        return '';\n      }\n\n      var replace = {\n        '{seektime}': config.seekTime,\n        '{title}': config.title\n      };\n      Object.entries(replace).forEach(function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 2),\n            k = _ref2[0],\n            v = _ref2[1];\n\n        string = replaceAll(string, k, v);\n      });\n      return string;\n    }\n  };\n\n  var Storage = /*#__PURE__*/function () {\n    function Storage(player) {\n      _classCallCheck(this, Storage);\n\n      this.enabled = player.config.storage.enabled;\n      this.key = player.config.storage.key;\n    } // Check for actual support (see if we can use it)\n\n\n    _createClass(Storage, [{\n      key: \"get\",\n      value: function get(key) {\n        if (!Storage.supported || !this.enabled) {\n          return null;\n        }\n\n        var store = window.localStorage.getItem(this.key);\n\n        if (is$1.empty(store)) {\n          return null;\n        }\n\n        var json = JSON.parse(store);\n        return is$1.string(key) && key.length ? json[key] : json;\n      }\n    }, {\n      key: \"set\",\n      value: function set(object) {\n        // Bail if we don't have localStorage support or it's disabled\n        if (!Storage.supported || !this.enabled) {\n          return;\n        } // Can only store objectst\n\n\n        if (!is$1.object(object)) {\n          return;\n        } // Get current storage\n\n\n        var storage = this.get(); // Default to empty object\n\n        if (is$1.empty(storage)) {\n          storage = {};\n        } // Update the working copy of the values\n\n\n        extend(storage, object); // Update storage\n\n        window.localStorage.setItem(this.key, JSON.stringify(storage));\n      }\n    }], [{\n      key: \"supported\",\n      get: function get() {\n        try {\n          if (!('localStorage' in window)) {\n            return false;\n          }\n\n          var test = '___test'; // Try to use it (it might be disabled, e.g. user is in private mode)\n          // see: https://github.com/sampotts/WassPlayer/issues/131\n\n          window.localStorage.setItem(test, test);\n          window.localStorage.removeItem(test);\n          return true;\n        } catch (e) {\n          return false;\n        }\n      }\n    }]);\n\n    return Storage;\n  }();\n\n  // ==========================================================================\n  // Fetch wrapper\n  // Using XHR to avoid issues with older browsers\n  // ==========================================================================\n  function fetch(url) {\n    var responseType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'text';\n    return new Promise(function (resolve, reject) {\n      try {\n        var request = new XMLHttpRequest(); // Check for CORS support\n\n        if (!('withCredentials' in request)) {\n          return;\n        }\n\n        request.addEventListener('load', function () {\n          if (responseType === 'text') {\n            try {\n              resolve(JSON.parse(request.responseText));\n            } catch (e) {\n              resolve(request.responseText);\n            }\n          } else {\n            resolve(request.response);\n          }\n        });\n        request.addEventListener('error', function () {\n          throw new Error(request.status);\n        });\n        request.open('GET', url, true); // Set the required response type\n\n        request.responseType = responseType;\n        request.send();\n      } catch (e) {\n        reject(e);\n      }\n    });\n  }\n\n  // ==========================================================================\n\n  function loadSprite(url, id) {\n    if (!is$1.string(url)) {\n      return;\n    }\n\n    var prefix = 'cache';\n    var hasId = is$1.string(id);\n    var isCached = false;\n\n    var exists = function exists() {\n      return document.getElementById(id) !== null;\n    };\n\n    var update = function update(container, data) {\n      // eslint-disable-next-line no-param-reassign\n      container.innerHTML = data; // Check again incase of race condition\n\n      if (hasId && exists()) {\n        return;\n      } // Inject the SVG to the body\n\n\n      document.body.insertAdjacentElement('afterbegin', container);\n    }; // Only load once if ID set\n\n\n    if (!hasId || !exists()) {\n      var useStorage = Storage.supported; // Create container\n\n      var container = document.createElement('div');\n      container.setAttribute('hidden', '');\n\n      if (hasId) {\n        container.setAttribute('id', id);\n      } // Check in cache\n\n\n      if (useStorage) {\n        var cached = window.localStorage.getItem(\"\".concat(prefix, \"-\").concat(id));\n        isCached = cached !== null;\n\n        if (isCached) {\n          var data = JSON.parse(cached);\n          update(container, data.content);\n        }\n      } // Get the sprite\n\n\n      fetch(url).then(function (result) {\n        if (is$1.empty(result)) {\n          return;\n        }\n\n        if (useStorage) {\n          window.localStorage.setItem(\"\".concat(prefix, \"-\").concat(id), JSON.stringify({\n            content: result\n          }));\n        }\n\n        update(container, result);\n      }).catch(function () {});\n    }\n  }\n\n  // ==========================================================================\n\n  var getHours = function getHours(value) {\n    return Math.trunc(value / 60 / 60 % 60, 10);\n  };\n  var getMinutes = function getMinutes(value) {\n    return Math.trunc(value / 60 % 60, 10);\n  };\n  var getSeconds = function getSeconds(value) {\n    return Math.trunc(value % 60, 10);\n  }; // Format time to UI friendly string\n\n  function formatTime() {\n    var time = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    var displayHours = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    var inverted = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n    // Bail if the value isn't a number\n    if (!is$1.number(time)) {\n      return formatTime(undefined, displayHours, inverted);\n    } // Format time component to add leading zero\n\n\n    var format = function format(value) {\n      return \"0\".concat(value).slice(-2);\n    }; // Breakdown to hours, mins, secs\n\n\n    var hours = getHours(time);\n    var mins = getMinutes(time);\n    var secs = getSeconds(time); // Do we need to display hours?\n\n    if (displayHours || hours > 0) {\n      hours = \"\".concat(hours, \":\");\n    } else {\n      hours = '';\n    } // Render\n\n\n    return \"\".concat(inverted && time > 0 ? '-' : '').concat(hours).concat(format(mins), \":\").concat(format(secs));\n  }\n\n  var controls = {\n    // Get icon URL\n    getIconUrl: function getIconUrl() {\n      var url = new URL(this.config.iconUrl, window.location);\n      var cors = url.host !== window.location.host || browser.isIE && !window.svg4everybody;\n      return {\n        url: this.config.iconUrl,\n        cors: cors\n      };\n    },\n    // Find the UI controls\n    findElements: function findElements() {\n      try {\n        this.elements.controls = getElement.call(this, this.config.selectors.controls.wrapper); // Buttons\n\n        this.elements.buttons = {\n          play: getElements.call(this, this.config.selectors.buttons.play),\n          pause: getElement.call(this, this.config.selectors.buttons.pause),\n          restart: getElement.call(this, this.config.selectors.buttons.restart),\n          rewind: getElement.call(this, this.config.selectors.buttons.rewind),\n          fastForward: getElement.call(this, this.config.selectors.buttons.fastForward),\n          mute: getElement.call(this, this.config.selectors.buttons.mute),\n          pip: getElement.call(this, this.config.selectors.buttons.pip),\n          airplay: getElement.call(this, this.config.selectors.buttons.airplay),\n          settings: getElement.call(this, this.config.selectors.buttons.settings),\n          captions: getElement.call(this, this.config.selectors.buttons.captions),\n          fullscreen: getElement.call(this, this.config.selectors.buttons.fullscreen)\n        }; // Progress\n\n        this.elements.progress = getElement.call(this, this.config.selectors.progress); // Inputs\n\n        this.elements.inputs = {\n          seek: getElement.call(this, this.config.selectors.inputs.seek),\n          volume: getElement.call(this, this.config.selectors.inputs.volume)\n        }; // Display\n\n        this.elements.display = {\n          buffer: getElement.call(this, this.config.selectors.display.buffer),\n          currentTime: getElement.call(this, this.config.selectors.display.currentTime),\n          duration: getElement.call(this, this.config.selectors.display.duration)\n        }; // Seek tooltip\n\n        if (is$1.element(this.elements.progress)) {\n          this.elements.display.seekTooltip = this.elements.progress.querySelector(\".\".concat(this.config.classNames.tooltip));\n        }\n\n        return true;\n      } catch (error) {\n        // Log it\n        this.debug.warn('It looks like there is a problem with your custom controls HTML', error); // Restore native video controls\n\n        this.toggleNativeControls(true);\n        return false;\n      }\n    },\n    // Create <svg> icon\n    createIcon: function createIcon(type, attributes) {\n      var namespace = 'http://www.w3.org/2000/svg';\n      var iconUrl = controls.getIconUrl.call(this);\n      var iconPath = \"\".concat(!iconUrl.cors ? iconUrl.url : '', \"#\").concat(this.config.iconPrefix); // Create <svg>\n\n      var icon = document.createElementNS(namespace, 'svg');\n      setAttributes(icon, extend(attributes, {\n        'aria-hidden': 'true',\n        focusable: 'false'\n      })); // Create the <use> to reference sprite\n\n      var use = document.createElementNS(namespace, 'use');\n      var path = \"\".concat(iconPath, \"-\").concat(type); // Set `href` attributes\n      // https://github.com/sampotts/WassPlayer/issues/460\n      // https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/xlink:href\n\n      if ('href' in use) {\n        use.setAttributeNS('http://www.w3.org/1999/xlink', 'href', path);\n      } // Always set the older attribute even though it's \"deprecated\" (it'll be around for ages)\n\n\n      use.setAttributeNS('http://www.w3.org/1999/xlink', 'xlink:href', path); // Add <use> to <svg>\n\n      icon.appendChild(use);\n      return icon;\n    },\n    // Create hidden text label\n    createLabel: function createLabel(key) {\n      var attr = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var text = i18n.get(key, this.config);\n\n      var attributes = _objectSpread2(_objectSpread2({}, attr), {}, {\n        class: [attr.class, this.config.classNames.hidden].filter(Boolean).join(' ')\n      });\n\n      return createElement('span', attributes, text);\n    },\n    // Create a badge\n    createBadge: function createBadge(text) {\n      if (is$1.empty(text)) {\n        return null;\n      }\n\n      var badge = createElement('span', {\n        class: this.config.classNames.menu.value\n      });\n      badge.appendChild(createElement('span', {\n        class: this.config.classNames.menu.badge\n      }, text));\n      return badge;\n    },\n    // Create a <button>\n    createButton: function createButton(buttonType, attr) {\n      var _this = this;\n\n      var attributes = extend({}, attr);\n      var type = toCamelCase(buttonType);\n      var props = {\n        element: 'button',\n        toggle: false,\n        label: null,\n        icon: null,\n        labelPressed: null,\n        iconPressed: null\n      };\n      ['element', 'icon', 'label'].forEach(function (key) {\n        if (Object.keys(attributes).includes(key)) {\n          props[key] = attributes[key];\n          delete attributes[key];\n        }\n      }); // Default to 'button' type to prevent form submission\n\n      if (props.element === 'button' && !Object.keys(attributes).includes('type')) {\n        attributes.type = 'button';\n      } // Set class name\n\n\n      if (Object.keys(attributes).includes('class')) {\n        if (!attributes.class.split(' ').some(function (c) {\n          return c === _this.config.classNames.control;\n        })) {\n          extend(attributes, {\n            class: \"\".concat(attributes.class, \" \").concat(this.config.classNames.control)\n          });\n        }\n      } else {\n        attributes.class = this.config.classNames.control;\n      } // Large play button\n\n\n      switch (buttonType) {\n        case 'play':\n          props.toggle = true;\n          props.label = 'play';\n          props.labelPressed = 'pause';\n          props.icon = 'play';\n          props.iconPressed = 'pause';\n          break;\n\n        case 'mute':\n          props.toggle = true;\n          props.label = 'mute';\n          props.labelPressed = 'unmute';\n          props.icon = 'volume';\n          props.iconPressed = 'muted';\n          break;\n\n        case 'captions':\n          props.toggle = true;\n          props.label = 'enableCaptions';\n          props.labelPressed = 'disableCaptions';\n          props.icon = 'captions-off';\n          props.iconPressed = 'captions-on';\n          break;\n\n        case 'fullscreen':\n          props.toggle = true;\n          props.label = 'enterFullscreen';\n          props.labelPressed = 'exitFullscreen';\n          props.icon = 'enter-fullscreen';\n          props.iconPressed = 'exit-fullscreen';\n          break;\n\n        case 'play-large':\n          attributes.class += \" \".concat(this.config.classNames.control, \"--overlaid\");\n          type = 'play';\n          props.label = 'play';\n          props.icon = 'play';\n          break;\n\n        default:\n          if (is$1.empty(props.label)) {\n            props.label = type;\n          }\n\n          if (is$1.empty(props.icon)) {\n            props.icon = buttonType;\n          }\n\n      }\n\n      var button = createElement(props.element); // Setup toggle icon and labels\n\n      if (props.toggle) {\n        // Icon\n        button.appendChild(controls.createIcon.call(this, props.iconPressed, {\n          class: 'icon--pressed'\n        }));\n        button.appendChild(controls.createIcon.call(this, props.icon, {\n          class: 'icon--not-pressed'\n        })); // Label/Tooltip\n\n        button.appendChild(controls.createLabel.call(this, props.labelPressed, {\n          class: 'label--pressed'\n        }));\n        button.appendChild(controls.createLabel.call(this, props.label, {\n          class: 'label--not-pressed'\n        }));\n      } else {\n        button.appendChild(controls.createIcon.call(this, props.icon));\n        button.appendChild(controls.createLabel.call(this, props.label));\n      } // Merge and set attributes\n\n\n      extend(attributes, getAttributesFromSelector(this.config.selectors.buttons[type], attributes));\n      setAttributes(button, attributes); // We have multiple play buttons\n\n      if (type === 'play') {\n        if (!is$1.array(this.elements.buttons[type])) {\n          this.elements.buttons[type] = [];\n        }\n\n        this.elements.buttons[type].push(button);\n      } else {\n        this.elements.buttons[type] = button;\n      }\n\n      return button;\n    },\n    // Create an <input type='range'>\n    createRange: function createRange(type, attributes) {\n      // Seek input\n      var input = createElement('input', extend(getAttributesFromSelector(this.config.selectors.inputs[type]), {\n        type: 'range',\n        min: 0,\n        max: 100,\n        step: 0.01,\n        value: 0,\n        autocomplete: 'off',\n        // A11y fixes for https://github.com/sampotts/WassPlayer/issues/905\n        role: 'slider',\n        'aria-label': i18n.get(type, this.config),\n        'aria-valuemin': 0,\n        'aria-valuemax': 100,\n        'aria-valuenow': 0\n      }, attributes));\n      this.elements.inputs[type] = input; // Set the fill for webkit now\n\n      controls.updateRangeFill.call(this, input); // Improve support on touch devices\n\n      RangeTouch.setup(input);\n      return input;\n    },\n    // Create a <progress>\n    createProgress: function createProgress(type, attributes) {\n      var progress = createElement('progress', extend(getAttributesFromSelector(this.config.selectors.display[type]), {\n        min: 0,\n        max: 100,\n        value: 0,\n        role: 'progressbar',\n        'aria-hidden': true\n      }, attributes)); // Create the label inside\n\n      if (type !== 'volume') {\n        progress.appendChild(createElement('span', null, '0'));\n        var suffixKey = {\n          played: 'played',\n          buffer: 'buffered'\n        }[type];\n        var suffix = suffixKey ? i18n.get(suffixKey, this.config) : '';\n        progress.innerText = \"% \".concat(suffix.toLowerCase());\n      }\n\n      this.elements.display[type] = progress;\n      return progress;\n    },\n    // Create time display\n    createTime: function createTime(type, attrs) {\n      var attributes = getAttributesFromSelector(this.config.selectors.display[type], attrs);\n      var container = createElement('div', extend(attributes, {\n        class: \"\".concat(attributes.class ? attributes.class : '', \" \").concat(this.config.classNames.display.time, \" \").trim(),\n        'aria-label': i18n.get(type, this.config)\n      }), '00:00'); // Reference for updates\n\n      this.elements.display[type] = container;\n      return container;\n    },\n    // Bind keyboard shortcuts for a menu item\n    // We have to bind to keyup otherwise Firefox triggers a click when a keydown event handler shifts focus\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=1220143\n    bindMenuItemShortcuts: function bindMenuItemShortcuts(menuItem, type) {\n      var _this2 = this;\n\n      // Navigate through menus via arrow keys and space\n      on.call(this, menuItem, 'keydown keyup', function (event) {\n        // We only care about space and   \n        if (![32, 38, 39, 40].includes(event.which)) {\n          return;\n        } // Prevent play / seek\n\n\n        event.preventDefault();\n        event.stopPropagation(); // We're just here to prevent the keydown bubbling\n\n        if (event.type === 'keydown') {\n          return;\n        }\n\n        var isRadioButton = matches$1(menuItem, '[role=\"menuitemradio\"]'); // Show the respective menu\n\n        if (!isRadioButton && [32, 39].includes(event.which)) {\n          controls.showMenuPanel.call(_this2, type, true);\n        } else {\n          var target;\n\n          if (event.which !== 32) {\n            if (event.which === 40 || isRadioButton && event.which === 39) {\n              target = menuItem.nextElementSibling;\n\n              if (!is$1.element(target)) {\n                target = menuItem.parentNode.firstElementChild;\n              }\n            } else {\n              target = menuItem.previousElementSibling;\n\n              if (!is$1.element(target)) {\n                target = menuItem.parentNode.lastElementChild;\n              }\n            }\n\n            setFocus.call(_this2, target, true);\n          }\n        }\n      }, false); // Enter will fire a `click` event but we still need to manage focus\n      // So we bind to keyup which fires after and set focus here\n\n      on.call(this, menuItem, 'keyup', function (event) {\n        if (event.which !== 13) {\n          return;\n        }\n\n        controls.focusFirstMenuItem.call(_this2, null, true);\n      });\n    },\n    // Create a settings menu item\n    createMenuItem: function createMenuItem(_ref) {\n      var _this3 = this;\n\n      var value = _ref.value,\n          list = _ref.list,\n          type = _ref.type,\n          title = _ref.title,\n          _ref$badge = _ref.badge,\n          badge = _ref$badge === void 0 ? null : _ref$badge,\n          _ref$checked = _ref.checked,\n          checked = _ref$checked === void 0 ? false : _ref$checked;\n      var attributes = getAttributesFromSelector(this.config.selectors.inputs[type]);\n      var menuItem = createElement('button', extend(attributes, {\n        type: 'button',\n        role: 'menuitemradio',\n        class: \"\".concat(this.config.classNames.control, \" \").concat(attributes.class ? attributes.class : '').trim(),\n        'aria-checked': checked,\n        value: value\n      }));\n      var flex = createElement('span'); // We have to set as HTML incase of special characters\n\n      flex.innerHTML = title;\n\n      if (is$1.element(badge)) {\n        flex.appendChild(badge);\n      }\n\n      menuItem.appendChild(flex); // Replicate radio button behaviour\n\n      Object.defineProperty(menuItem, 'checked', {\n        enumerable: true,\n        get: function get() {\n          return menuItem.getAttribute('aria-checked') === 'true';\n        },\n        set: function set(check) {\n          // Ensure exclusivity\n          if (check) {\n            Array.from(menuItem.parentNode.children).filter(function (node) {\n              return matches$1(node, '[role=\"menuitemradio\"]');\n            }).forEach(function (node) {\n              return node.setAttribute('aria-checked', 'false');\n            });\n          }\n\n          menuItem.setAttribute('aria-checked', check ? 'true' : 'false');\n        }\n      });\n      this.listeners.bind(menuItem, 'click keyup', function (event) {\n        if (is$1.keyboardEvent(event) && event.which !== 32) {\n          return;\n        }\n\n        event.preventDefault();\n        event.stopPropagation();\n        menuItem.checked = true;\n\n        switch (type) {\n          case 'language':\n            _this3.currentTrack = Number(value);\n            break;\n\n          case 'quality':\n            _this3.quality = value;\n            break;\n\n          case 'speed':\n            _this3.speed = parseFloat(value);\n            break;\n        }\n\n        controls.showMenuPanel.call(_this3, 'home', is$1.keyboardEvent(event));\n      }, type, false);\n      controls.bindMenuItemShortcuts.call(this, menuItem, type);\n      list.appendChild(menuItem);\n    },\n    // Format a time for display\n    formatTime: function formatTime$1() {\n      var time = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var inverted = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n      // Bail if the value isn't a number\n      if (!is$1.number(time)) {\n        return time;\n      } // Always display hours if duration is over an hour\n\n\n      var forceHours = getHours(this.duration) > 0;\n      return formatTime(time, forceHours, inverted);\n    },\n    // Update the displayed time\n    updateTimeDisplay: function updateTimeDisplay() {\n      var target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      var time = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var inverted = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n      // Bail if there's no element to display or the value isn't a number\n      if (!is$1.element(target) || !is$1.number(time)) {\n        return;\n      } // eslint-disable-next-line no-param-reassign\n\n\n      target.innerText = controls.formatTime(time, inverted);\n    },\n    // Update volume UI and storage\n    updateVolume: function updateVolume() {\n      if (!this.supported.ui) {\n        return;\n      } // Update range\n\n\n      if (is$1.element(this.elements.inputs.volume)) {\n        controls.setRange.call(this, this.elements.inputs.volume, this.muted ? 0 : this.volume);\n      } // Update mute state\n\n\n      if (is$1.element(this.elements.buttons.mute)) {\n        this.elements.buttons.mute.pressed = this.muted || this.volume === 0;\n      }\n    },\n    // Update seek value and lower fill\n    setRange: function setRange(target) {\n      var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n      if (!is$1.element(target)) {\n        return;\n      } // eslint-disable-next-line\n\n\n      target.value = value; // Webkit range fill\n\n      controls.updateRangeFill.call(this, target);\n    },\n    // Update <progress> elements\n    updateProgress: function updateProgress(event) {\n      var _this4 = this;\n\n      if (!this.supported.ui || !is$1.event(event)) {\n        return;\n      }\n\n      var value = 0;\n\n      var setProgress = function setProgress(target, input) {\n        var val = is$1.number(input) ? input : 0;\n        var progress = is$1.element(target) ? target : _this4.elements.display.buffer; // Update value and label\n\n        if (is$1.element(progress)) {\n          progress.value = val; // Update text label inside\n\n          var label = progress.getElementsByTagName('span')[0];\n\n          if (is$1.element(label)) {\n            label.childNodes[0].nodeValue = val;\n          }\n        }\n      };\n\n      if (event) {\n        switch (event.type) {\n          // Video playing\n          case 'timeupdate':\n          case 'seeking':\n          case 'seeked':\n            value = getPercentage(this.currentTime, this.duration); // Set seek range value only if it's a 'natural' time event\n\n            if (event.type === 'timeupdate') {\n              controls.setRange.call(this, this.elements.inputs.seek, value);\n            }\n\n            break;\n          // Check buffer status\n\n          case 'playing':\n          case 'progress':\n            setProgress(this.elements.display.buffer, this.buffered * 100);\n            break;\n        }\n      }\n    },\n    // Webkit polyfill for lower fill range\n    updateRangeFill: function updateRangeFill(target) {\n      // Get range from event if event passed\n      var range = is$1.event(target) ? target.target : target; // Needs to be a valid <input type='range'>\n\n      if (!is$1.element(range) || range.getAttribute('type') !== 'range') {\n        return;\n      } // Set aria values for https://github.com/sampotts/WassPlayer/issues/905\n\n\n      if (matches$1(range, this.config.selectors.inputs.seek)) {\n        range.setAttribute('aria-valuenow', this.currentTime);\n        var currentTime = controls.formatTime(this.currentTime);\n        var duration = controls.formatTime(this.duration);\n        var format = i18n.get('seekLabel', this.config);\n        range.setAttribute('aria-valuetext', format.replace('{currentTime}', currentTime).replace('{duration}', duration));\n      } else if (matches$1(range, this.config.selectors.inputs.volume)) {\n        var percent = range.value * 100;\n        range.setAttribute('aria-valuenow', percent);\n        range.setAttribute('aria-valuetext', \"\".concat(percent.toFixed(1), \"%\"));\n      } else {\n        range.setAttribute('aria-valuenow', range.value);\n      } // WebKit only\n\n\n      if (!browser.isWebkit) {\n        return;\n      } // Set CSS custom property\n\n\n      range.style.setProperty('--value', \"\".concat(range.value / range.max * 100, \"%\"));\n    },\n    // Update hover tooltip for seeking\n    updateSeekTooltip: function updateSeekTooltip(event) {\n      var _this5 = this;\n\n      // Bail if setting not true\n      if (!this.config.tooltips.seek || !is$1.element(this.elements.inputs.seek) || !is$1.element(this.elements.display.seekTooltip) || this.duration === 0) {\n        return;\n      }\n\n      var visible = \"\".concat(this.config.classNames.tooltip, \"--visible\");\n\n      var toggle = function toggle(show) {\n        return toggleClass(_this5.elements.display.seekTooltip, visible, show);\n      }; // Hide on touch\n\n\n      if (this.touch) {\n        toggle(false);\n        return;\n      } // Determine percentage, if already visible\n\n\n      var percent = 0;\n      var clientRect = this.elements.progress.getBoundingClientRect();\n\n      if (is$1.event(event)) {\n        percent = 100 / clientRect.width * (event.pageX - clientRect.left);\n      } else if (hasClass(this.elements.display.seekTooltip, visible)) {\n        percent = parseFloat(this.elements.display.seekTooltip.style.left, 10);\n      } else {\n        return;\n      } // Set bounds\n\n\n      if (percent < 0) {\n        percent = 0;\n      } else if (percent > 100) {\n        percent = 100;\n      } // Display the time a click would seek to\n\n\n      controls.updateTimeDisplay.call(this, this.elements.display.seekTooltip, this.duration / 100 * percent); // Set position\n\n      this.elements.display.seekTooltip.style.left = \"\".concat(percent, \"%\"); // Show/hide the tooltip\n      // If the event is a moues in/out and percentage is inside bounds\n\n      if (is$1.event(event) && ['mouseenter', 'mouseleave'].includes(event.type)) {\n        toggle(event.type === 'mouseenter');\n      }\n    },\n    // Handle time change event\n    timeUpdate: function timeUpdate(event) {\n      // Only invert if only one time element is displayed and used for both duration and currentTime\n      var invert = !is$1.element(this.elements.display.duration) && this.config.invertTime; // Duration\n\n      controls.updateTimeDisplay.call(this, this.elements.display.currentTime, invert ? this.duration - this.currentTime : this.currentTime, invert); // Ignore updates while seeking\n\n      if (event && event.type === 'timeupdate' && this.media.seeking) {\n        return;\n      } // Playing progress\n\n\n      controls.updateProgress.call(this, event);\n    },\n    // Show the duration on metadataloaded or durationchange events\n    durationUpdate: function durationUpdate() {\n      // Bail if no UI or durationchange event triggered after playing/seek when invertTime is false\n      if (!this.supported.ui || !this.config.invertTime && this.currentTime) {\n        return;\n      } // If duration is the 2**32 (shaka), Infinity (HLS), DASH-IF (Number.MAX_SAFE_INTEGER || Number.MAX_VALUE) indicating live we hide the currentTime and progressbar.\n      // https://github.com/video-dev/hls.js/blob/5820d29d3c4c8a46e8b75f1e3afa3e68c1a9a2db/src/controller/buffer-controller.js#L415\n      // https://github.com/google/shaka-player/blob/4d889054631f4e1cf0fbd80ddd2b71887c02e232/lib/media/streaming_engine.js#L1062\n      // https://github.com/Dash-Industry-Forum/dash.js/blob/69859f51b969645b234666800d4cb596d89c602d/src/dash/models/DashManifestModel.js#L338\n\n\n      if (this.duration >= Math.pow(2, 32)) {\n        toggleHidden(this.elements.display.currentTime, true);\n        toggleHidden(this.elements.progress, true);\n        return;\n      } // Update ARIA values\n\n\n      if (is$1.element(this.elements.inputs.seek)) {\n        this.elements.inputs.seek.setAttribute('aria-valuemax', this.duration);\n      } // If there's a spot to display duration\n\n\n      var hasDuration = is$1.element(this.elements.display.duration); // If there's only one time display, display duration there\n\n      if (!hasDuration && this.config.displayDuration && this.paused) {\n        controls.updateTimeDisplay.call(this, this.elements.display.currentTime, this.duration);\n      } // If there's a duration element, update content\n\n\n      if (hasDuration) {\n        controls.updateTimeDisplay.call(this, this.elements.display.duration, this.duration);\n      } // Update the tooltip (if visible)\n\n\n      controls.updateSeekTooltip.call(this);\n    },\n    // Hide/show a tab\n    toggleMenuButton: function toggleMenuButton(setting, toggle) {\n      toggleHidden(this.elements.settings.buttons[setting], !toggle);\n    },\n    // Update the selected setting\n    updateSetting: function updateSetting(setting, container, input) {\n      var pane = this.elements.settings.panels[setting];\n      var value = null;\n      var list = container;\n\n      if (setting === 'captions') {\n        value = this.currentTrack;\n      } else {\n        value = !is$1.empty(input) ? input : this[setting]; // Get default\n\n        if (is$1.empty(value)) {\n          value = this.config[setting].default;\n        } // Unsupported value\n\n\n        if (!is$1.empty(this.options[setting]) && !this.options[setting].includes(value)) {\n          this.debug.warn(\"Unsupported value of '\".concat(value, \"' for \").concat(setting));\n          return;\n        } // Disabled value\n\n\n        if (!this.config[setting].options.includes(value)) {\n          this.debug.warn(\"Disabled value of '\".concat(value, \"' for \").concat(setting));\n          return;\n        }\n      } // Get the list if we need to\n\n\n      if (!is$1.element(list)) {\n        list = pane && pane.querySelector('[role=\"menu\"]');\n      } // If there's no list it means it's not been rendered...\n\n\n      if (!is$1.element(list)) {\n        return;\n      } // Update the label\n\n\n      var label = this.elements.settings.buttons[setting].querySelector(\".\".concat(this.config.classNames.menu.value));\n      label.innerHTML = controls.getLabel.call(this, setting, value); // Find the radio option and check it\n\n      var target = list && list.querySelector(\"[value=\\\"\".concat(value, \"\\\"]\"));\n\n      if (is$1.element(target)) {\n        target.checked = true;\n      }\n    },\n    // Translate a value into a nice label\n    getLabel: function getLabel(setting, value) {\n      switch (setting) {\n        case 'speed':\n          return value === 1 ? i18n.get('normal', this.config) : \"\".concat(value, \"&times;\");\n\n        case 'quality':\n          if (is$1.number(value)) {\n            var label = i18n.get(\"qualityLabel.\".concat(value), this.config);\n\n            if (!label.length) {\n              return \"\".concat(value, \"p\");\n            }\n\n            return label;\n          }\n\n          return toTitleCase(value);\n\n        case 'captions':\n          return captions.getLabel.call(this);\n\n        default:\n          return null;\n      }\n    },\n    // Set the quality menu\n    setQualityMenu: function setQualityMenu(options) {\n      var _this6 = this;\n\n      // Menu required\n      if (!is$1.element(this.elements.settings.panels.quality)) {\n        return;\n      }\n\n      var type = 'quality';\n      var list = this.elements.settings.panels.quality.querySelector('[role=\"menu\"]'); // Set options if passed and filter based on uniqueness and config\n\n      if (is$1.array(options)) {\n        this.options.quality = dedupe(options).filter(function (quality) {\n          return _this6.config.quality.options.includes(quality);\n        });\n      } // Toggle the pane and tab\n\n\n      var toggle = !is$1.empty(this.options.quality) && this.options.quality.length > 1;\n      controls.toggleMenuButton.call(this, type, toggle); // Empty the menu\n\n      emptyElement(list); // Check if we need to toggle the parent\n\n      controls.checkMenu.call(this); // If we're hiding, nothing more to do\n\n      if (!toggle) {\n        return;\n      } // Get the badge HTML for HD, 4K etc\n\n\n      var getBadge = function getBadge(quality) {\n        var label = i18n.get(\"qualityBadge.\".concat(quality), _this6.config);\n\n        if (!label.length) {\n          return null;\n        }\n\n        return controls.createBadge.call(_this6, label);\n      }; // Sort options by the config and then render options\n\n\n      this.options.quality.sort(function (a, b) {\n        var sorting = _this6.config.quality.options;\n        return sorting.indexOf(a) > sorting.indexOf(b) ? 1 : -1;\n      }).forEach(function (quality) {\n        controls.createMenuItem.call(_this6, {\n          value: quality,\n          list: list,\n          type: type,\n          title: controls.getLabel.call(_this6, 'quality', quality),\n          badge: getBadge(quality)\n        });\n      });\n      controls.updateSetting.call(this, type, list);\n    },\n    // Set the looping options\n\n    /* setLoopMenu() {\n          // Menu required\n          if (!is.element(this.elements.settings.panels.loop)) {\n              return;\n          }\n           const options = ['start', 'end', 'all', 'reset'];\n          const list = this.elements.settings.panels.loop.querySelector('[role=\"menu\"]');\n           // Show the pane and tab\n          toggleHidden(this.elements.settings.buttons.loop, false);\n          toggleHidden(this.elements.settings.panels.loop, false);\n           // Toggle the pane and tab\n          const toggle = !is.empty(this.loop.options);\n          controls.toggleMenuButton.call(this, 'loop', toggle);\n           // Empty the menu\n          emptyElement(list);\n           options.forEach(option => {\n              const item = createElement('li');\n               const button = createElement(\n                  'button',\n                  extend(getAttributesFromSelector(this.config.selectors.buttons.loop), {\n                      type: 'button',\n                      class: this.config.classNames.control,\n                      'data-wassPlayer-loop-action': option,\n                  }),\n                  i18n.get(option, this.config)\n              );\n               if (['start', 'end'].includes(option)) {\n                  const badge = controls.createBadge.call(this, '00:00');\n                  button.appendChild(badge);\n              }\n               item.appendChild(button);\n              list.appendChild(item);\n          });\n      }, */\n    // Get current selected caption language\n    // Set a list of available captions languages\n    setCaptionsMenu: function setCaptionsMenu() {\n      var _this7 = this;\n\n      // Menu required\n      if (!is$1.element(this.elements.settings.panels.captions)) {\n        return;\n      }\n\n      var type = 'captions';\n      var list = this.elements.settings.panels.captions.querySelector('[role=\"menu\"]');\n      var tracks = captions.getTracks.call(this);\n      var toggle = Boolean(tracks.length); // Toggle the pane and tab\n\n      controls.toggleMenuButton.call(this, type, toggle); // Empty the menu\n\n      emptyElement(list); // Check if we need to toggle the parent\n\n      controls.checkMenu.call(this); // If there's no captions, bail\n\n      if (!toggle) {\n        return;\n      } // Generate options data\n\n\n      var options = tracks.map(function (track, value) {\n        return {\n          value: value,\n          checked: _this7.captions.toggled && _this7.currentTrack === value,\n          title: captions.getLabel.call(_this7, track),\n          badge: track.language && controls.createBadge.call(_this7, track.language.toUpperCase()),\n          list: list,\n          type: 'language'\n        };\n      }); // Add the \"Disabled\" option to turn off captions\n\n      options.unshift({\n        value: -1,\n        checked: !this.captions.toggled,\n        title: i18n.get('disabled', this.config),\n        list: list,\n        type: 'language'\n      }); // Generate options\n\n      options.forEach(controls.createMenuItem.bind(this));\n      controls.updateSetting.call(this, type, list);\n    },\n    // Set a list of available captions languages\n    setSpeedMenu: function setSpeedMenu() {\n      var _this8 = this;\n\n      // Menu required\n      if (!is$1.element(this.elements.settings.panels.speed)) {\n        return;\n      }\n\n      var type = 'speed';\n      var list = this.elements.settings.panels.speed.querySelector('[role=\"menu\"]'); // Filter out invalid speeds\n\n      this.options.speed = this.options.speed.filter(function (o) {\n        return o >= _this8.minimumSpeed && o <= _this8.maximumSpeed;\n      }); // Toggle the pane and tab\n\n      var toggle = !is$1.empty(this.options.speed) && this.options.speed.length > 1;\n      controls.toggleMenuButton.call(this, type, toggle); // Empty the menu\n\n      emptyElement(list); // Check if we need to toggle the parent\n\n      controls.checkMenu.call(this); // If we're hiding, nothing more to do\n\n      if (!toggle) {\n        return;\n      } // Create items\n\n\n      this.options.speed.forEach(function (speed) {\n        controls.createMenuItem.call(_this8, {\n          value: speed,\n          list: list,\n          type: type,\n          title: controls.getLabel.call(_this8, 'speed', speed)\n        });\n      });\n      controls.updateSetting.call(this, type, list);\n    },\n    // Check if we need to hide/show the settings menu\n    checkMenu: function checkMenu() {\n      var buttons = this.elements.settings.buttons;\n      var visible = !is$1.empty(buttons) && Object.values(buttons).some(function (button) {\n        return !button.hidden;\n      });\n      toggleHidden(this.elements.settings.menu, !visible);\n    },\n    // Focus the first menu item in a given (or visible) menu\n    focusFirstMenuItem: function focusFirstMenuItem(pane) {\n      var tabFocus = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n      if (this.elements.settings.popup.hidden) {\n        return;\n      }\n\n      var target = pane;\n\n      if (!is$1.element(target)) {\n        target = Object.values(this.elements.settings.panels).find(function (p) {\n          return !p.hidden;\n        });\n      }\n\n      var firstItem = target.querySelector('[role^=\"menuitem\"]');\n      setFocus.call(this, firstItem, tabFocus);\n    },\n    // Show/hide menu\n    toggleMenu: function toggleMenu(input) {\n      var popup = this.elements.settings.popup;\n      var button = this.elements.buttons.settings; // Menu and button are required\n\n      if (!is$1.element(popup) || !is$1.element(button)) {\n        return;\n      } // True toggle by default\n\n\n      var hidden = popup.hidden;\n      var show = hidden;\n\n      if (is$1.boolean(input)) {\n        show = input;\n      } else if (is$1.keyboardEvent(input) && input.which === 27) {\n        show = false;\n      } else if (is$1.event(input)) {\n        // If WassPlayer is in a shadowDOM, the event target is set to the component, instead of the\n        // Element in the shadowDOM. The path, if available, is complete.\n        var target = is$1.function(input.composedPath) ? input.composedPath()[0] : input.target;\n        var isMenuItem = popup.contains(target); // If the click was inside the menu or if the click\n        // wasn't the button or menu item and we're trying to\n        // show the menu (a doc click shouldn't show the menu)\n\n        if (isMenuItem || !isMenuItem && input.target !== button && show) {\n          return;\n        }\n      } // Set button attributes\n\n\n      button.setAttribute('aria-expanded', show); // Show the actual popup\n\n      toggleHidden(popup, !show); // Add class hook\n\n      toggleClass(this.elements.container, this.config.classNames.menu.open, show); // Focus the first item if key interaction\n\n      if (show && is$1.keyboardEvent(input)) {\n        controls.focusFirstMenuItem.call(this, null, true);\n      } else if (!show && !hidden) {\n        // If closing, re-focus the button\n        setFocus.call(this, button, is$1.keyboardEvent(input));\n      }\n    },\n    // Get the natural size of a menu panel\n    getMenuSize: function getMenuSize(tab) {\n      var clone = tab.cloneNode(true);\n      clone.style.position = 'absolute';\n      clone.style.opacity = 0;\n      clone.removeAttribute('hidden'); // Append to parent so we get the \"real\" size\n\n      tab.parentNode.appendChild(clone); // Get the sizes before we remove\n\n      var width = clone.scrollWidth;\n      var height = clone.scrollHeight; // Remove from the DOM\n\n      removeElement(clone);\n      return {\n        width: width,\n        height: height\n      };\n    },\n    // Show a panel in the menu\n    showMenuPanel: function showMenuPanel() {\n      var _this9 = this;\n\n      var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n      var tabFocus = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var target = this.elements.container.querySelector(\"#wassPlayer-settings-\".concat(this.id, \"-\").concat(type)); // Nothing to show, bail\n\n      if (!is$1.element(target)) {\n        return;\n      } // Hide all other panels\n\n\n      var container = target.parentNode;\n      var current = Array.from(container.children).find(function (node) {\n        return !node.hidden;\n      }); // If we can do fancy animations, we'll animate the height/width\n\n      if (support.transitions && !support.reducedMotion) {\n        // Set the current width as a base\n        container.style.width = \"\".concat(current.scrollWidth, \"px\");\n        container.style.height = \"\".concat(current.scrollHeight, \"px\"); // Get potential sizes\n\n        var size = controls.getMenuSize.call(this, target); // Restore auto height/width\n\n        var restore = function restore(event) {\n          // We're only bothered about height and width on the container\n          if (event.target !== container || !['width', 'height'].includes(event.propertyName)) {\n            return;\n          } // Revert back to auto\n\n\n          container.style.width = '';\n          container.style.height = ''; // Only listen once\n\n          off.call(_this9, container, transitionEndEvent, restore);\n        }; // Listen for the transition finishing and restore auto height/width\n\n\n        on.call(this, container, transitionEndEvent, restore); // Set dimensions to target\n\n        container.style.width = \"\".concat(size.width, \"px\");\n        container.style.height = \"\".concat(size.height, \"px\");\n      } // Set attributes on current tab\n\n\n      toggleHidden(current, true); // Set attributes on target\n\n      toggleHidden(target, false); // Focus the first item\n\n      controls.focusFirstMenuItem.call(this, target, tabFocus);\n    },\n    // Set the download URL\n    setDownloadUrl: function setDownloadUrl() {\n      var button = this.elements.buttons.download; // Bail if no button\n\n      if (!is$1.element(button)) {\n        return;\n      } // Set attribute\n\n\n      button.setAttribute('href', this.download);\n    },\n    // Build the default HTML\n    create: function create(data) {\n      var _this10 = this;\n\n      var bindMenuItemShortcuts = controls.bindMenuItemShortcuts,\n          createButton = controls.createButton,\n          createProgress = controls.createProgress,\n          createRange = controls.createRange,\n          createTime = controls.createTime,\n          setQualityMenu = controls.setQualityMenu,\n          setSpeedMenu = controls.setSpeedMenu,\n          showMenuPanel = controls.showMenuPanel;\n      this.elements.controls = null; // Larger overlaid play button\n\n      if (is$1.array(this.config.controls) && this.config.controls.includes('play-large')) {\n        this.elements.container.appendChild(createButton.call(this, 'play-large'));\n      } // Create the container\n\n\n      var container = createElement('div', getAttributesFromSelector(this.config.selectors.controls.wrapper));\n      this.elements.controls = container; // Default item attributes\n\n      var defaultAttributes = {\n        class: 'wassPlayer__controls__item'\n      }; // Loop through controls in order\n\n      dedupe(is$1.array(this.config.controls) ? this.config.controls : []).forEach(function (control) {\n        // Restart button\n        if (control === 'restart') {\n          container.appendChild(createButton.call(_this10, 'restart', defaultAttributes));\n        } // Rewind button\n\n\n        if (control === 'rewind') {\n          container.appendChild(createButton.call(_this10, 'rewind', defaultAttributes));\n        } // Play/Pause button\n\n\n        if (control === 'play') {\n          container.appendChild(createButton.call(_this10, 'play', defaultAttributes));\n        } // Fast forward button\n\n\n        if (control === 'fast-forward') {\n          container.appendChild(createButton.call(_this10, 'fast-forward', defaultAttributes));\n        } // Progress\n\n\n        if (control === 'progress') {\n          var progressContainer = createElement('div', {\n            class: \"\".concat(defaultAttributes.class, \" wassPlayer__progress__container\")\n          });\n          var progress = createElement('div', getAttributesFromSelector(_this10.config.selectors.progress)); // Seek range slider\n\n          progress.appendChild(createRange.call(_this10, 'seek', {\n            id: \"wassPlayer-seek-\".concat(data.id)\n          })); // Buffer progress\n\n          progress.appendChild(createProgress.call(_this10, 'buffer')); // Seek tooltip\n\n          if (_this10.config.tooltips.seek) {\n            var tooltip = createElement('span', {\n              class: _this10.config.classNames.tooltip\n            }, '00:00');\n            progress.appendChild(tooltip);\n            _this10.elements.display.seekTooltip = tooltip;\n          }\n\n          _this10.elements.progress = progress;\n          progressContainer.appendChild(_this10.elements.progress);\n          container.appendChild(progressContainer);\n        } // Media current time display\n\n\n        if (control === 'current-time') {\n          container.appendChild(createTime.call(_this10, 'currentTime', defaultAttributes));\n        } // Media duration display\n\n\n        if (control === 'duration') {\n          container.appendChild(createTime.call(_this10, 'duration', defaultAttributes));\n        } // Volume controls\n\n\n        if (control === 'mute' || control === 'volume') {\n          var volume = _this10.elements.volume; // Create the volume container if needed\n\n          if (!is$1.element(volume) || !container.contains(volume)) {\n            volume = createElement('div', extend({}, defaultAttributes, {\n              class: \"\".concat(defaultAttributes.class, \" wassPlayer__volume\").trim()\n            }));\n            _this10.elements.volume = volume;\n            container.appendChild(volume);\n          } // Toggle mute button\n\n\n          if (control === 'mute') {\n            volume.appendChild(createButton.call(_this10, 'mute'));\n          } // Volume range control\n          // Ignored on iOS as it's handled globally\n          // https://developer.apple.com/library/safari/documentation/AudioVideo/Conceptual/Using_HTML5_Audio_Video/Device-SpecificConsiderations/Device-SpecificConsiderations.html\n\n\n          if (control === 'volume' && !browser.isIos) {\n            // Set the attributes\n            var attributes = {\n              max: 1,\n              step: 0.05,\n              value: _this10.config.volume\n            }; // Create the volume range slider\n\n            volume.appendChild(createRange.call(_this10, 'volume', extend(attributes, {\n              id: \"wassPlayer-volume-\".concat(data.id)\n            })));\n          }\n        } // Toggle captions button\n\n\n        if (control === 'captions') {\n          container.appendChild(createButton.call(_this10, 'captions', defaultAttributes));\n        } // Settings button / menu\n\n\n        if (control === 'settings' && !is$1.empty(_this10.config.settings)) {\n          var wrapper = createElement('div', extend({}, defaultAttributes, {\n            class: \"\".concat(defaultAttributes.class, \" wassPlayer__menu\").trim(),\n            hidden: ''\n          }));\n          wrapper.appendChild(createButton.call(_this10, 'settings', {\n            'aria-haspopup': true,\n            'aria-controls': \"wassPlayer-settings-\".concat(data.id),\n            'aria-expanded': false\n          }));\n          var popup = createElement('div', {\n            class: 'wassPlayer__menu__container',\n            id: \"wassPlayer-settings-\".concat(data.id),\n            hidden: ''\n          });\n          var inner = createElement('div');\n          var home = createElement('div', {\n            id: \"wassPlayer-settings-\".concat(data.id, \"-home\")\n          }); // Create the menu\n\n          var menu = createElement('div', {\n            role: 'menu'\n          });\n          home.appendChild(menu);\n          inner.appendChild(home);\n          _this10.elements.settings.panels.home = home; // Build the menu items\n\n          _this10.config.settings.forEach(function (type) {\n            var menuItem = createElement('button', extend(getAttributesFromSelector(_this10.config.selectors.buttons.settings), {\n              type: 'button',\n              class: \"\".concat(_this10.config.classNames.control, \" \").concat(_this10.config.classNames.control, \"--forward\"),\n              role: 'menuitem',\n              'aria-haspopup': true,\n              hidden: ''\n            })); // Bind menu shortcuts for keyboard users\n\n            bindMenuItemShortcuts.call(_this10, menuItem, type); // Show menu on click\n\n            on.call(_this10, menuItem, 'click', function () {\n              showMenuPanel.call(_this10, type, false);\n            });\n            var flex = createElement('span', null, i18n.get(type, _this10.config));\n            var value = createElement('span', {\n              class: _this10.config.classNames.menu.value\n            }); // Speed contains HTML entities\n\n            value.innerHTML = data[type];\n            flex.appendChild(value);\n            menuItem.appendChild(flex);\n            menu.appendChild(menuItem); // Build the panes\n\n            var pane = createElement('div', {\n              id: \"wassPlayer-settings-\".concat(data.id, \"-\").concat(type),\n              hidden: ''\n            }); // Back button\n\n            var backButton = createElement('button', {\n              type: 'button',\n              class: \"\".concat(_this10.config.classNames.control, \" \").concat(_this10.config.classNames.control, \"--back\")\n            }); // Visible label\n\n            backButton.appendChild(createElement('span', {\n              'aria-hidden': true\n            }, i18n.get(type, _this10.config))); // Screen reader label\n\n            backButton.appendChild(createElement('span', {\n              class: _this10.config.classNames.hidden\n            }, i18n.get('menuBack', _this10.config))); // Go back via keyboard\n\n            on.call(_this10, pane, 'keydown', function (event) {\n              // We only care about <-\n              if (event.which !== 37) {\n                return;\n              } // Prevent seek\n\n\n              event.preventDefault();\n              event.stopPropagation(); // Show the respective menu\n\n              showMenuPanel.call(_this10, 'home', true);\n            }, false); // Go back via button click\n\n            on.call(_this10, backButton, 'click', function () {\n              showMenuPanel.call(_this10, 'home', false);\n            }); // Add to pane\n\n            pane.appendChild(backButton); // Menu\n\n            pane.appendChild(createElement('div', {\n              role: 'menu'\n            }));\n            inner.appendChild(pane);\n            _this10.elements.settings.buttons[type] = menuItem;\n            _this10.elements.settings.panels[type] = pane;\n          });\n\n          popup.appendChild(inner);\n          wrapper.appendChild(popup);\n          container.appendChild(wrapper);\n          _this10.elements.settings.popup = popup;\n          _this10.elements.settings.menu = wrapper;\n        } // Picture in picture button\n\n\n        if (control === 'pip' && support.pip) {\n          container.appendChild(createButton.call(_this10, 'pip', defaultAttributes));\n        } // Airplay button\n\n\n        if (control === 'airplay' && support.airplay) {\n          container.appendChild(createButton.call(_this10, 'airplay', defaultAttributes));\n        } // Download button\n\n\n        if (control === 'download') {\n          var _attributes = extend({}, defaultAttributes, {\n            element: 'a',\n            href: _this10.download,\n            target: '_blank'\n          }); // Set download attribute for HTML5 only\n\n\n          if (_this10.isHTML5) {\n            _attributes.download = '';\n          }\n\n          var download = _this10.config.urls.download;\n\n          if (!is$1.url(download) && _this10.isEmbed) {\n            extend(_attributes, {\n              icon: \"logo-\".concat(_this10.provider),\n              label: _this10.provider\n            });\n          }\n\n          container.appendChild(createButton.call(_this10, 'download', _attributes));\n        } // Toggle fullscreen button\n\n\n        if (control === 'fullscreen') {\n          container.appendChild(createButton.call(_this10, 'fullscreen', defaultAttributes));\n        }\n      }); // Set available quality levels\n\n      if (this.isHTML5) {\n        setQualityMenu.call(this, html5.getQualityOptions.call(this));\n      }\n\n      setSpeedMenu.call(this);\n      return container;\n    },\n    // Insert controls\n    inject: function inject() {\n      var _this11 = this;\n\n      // Sprite\n      if (this.config.loadSprite) {\n        var icon = controls.getIconUrl.call(this); // Only load external sprite using AJAX\n\n        if (icon.cors) {\n          loadSprite(icon.url, 'sprite-wassPlayer');\n        }\n      } // Create a unique ID\n\n\n      this.id = Math.floor(Math.random() * 10000); // Null by default\n\n      var container = null;\n      this.elements.controls = null; // Set template properties\n\n      var props = {\n        id: this.id,\n        seektime: this.config.seekTime,\n        title: this.config.title\n      };\n      var update = true; // If function, run it and use output\n\n      if (is$1.function(this.config.controls)) {\n        this.config.controls = this.config.controls.call(this, props);\n      } // Convert falsy controls to empty array (primarily for empty strings)\n\n\n      if (!this.config.controls) {\n        this.config.controls = [];\n      }\n\n      if (is$1.element(this.config.controls) || is$1.string(this.config.controls)) {\n        // HTMLElement or Non-empty string passed as the option\n        container = this.config.controls;\n      } else {\n        // Create controls\n        container = controls.create.call(this, {\n          id: this.id,\n          seektime: this.config.seekTime,\n          speed: this.speed,\n          quality: this.quality,\n          captions: captions.getLabel.call(this) // loop: 'None',\n\n        });\n        update = false;\n      } // Replace props with their value\n\n\n      var replace = function replace(input) {\n        var result = input;\n        Object.entries(props).forEach(function (_ref2) {\n          var _ref3 = _slicedToArray(_ref2, 2),\n              key = _ref3[0],\n              value = _ref3[1];\n\n          result = replaceAll(result, \"{\".concat(key, \"}\"), value);\n        });\n        return result;\n      }; // Update markup\n\n\n      if (update) {\n        if (is$1.string(this.config.controls)) {\n          container = replace(container);\n        }\n      } // Controls container\n\n\n      var target; // Inject to custom location\n\n      if (is$1.string(this.config.selectors.controls.container)) {\n        target = document.querySelector(this.config.selectors.controls.container);\n      } // Inject into the container by default\n\n\n      if (!is$1.element(target)) {\n        target = this.elements.container;\n      } // Inject controls HTML (needs to be before captions, hence \"afterbegin\")\n\n\n      var insertMethod = is$1.element(container) ? 'insertAdjacentElement' : 'insertAdjacentHTML';\n      target[insertMethod]('afterbegin', container); // Find the elements if need be\n\n      if (!is$1.element(this.elements.controls)) {\n        controls.findElements.call(this);\n      } // Add pressed property to buttons\n\n\n      if (!is$1.empty(this.elements.buttons)) {\n        var addProperty = function addProperty(button) {\n          var className = _this11.config.classNames.controlPressed;\n          Object.defineProperty(button, 'pressed', {\n            enumerable: true,\n            get: function get() {\n              return hasClass(button, className);\n            },\n            set: function set() {\n              var pressed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n              toggleClass(button, className, pressed);\n            }\n          });\n        }; // Toggle classname when pressed property is set\n\n\n        Object.values(this.elements.buttons).filter(Boolean).forEach(function (button) {\n          if (is$1.array(button) || is$1.nodeList(button)) {\n            Array.from(button).filter(Boolean).forEach(addProperty);\n          } else {\n            addProperty(button);\n          }\n        });\n      } // Edge sometimes doesn't finish the paint so force a repaint\n\n\n      if (browser.isEdge) {\n        repaint(target);\n      } // Setup tooltips\n\n\n      if (this.config.tooltips.controls) {\n        var _this$config = this.config,\n            classNames = _this$config.classNames,\n            selectors = _this$config.selectors;\n        var selector = \"\".concat(selectors.controls.wrapper, \" \").concat(selectors.labels, \" .\").concat(classNames.hidden);\n        var labels = getElements.call(this, selector);\n        Array.from(labels).forEach(function (label) {\n          toggleClass(label, _this11.config.classNames.hidden, false);\n          toggleClass(label, _this11.config.classNames.tooltip, true);\n        });\n      }\n    }\n  };\n\n  /**\n   * Parse a string to a URL object\n   * @param {String} input - the URL to be parsed\n   * @param {Boolean} safe - failsafe parsing\n   */\n\n  function parseUrl(input) {\n    var safe = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    var url = input;\n\n    if (safe) {\n      var parser = document.createElement('a');\n      parser.href = url;\n      url = parser.href;\n    }\n\n    try {\n      return new URL(url);\n    } catch (e) {\n      return null;\n    }\n  } // Convert object to URLSearchParams\n\n  var captions = {\n    // Setup captions\n    setup: function setup() {\n      // Requires UI support\n      if (!this.supported.ui) {\n        return;\n      } // Only Vimeo and HTML5 video supported at this point\n\n\n      if (!this.isVideo || this.isYouTube || this.isHTML5 && !support.textTracks) {\n        // Clear menu and hide\n        if (is$1.array(this.config.controls) && this.config.controls.includes('settings') && this.config.settings.includes('captions')) {\n          controls.setCaptionsMenu.call(this);\n        }\n\n        return;\n      } // Inject the container\n\n\n      if (!is$1.element(this.elements.captions)) {\n        this.elements.captions = createElement('div', getAttributesFromSelector(this.config.selectors.captions));\n        insertAfter(this.elements.captions, this.elements.wrapper);\n      } // Fix IE captions if CORS is used\n      // Fetch captions and inject as blobs instead (data URIs not supported!)\n\n\n      if (browser.isIE && window.URL) {\n        var elements = this.media.querySelectorAll('track');\n        Array.from(elements).forEach(function (track) {\n          var src = track.getAttribute('src');\n          var url = parseUrl(src);\n\n          if (url !== null && url.hostname !== window.location.href.hostname && ['http:', 'https:'].includes(url.protocol)) {\n            fetch(src, 'blob').then(function (blob) {\n              track.setAttribute('src', window.URL.createObjectURL(blob));\n            }).catch(function () {\n              removeElement(track);\n            });\n          }\n        });\n      }\n\n      var browserLanguages = navigator.languages || [navigator.language || navigator.userLanguage || 'en'];\n      var languages = dedupe(browserLanguages.map(function (language) {\n        return language.split('-')[0];\n      }));\n      var language = (this.storage.get('language') || this.config.captions.language || 'auto').toLowerCase(); // Use first browser language when language is 'auto'\n\n      if (language === 'auto') {\n        var _languages = _slicedToArray(languages, 1);\n\n        language = _languages[0];\n      }\n\n      var active = this.storage.get('captions');\n\n      if (!is$1.boolean(active)) {\n        active = this.config.captions.active;\n      }\n\n      Object.assign(this.captions, {\n        toggled: false,\n        active: active,\n        language: language,\n        languages: languages\n      }); // Watch changes to textTracks and update captions menu\n\n      if (this.isHTML5) {\n        var trackEvents = this.config.captions.update ? 'addtrack removetrack' : 'removetrack';\n        on.call(this, this.media.textTracks, trackEvents, captions.update.bind(this));\n      } // Update available languages in list next tick (the event must not be triggered before the listeners)\n\n\n      setTimeout(captions.update.bind(this), 0);\n    },\n    // Update available language options in settings based on tracks\n    update: function update() {\n      var _this = this;\n\n      var tracks = captions.getTracks.call(this, true); // Get the wanted language\n\n      var _this$captions = this.captions,\n          active = _this$captions.active,\n          language = _this$captions.language,\n          meta = _this$captions.meta,\n          currentTrackNode = _this$captions.currentTrackNode;\n      var languageExists = Boolean(tracks.find(function (track) {\n        return track.language === language;\n      })); // Handle tracks (add event listener and \"pseudo\"-default)\n\n      if (this.isHTML5 && this.isVideo) {\n        tracks.filter(function (track) {\n          return !meta.get(track);\n        }).forEach(function (track) {\n          _this.debug.log('Track added', track); // Attempt to store if the original dom element was \"default\"\n\n\n          meta.set(track, {\n            default: track.mode === 'showing'\n          }); // eslint-disable-next-line no-param-reassign\n\n          if (track.mode === 'showing') {\n            // eslint-disable-next-line no-param-reassign\n            track.mode = 'hidden';\n          } // Add event listener for cue changes\n\n\n          on.call(_this, track, 'cuechange', function () {\n            return captions.updateCues.call(_this);\n          });\n        });\n      } // Update language first time it matches, or if the previous matching track was removed\n\n\n      if (languageExists && this.language !== language || !tracks.includes(currentTrackNode)) {\n        captions.setLanguage.call(this, language);\n        captions.toggle.call(this, active && languageExists);\n      } // Enable or disable captions based on track length\n\n\n      toggleClass(this.elements.container, this.config.classNames.captions.enabled, !is$1.empty(tracks)); // Update available languages in list\n\n      if (is$1.array(this.config.controls) && this.config.controls.includes('settings') && this.config.settings.includes('captions')) {\n        controls.setCaptionsMenu.call(this);\n      }\n    },\n    // Toggle captions display\n    // Used internally for the toggleCaptions method, with the passive option forced to false\n    toggle: function toggle(input) {\n      var _this2 = this;\n\n      var passive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n      // If there's no full support\n      if (!this.supported.ui) {\n        return;\n      }\n\n      var toggled = this.captions.toggled; // Current state\n\n      var activeClass = this.config.classNames.captions.active; // Get the next state\n      // If the method is called without parameter, toggle based on current value\n\n      var active = is$1.nullOrUndefined(input) ? !toggled : input; // Update state and trigger event\n\n      if (active !== toggled) {\n        // When passive, don't override user preferences\n        if (!passive) {\n          this.captions.active = active;\n          this.storage.set({\n            captions: active\n          });\n        } // Force language if the call isn't passive and there is no matching language to toggle to\n\n\n        if (!this.language && active && !passive) {\n          var tracks = captions.getTracks.call(this);\n          var track = captions.findTrack.call(this, [this.captions.language].concat(_toConsumableArray(this.captions.languages)), true); // Override user preferences to avoid switching languages if a matching track is added\n\n          this.captions.language = track.language; // Set caption, but don't store in localStorage as user preference\n\n          captions.set.call(this, tracks.indexOf(track));\n          return;\n        } // Toggle button if it's enabled\n\n\n        if (this.elements.buttons.captions) {\n          this.elements.buttons.captions.pressed = active;\n        } // Add class hook\n\n\n        toggleClass(this.elements.container, activeClass, active);\n        this.captions.toggled = active; // Update settings menu\n\n        controls.updateSetting.call(this, 'captions'); // Trigger event (not used internally)\n\n        triggerEvent.call(this, this.media, active ? 'captionsenabled' : 'captionsdisabled');\n      } // on the active track - forcing the browser to download it\n\n\n      setTimeout(function () {\n        if (active && _this2.captions.toggled) {\n          _this2.captions.currentTrackNode.mode = 'hidden';\n        }\n      });\n    },\n    // Set captions by track index\n    // Used internally for the currentTrack setter with the passive option forced to false\n    set: function set(index) {\n      var passive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var tracks = captions.getTracks.call(this); // Disable captions if setting to -1\n\n      if (index === -1) {\n        captions.toggle.call(this, false, passive);\n        return;\n      }\n\n      if (!is$1.number(index)) {\n        this.debug.warn('Invalid caption argument', index);\n        return;\n      }\n\n      if (!(index in tracks)) {\n        this.debug.warn('Track not found', index);\n        return;\n      }\n\n      if (this.captions.currentTrack !== index) {\n        this.captions.currentTrack = index;\n        var track = tracks[index];\n\n        var _ref = track || {},\n            language = _ref.language; // Store reference to node for invalidation on remove\n\n\n        this.captions.currentTrackNode = track; // Update settings menu\n\n        controls.updateSetting.call(this, 'captions'); // When passive, don't override user preferences\n\n        if (!passive) {\n          this.captions.language = language;\n          this.storage.set({\n            language: language\n          });\n        } // Handle Vimeo captions\n\n\n        if (this.isVimeo) {\n          this.embed.enableTextTrack(language);\n        } // Trigger event\n\n\n        triggerEvent.call(this, this.media, 'languagechange');\n      } // Show captions\n\n\n      captions.toggle.call(this, true, passive);\n\n      if (this.isHTML5 && this.isVideo) {\n        // If we change the active track while a cue is already displayed we need to update it\n        captions.updateCues.call(this);\n      }\n    },\n    // Set captions by language\n    // Used internally for the language setter with the passive option forced to false\n    setLanguage: function setLanguage(input) {\n      var passive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n      if (!is$1.string(input)) {\n        this.debug.warn('Invalid language argument', input);\n        return;\n      } // Normalize\n\n\n      var language = input.toLowerCase();\n      this.captions.language = language; // Set currentTrack\n\n      var tracks = captions.getTracks.call(this);\n      var track = captions.findTrack.call(this, [language]);\n      captions.set.call(this, tracks.indexOf(track), passive);\n    },\n    // Get current valid caption tracks\n    // If update is false it will also ignore tracks without metadata\n    // This is used to \"freeze\" the language options when captions.update is false\n    getTracks: function getTracks() {\n      var _this3 = this;\n\n      var update = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      // Handle media or textTracks missing or null\n      var tracks = Array.from((this.media || {}).textTracks || []); // For HTML5, use cache instead of current tracks when it exists (if captions.update is false)\n      // Filter out removed tracks and tracks that aren't captions/subtitles (for example metadata)\n\n      return tracks.filter(function (track) {\n        return !_this3.isHTML5 || update || _this3.captions.meta.has(track);\n      }).filter(function (track) {\n        return ['captions', 'subtitles'].includes(track.kind);\n      });\n    },\n    // Match tracks based on languages and get the first\n    findTrack: function findTrack(languages) {\n      var _this4 = this;\n\n      var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var tracks = captions.getTracks.call(this);\n\n      var sortIsDefault = function sortIsDefault(track) {\n        return Number((_this4.captions.meta.get(track) || {}).default);\n      };\n\n      var sorted = Array.from(tracks).sort(function (a, b) {\n        return sortIsDefault(b) - sortIsDefault(a);\n      });\n      var track;\n      languages.every(function (language) {\n        track = sorted.find(function (t) {\n          return t.language === language;\n        });\n        return !track; // Break iteration if there is a match\n      }); // If no match is found but is required, get first\n\n      return track || (force ? sorted[0] : undefined);\n    },\n    // Get the current track\n    getCurrentTrack: function getCurrentTrack() {\n      return captions.getTracks.call(this)[this.currentTrack];\n    },\n    // Get UI label for track\n    getLabel: function getLabel(track) {\n      var currentTrack = track;\n\n      if (!is$1.track(currentTrack) && support.textTracks && this.captions.toggled) {\n        currentTrack = captions.getCurrentTrack.call(this);\n      }\n\n      if (is$1.track(currentTrack)) {\n        if (!is$1.empty(currentTrack.label)) {\n          return currentTrack.label;\n        }\n\n        if (!is$1.empty(currentTrack.language)) {\n          return track.language.toUpperCase();\n        }\n\n        return i18n.get('enabled', this.config);\n      }\n\n      return i18n.get('disabled', this.config);\n    },\n    // Update captions using current track's active cues\n    // Also optional array argument in case there isn't any track (ex: vimeo)\n    updateCues: function updateCues(input) {\n      // Requires UI\n      if (!this.supported.ui) {\n        return;\n      }\n\n      if (!is$1.element(this.elements.captions)) {\n        this.debug.warn('No captions element to render to');\n        return;\n      } // Only accept array or empty input\n\n\n      if (!is$1.nullOrUndefined(input) && !Array.isArray(input)) {\n        this.debug.warn('updateCues: Invalid input', input);\n        return;\n      }\n\n      var cues = input; // Get cues from track\n\n      if (!cues) {\n        var track = captions.getCurrentTrack.call(this);\n        cues = Array.from((track || {}).activeCues || []).map(function (cue) {\n          return cue.getCueAsHTML();\n        }).map(getHTML);\n      } // Set new caption text\n\n\n      var content = cues.map(function (cueText) {\n        return cueText.trim();\n      }).join('\\n');\n      var changed = content !== this.elements.captions.innerHTML;\n\n      if (changed) {\n        // Empty the container and create a new child element\n        emptyElement(this.elements.captions);\n        var caption = createElement('span', getAttributesFromSelector(this.config.selectors.caption));\n        caption.innerHTML = content;\n        this.elements.captions.appendChild(caption); // Trigger event\n\n        triggerEvent.call(this, this.media, 'cuechange');\n      }\n    }\n  };\n\n  // ==========================================================================\n  // WassPlayer default config file\n  // ==========================================================================\n  var defaults$1 = {\n    // Disable\n    enabled: true,\n    // Custom media title\n    title: '',\n    // Logging to console\n    debug: false,\n    // Auto play (if supported)\n    autoplay: false,\n    // Only allow one media playing at once\n    autopause: true,\n    // Allow inline playback on iOS\n    playsinline: true,\n    // Default time to skip when rewind/fast forward\n    seekTime: 10,\n    // Default volume\n    volume: 1,\n    muted: false,\n    // Pass a custom duration\n    duration: null,\n    // Display the media duration on load in the current time position\n    // If you have opted to display both duration and currentTime, this is ignored\n    displayDuration: true,\n    // Invert the current time to be a countdown\n    invertTime: true,\n    // Clicking the currentTime inverts it's value to show time left rather than elapsed\n    toggleInvert: true,\n    // Force an aspect ratio\n    // The format must be `'w:h'` (e.g. `'16:9'`)\n    ratio: null,\n    // Click video container to play/pause\n    clickToPlay: true,\n    // Auto hide the controls\n    hideControls: true,\n    // Reset to start when playback ended\n    resetOnEnd: false,\n    // Disable the standard context menu\n    disableContextMenu: true,\n    // Sprite (for icons)\n    loadSprite: true,\n    iconPrefix: 'wassPlayer',\n    iconUrl: 'http://code4stack.com/wassplayer.svg',\n    // Quality default\n    quality: {\n      default: 576,\n      // The options to display in the UI, if available for the source media\n      options: [4320, 2880, 2160, 1440, 1080, 720, 576, 480, 360, 240],\n      forced: false,\n      onChange: null\n    },\n    // Set loops\n    loop: {\n      active: false // start: null,\n      // end: null,\n\n    },\n    // Speed default and options to display\n    speed: {\n      selected: 1,\n      // The options to display in the UI, if available for the source media\n      options: [0.5, 0.75, 1, 1.25, 1.5, 1.75, 2, 4]\n    },\n    // Keyboard shortcut settings\n    keyboard: {\n      focused: true,\n      global: false\n    },\n    // Display tooltips\n    tooltips: {\n      controls: false,\n      seek: true\n    },\n    // Captions settings\n    captions: {\n      active: false,\n      language: 'auto',\n      // Listen to new tracks added after Plyr is initialized.\n      // This is needed for streaming captions, but may result in unselectable options\n      update: false\n    },\n    // Fullscreen settings\n    fullscreen: {\n      enabled: true,\n      // Allow fullscreen?\n      fallback: true,\n      // Fallback using full viewport/window\n      iosNative: false // Use the native fullscreen in iOS (disables custom controls)\n      // Selector for the fullscreen container so contextual / non-player content can remain visible in fullscreen mode\n      // Non-ancestors of the player element will be ignored\n      // container: null, // defaults to the player element\n\n    },\n    // Local storage\n    storage: {\n      enabled: true,\n      key: 'wassPlayer'\n    },\n    // Default controls\n    controls: ['play-large', // 'restart',\n    'rewind', 'play', 'fast-forward', 'progress', 'current-time', // 'duration',\n    'mute', 'volume', 'captions', 'settings', 'pip', 'airplay', // 'download',\n    'fullscreen'],\n    settings: ['captions', 'quality', 'speed'],\n    // Localisation\n    i18n: {\n      restart: 'Restart',\n      rewind: 'Rewind {seektime}s',\n      play: 'Play',\n      pause: 'Pause',\n      fastForward: 'Forward {seektime}s',\n      seek: 'Seek',\n      seekLabel: '{currentTime} of {duration}',\n      played: 'Played',\n      buffered: 'Buffered',\n      currentTime: 'Current time',\n      duration: 'Duration',\n      volume: 'Volume',\n      mute: 'Mute',\n      unmute: 'Unmute',\n      enableCaptions: 'Enable captions',\n      disableCaptions: 'Disable captions',\n      download: 'Download',\n      enterFullscreen: 'Enter fullscreen',\n      exitFullscreen: 'Exit fullscreen',\n      frameTitle: 'Player for {title}',\n      captions: 'Captions',\n      settings: 'Settings',\n      pip: 'PIP',\n      menuBack: 'Go back to previous menu',\n      speed: 'Speed',\n      normal: 'Normal',\n      quality: 'Quality',\n      loop: 'Loop',\n      start: 'Start',\n      end: 'End',\n      all: 'All',\n      reset: 'Reset',\n      disabled: 'Disabled',\n      enabled: 'Enabled',\n      advertisement: 'Ad',\n      qualityBadge: {\n        2160: '4K',\n        1440: 'HD',\n        1080: 'HD',\n        720: 'HD',\n        576: 'SD',\n        480: 'SD'\n      }\n    },\n    // Custom control listeners\n    listeners: {\n      seek: null,\n      play: null,\n      pause: null,\n      restart: null,\n      rewind: null,\n      fastForward: null,\n      mute: null,\n      volume: null,\n      captions: null,\n      download: null,\n      fullscreen: null,\n      pip: null,\n      airplay: null,\n      speed: null,\n      quality: null,\n      loop: null,\n      language: null\n    },\n    // Events to watch and bubble\n    events: [// Events to watch on HTML5 media elements and bubble\n    // https://developer.mozilla.org/en/docs/Web/Guide/Events/Media_events\n    'ended', 'progress', 'stalled', 'playing', 'waiting', 'canplay', 'canplaythrough', 'loadstart', 'loadeddata', 'loadedmetadata', 'timeupdate', 'volumechange', 'play', 'pause', 'error', 'seeking', 'seeked', 'emptied', 'ratechange', 'cuechange', // Custom events\n    'download', 'enterfullscreen', 'exitfullscreen', 'captionsenabled', 'captionsdisabled', 'languagechange', 'controlshidden', 'controlsshown', 'ready', // Quality\n    'qualitychange'],\n    // Selectors\n    // Change these to match your template if using custom HTML\n    selectors: {\n      editable: 'input, textarea, select, [contenteditable]',\n      container: '.wassPlayer',\n      controls: {\n        container: null,\n        wrapper: '.wassPlayer__controls'\n      },\n      labels: '[data-wassPlayer]',\n      buttons: {\n        play: '[data-wassPlayer=\"play\"]',\n        pause: '[data-wassPlayer=\"pause\"]',\n        restart: '[data-wassPlayer=\"restart\"]',\n        rewind: '[data-wassPlayer=\"rewind\"]',\n        fastForward: '[data-wassPlayer=\"fast-forward\"]',\n        mute: '[data-wassPlayer=\"mute\"]',\n        captions: '[data-wassPlayer=\"captions\"]',\n        download: '[data-wassPlayer=\"download\"]',\n        fullscreen: '[data-wassPlayer=\"fullscreen\"]',\n        pip: '[data-wassPlayer=\"pip\"]',\n        airplay: '[data-wassPlayer=\"airplay\"]',\n        settings: '[data-wassPlayer=\"settings\"]',\n        loop: '[data-wassPlayer=\"loop\"]'\n      },\n      inputs: {\n        seek: '[data-wassPlayer=\"seek\"]',\n        volume: '[data-wassPlayer=\"volume\"]',\n        speed: '[data-wassPlayer=\"speed\"]',\n        language: '[data-wassPlayer=\"language\"]',\n        quality: '[data-wassPlayer=\"quality\"]'\n      },\n      display: {\n        currentTime: '.wassPlayer__time--current',\n        duration: '.wassPlayer__time--duration',\n        buffer: '.wassPlayer__progress__buffer',\n        loop: '.wassPlayer__progress__loop',\n        // Used later\n        volume: '.wassPlayer__volume--display'\n      },\n      progress: '.wassPlayer__progress',\n      captions: '.wassPlayer__captions',\n      caption: '.wassPlayer__caption'\n    },\n    // Class hooks added to the player in different states\n    classNames: {\n      type: 'wassPlayer--{0}',\n      provider: 'wassPlayer--{0}',\n      video: 'wassPlayer__video-wrapper',\n      embed: 'wassPlayer__video-embed',\n      videoFixedRatio: 'wassPlayer__video-wrapper--fixed-ratio',\n      embedContainer: 'wassPlayer__video-embed__container',\n      poster: 'wassPlayer__poster',\n      posterEnabled: 'wassPlayer__poster-enabled',\n      control: 'wassPlayer__control',\n      controlPressed: 'wassPlayer__control--pressed',\n      playing: 'wassPlayer--playing',\n      paused: 'wassPlayer--paused',\n      stopped: 'wassPlayer--stopped',\n      loading: 'wassPlayer--loading',\n      hover: 'wassPlayer--hover',\n      tooltip: 'wassPlayer__tooltip',\n      cues: 'wassPlayer__cues',\n      hidden: 'wassPlayer__sr-only',\n      hideControls: 'wassPlayer--hide-controls',\n      isIos: 'wassPlayer--is-ios',\n      isTouch: 'wassPlayer--is-touch',\n      uiSupported: 'wassPlayer--full-ui',\n      noTransition: 'wassPlayer--no-transition',\n      display: {\n        time: 'wassPlayer__time'\n      },\n      menu: {\n        value: 'wassPlayer__menu__value',\n        badge: 'wassPlayer__badge',\n        open: 'wassPlayer--menu-open'\n      },\n      captions: {\n        enabled: 'wassPlayer--captions-enabled',\n        active: 'wassPlayer--captions-active'\n      },\n      fullscreen: {\n        enabled: 'wassPlayer--fullscreen-enabled',\n        fallback: 'wassPlayer--fullscreen-fallback'\n      },\n      pip: {\n        supported: 'wassPlayer--pip-supported',\n        active: 'wassPlayer--pip-active'\n      },\n      airplay: {\n        supported: 'wassPlayer--airplay-supported',\n        active: 'wassPlayer--airplay-active'\n      },\n      tabFocus: 'wassPlayer__tab-focus',\n      previewThumbnails: {\n        // Tooltip thumbs\n        thumbContainer: 'wassPlayer__preview-thumb',\n        thumbContainerShown: 'wassPlayer__preview-thumb--is-shown',\n        imageContainer: 'wassPlayer__preview-thumb__image-container',\n        timeContainer: 'wassPlayer__preview-thumb__time-container',\n        // Scrubbing\n        scrubbingContainer: 'wassPlayer__preview-scrubbing',\n        scrubbingContainerShown: 'wassPlayer__preview-scrubbing--is-shown'\n      }\n    },\n    // Embed attributes\n    attributes: {\n      embed: {\n        provider: 'data-wassPlayer-provider',\n        id: 'data-wassPlayer-embed-id'\n      }\n    },\n    // Preview Thumbnails plugin\n    previewThumbnails: {\n      enabled: false,\n      src: ''\n    }\n  };\n\n  // ==========================================================================\n  // WassPlayer states\n  // ==========================================================================\n  var pip = {\n    active: 'picture-in-picture',\n    inactive: 'inline'\n  };\n\n  // ==========================================================================\n  // WassPlayer supported types and providers\n  // ==========================================================================\n  var providers = {\n    html5: 'html5'\n  };\n  var types = {\n    video: 'video'\n  };\n  /**\n   * Get provider by URL\n   * @param {String} url\n   */\n\n  function getProviderByUrl() {\n    return null;\n  }\n\n  // ==========================================================================\n  // Console wrapper\n  // ==========================================================================\n  var noop = function noop() {};\n\n  var Console = /*#__PURE__*/function () {\n    function Console() {\n      var enabled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n      _classCallCheck(this, Console);\n\n      this.enabled = window.console && enabled;\n\n      if (this.enabled) {\n        this.log('Debugging enabled');\n      }\n    }\n\n    _createClass(Console, [{\n      key: \"log\",\n      get: function get() {\n        // eslint-disable-next-line no-console\n        return this.enabled ? Function.prototype.bind.call(console.log, console) : noop;\n      }\n    }, {\n      key: \"warn\",\n      get: function get() {\n        // eslint-disable-next-line no-console\n        return this.enabled ? Function.prototype.bind.call(console.warn, console) : noop;\n      }\n    }, {\n      key: \"error\",\n      get: function get() {\n        // eslint-disable-next-line no-console\n        return this.enabled ? Function.prototype.bind.call(console.error, console) : noop;\n      }\n    }]);\n\n    return Console;\n  }();\n\n  var Fullscreen = /*#__PURE__*/function () {\n    function Fullscreen(player) {\n      var _this = this;\n\n      _classCallCheck(this, Fullscreen);\n\n      // Keep reference to parent\n      this.player = player; // Get prefix\n\n      this.prefix = Fullscreen.prefix;\n      this.property = Fullscreen.property; // Scroll position\n\n      this.scrollPosition = {\n        x: 0,\n        y: 0\n      }; // Force the use of 'full window/browser' rather than fullscreen\n\n      this.forceFallback = player.config.fullscreen.fallback === 'force'; // Get the fullscreen element\n      // Checks container is an ancestor, defaults to null\n\n      this.player.elements.fullscreen = player.config.fullscreen.container && closest(this.player.elements.container, player.config.fullscreen.container); // Register event listeners\n      // Handle event (incase user presses escape etc)\n\n      on.call(this.player, document, this.prefix === 'ms' ? 'MSFullscreenChange' : \"\".concat(this.prefix, \"fullscreenchange\"), function () {\n        _this.onChange();\n      }); // Fullscreen toggle on double click\n\n      on.call(this.player, this.player.elements.container, 'dblclick', function (event) {\n        // Ignore double click in controls\n        if (is$1.element(_this.player.elements.controls) && _this.player.elements.controls.contains(event.target)) {\n          return;\n        }\n\n        _this.toggle();\n      }); // Tap focus when in fullscreen\n\n      on.call(this, this.player.elements.container, 'keydown', function (event) {\n        return _this.trapFocus(event);\n      }); // Update the UI\n\n      this.update();\n    } // Determine if native supported\n\n\n    _createClass(Fullscreen, [{\n      key: \"onChange\",\n      value: function onChange() {\n        if (!this.enabled) {\n          return;\n        } // Update toggle button\n\n\n        var button = this.player.elements.buttons.fullscreen;\n\n        if (is$1.element(button)) {\n          button.pressed = this.active;\n        } // Trigger an event\n\n\n        triggerEvent.call(this.player, this.target, this.active ? 'enterfullscreen' : 'exitfullscreen', true);\n      }\n    }, {\n      key: \"toggleFallback\",\n      value: function toggleFallback() {\n        var toggle = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n        // Store or restore scroll position\n        if (toggle) {\n          this.scrollPosition = {\n            x: window.scrollX || 0,\n            y: window.scrollY || 0\n          };\n        } else {\n          window.scrollTo(this.scrollPosition.x, this.scrollPosition.y);\n        } // Toggle scroll\n\n\n        document.body.style.overflow = toggle ? 'hidden' : ''; // Toggle class hook\n\n        toggleClass(this.target, this.player.config.classNames.fullscreen.fallback, toggle); // Force full viewport on iPhone X+\n\n        if (browser.isIos) {\n          var viewport = document.head.querySelector('meta[name=\"viewport\"]');\n          var property = 'viewport-fit=cover'; // Inject the viewport meta if required\n\n          if (!viewport) {\n            viewport = document.createElement('meta');\n            viewport.setAttribute('name', 'viewport');\n          } // Check if the property already exists\n\n\n          var hasProperty = is$1.string(viewport.content) && viewport.content.includes(property);\n\n          if (toggle) {\n            this.cleanupViewport = !hasProperty;\n\n            if (!hasProperty) {\n              viewport.content += \",\".concat(property);\n            }\n          } else if (this.cleanupViewport) {\n            viewport.content = viewport.content.split(',').filter(function (part) {\n              return part.trim() !== property;\n            }).join(',');\n          }\n        } // Toggle button and fire events\n\n\n        this.onChange();\n      } // Trap focus inside container\n\n    }, {\n      key: \"trapFocus\",\n      value: function trapFocus(event) {\n        // Bail if iOS, not active, not the tab key\n        if (browser.isIos || !this.active || event.key !== 'Tab' || event.keyCode !== 9) {\n          return;\n        } // Get the current focused element\n\n\n        var focused = document.activeElement;\n        var focusable = getElements.call(this.player, 'a[href], button:not(:disabled), input:not(:disabled), [tabindex]');\n\n        var _focusable = _slicedToArray(focusable, 1),\n            first = _focusable[0];\n\n        var last = focusable[focusable.length - 1];\n\n        if (focused === last && !event.shiftKey) {\n          // Move focus to first element that can be tabbed if Shift isn't used\n          first.focus();\n          event.preventDefault();\n        } else if (focused === first && event.shiftKey) {\n          // Move focus to last element that can be tabbed if Shift is used\n          last.focus();\n          event.preventDefault();\n        }\n      } // Update UI\n\n    }, {\n      key: \"update\",\n      value: function update() {\n        if (this.enabled) {\n          var mode;\n\n          if (this.forceFallback) {\n            mode = 'Fallback (forced)';\n          } else if (Fullscreen.native) {\n            mode = 'Native';\n          } else {\n            mode = 'Fallback';\n          }\n\n          this.player.debug.log(\"\".concat(mode, \" fullscreen enabled\"));\n        } else {\n          this.player.debug.log('Fullscreen not supported and fallback disabled');\n        } // Add styling hook to show button\n\n\n        toggleClass(this.player.elements.container, this.player.config.classNames.fullscreen.enabled, this.enabled);\n      } // Make an element fullscreen\n\n    }, {\n      key: \"enter\",\n      value: function enter() {\n        if (!this.enabled) {\n          return;\n        } // iOS native fullscreen doesn't need the request step\n\n\n        if (browser.isIos && this.player.config.fullscreen.iosNative) {\n          this.target.webkitEnterFullscreen();\n        } else if (!Fullscreen.native || this.forceFallback) {\n          this.toggleFallback(true);\n        } else if (!this.prefix) {\n          this.target.requestFullscreen({\n            navigationUI: 'hide'\n          });\n        } else if (!is$1.empty(this.prefix)) {\n          this.target[\"\".concat(this.prefix, \"Request\").concat(this.property)]();\n        }\n      } // Bail from fullscreen\n\n    }, {\n      key: \"exit\",\n      value: function exit() {\n        if (!this.enabled) {\n          return;\n        } // iOS native fullscreen\n\n\n        if (browser.isIos && this.player.config.fullscreen.iosNative) {\n          this.target.webkitExitFullscreen();\n          silencePromise(this.player.play());\n        } else if (!Fullscreen.native || this.forceFallback) {\n          this.toggleFallback(false);\n        } else if (!this.prefix) {\n          (document.cancelFullScreen || document.exitFullscreen).call(document);\n        } else if (!is$1.empty(this.prefix)) {\n          var action = this.prefix === 'moz' ? 'Cancel' : 'Exit';\n          document[\"\".concat(this.prefix).concat(action).concat(this.property)]();\n        }\n      } // Toggle state\n\n    }, {\n      key: \"toggle\",\n      value: function toggle() {\n        if (!this.active) {\n          this.enter();\n        } else {\n          this.exit();\n        }\n      }\n    }, {\n      key: \"usingNative\",\n      // If we're actually using native\n      get: function get() {\n        return Fullscreen.native && !this.forceFallback;\n      } // Get the prefix for handlers\n\n    }, {\n      key: \"enabled\",\n      // Determine if fullscreen is enabled\n      get: function get() {\n        return (Fullscreen.native || this.player.config.fullscreen.fallback) && this.player.config.fullscreen.enabled && this.player.supported.ui && this.player.isVideo;\n      } // Get active state\n\n    }, {\n      key: \"active\",\n      get: function get() {\n        if (!this.enabled) {\n          return false;\n        } // Fallback using classname\n\n\n        if (!Fullscreen.native || this.forceFallback) {\n          return hasClass(this.target, this.player.config.classNames.fullscreen.fallback);\n        }\n\n        var element = !this.prefix ? document.fullscreenElement : document[\"\".concat(this.prefix).concat(this.property, \"Element\")];\n        return element && element.shadowRoot ? element === this.target.getRootNode().host : element === this.target;\n      } // Get target element\n\n    }, {\n      key: \"target\",\n      get: function get() {\n        return browser.isIos && this.player.config.fullscreen.iosNative ? this.player.media : this.player.elements.fullscreen || this.player.elements.container;\n      }\n    }], [{\n      key: \"native\",\n      get: function get() {\n        return !!(document.fullscreenEnabled || document.webkitFullscreenEnabled || document.mozFullScreenEnabled || document.msFullscreenEnabled);\n      }\n    }, {\n      key: \"prefix\",\n      get: function get() {\n        // No prefix\n        if (is$1.function(document.exitFullscreen)) {\n          return '';\n        } // Check for fullscreen support by vendor prefix\n\n\n        var value = '';\n        var prefixes = ['webkit', 'moz', 'ms'];\n        prefixes.some(function (pre) {\n          if (is$1.function(document[\"\".concat(pre, \"ExitFullscreen\")]) || is$1.function(document[\"\".concat(pre, \"CancelFullScreen\")])) {\n            value = pre;\n            return true;\n          }\n\n          return false;\n        });\n        return value;\n      }\n    }, {\n      key: \"property\",\n      get: function get() {\n        return this.prefix === 'moz' ? 'FullScreen' : 'Fullscreen';\n      }\n    }]);\n\n    return Fullscreen;\n  }();\n\n  // ==========================================================================\n  // Load image avoiding xhr/fetch CORS issues\n  // Server status can't be obtained this way unfortunately, so this uses \"naturalWidth\" to determine if the image has loaded\n  // By default it checks if it is at least 1px, but you can add a second argument to change this\n  // ==========================================================================\n  function loadImage(src) {\n    var minWidth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    return new Promise(function (resolve, reject) {\n      var image = new Image();\n\n      var handler = function handler() {\n        delete image.onload;\n        delete image.onerror;\n        (image.naturalWidth >= minWidth ? resolve : reject)(image);\n      };\n\n      Object.assign(image, {\n        onload: handler,\n        onerror: handler,\n        src: src\n      });\n    });\n  }\n\n  var ui = {\n    addStyleHook: function addStyleHook() {\n      toggleClass(this.elements.container, this.config.selectors.container.replace('.', ''), true);\n      toggleClass(this.elements.container, this.config.classNames.uiSupported, this.supported.ui);\n    },\n    // Toggle native HTML5 media controls\n    toggleNativeControls: function toggleNativeControls() {\n      var toggle = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n      if (toggle && this.isHTML5) {\n        this.media.setAttribute('controls', '');\n      } else {\n        this.media.removeAttribute('controls');\n      }\n    },\n    // Setup the UI\n    build: function build() {\n      var _this = this;\n\n      // Re-attach media element listeners\n      // TODO: Use event bubbling?\n      this.listeners.media(); // Don't setup interface if no support\n\n      if (!this.supported.ui) {\n        this.debug.warn(\"Basic support only for \".concat(this.provider, \" \").concat(this.type)); // Restore native controls\n\n        ui.toggleNativeControls.call(this, true); // Bail\n\n        return;\n      } // Inject custom controls if not present\n\n\n      if (!is$1.element(this.elements.controls)) {\n        // Inject custom controls\n        controls.inject.call(this); // Re-attach control listeners\n\n        this.listeners.controls();\n      } // Remove native controls\n\n\n      ui.toggleNativeControls.call(this); // Setup captions for HTML5\n\n      if (this.isHTML5) {\n        captions.setup.call(this);\n      } // Reset volume\n\n\n      this.volume = null; // Reset mute state\n\n      this.muted = null; // Reset loop state\n\n      this.loop = null; // Reset quality setting\n\n      this.quality = null; // Reset speed\n\n      this.speed = null; // Reset volume display\n\n      controls.updateVolume.call(this); // Reset time display\n\n      controls.timeUpdate.call(this); // Update the UI\n\n      ui.checkPlaying.call(this); // Check for picture-in-picture support\n\n      toggleClass(this.elements.container, this.config.classNames.pip.supported, support.pip && this.isHTML5 && this.isVideo); // Check for airplay support\n\n      toggleClass(this.elements.container, this.config.classNames.airplay.supported, support.airplay && this.isHTML5); // Add iOS class\n\n      toggleClass(this.elements.container, this.config.classNames.isIos, browser.isIos); // Add touch class\n\n      toggleClass(this.elements.container, this.config.classNames.isTouch, this.touch); // Ready for API calls\n\n      this.ready = true; // Ready event at end of execution stack\n\n      setTimeout(function () {\n        triggerEvent.call(_this, _this.media, 'ready');\n      }, 0); // Set the title\n\n      ui.setTitle.call(this); // Assure the poster image is set, if the property was added before the element was created\n\n      if (this.poster) {\n        ui.setPoster.call(this, this.poster, false).catch(function () {});\n      } // Manually set the duration if user has overridden it.\n      // The event listeners for it doesn't get called if preload is disabled (#701)\n\n\n      if (this.config.duration) {\n        controls.durationUpdate.call(this);\n      }\n    },\n    // Setup aria attribute for play and iframe title\n    setTitle: function setTitle() {\n      // Find the current text\n      var label = i18n.get('play', this.config); // If there's a media title set, use that for the label\n\n      if (is$1.string(this.config.title) && !is$1.empty(this.config.title)) {\n        label += \", \".concat(this.config.title);\n      } // If there's a play button, set label\n\n\n      Array.from(this.elements.buttons.play || []).forEach(function (button) {\n        button.setAttribute('aria-label', label);\n      }); // Set iframe title\n      // https://github.com/sampotts/WassPlayer/issues/124\n\n      if (this.isEmbed) {\n        var iframe = getElement.call(this, 'iframe');\n\n        if (!is$1.element(iframe)) {\n          return;\n        } // Default to media type\n\n\n        var title = !is$1.empty(this.config.title) ? this.config.title : 'video';\n        var format = i18n.get('frameTitle', this.config);\n        iframe.setAttribute('title', format.replace('{title}', title));\n      }\n    },\n    // Toggle poster\n    togglePoster: function togglePoster(enable) {\n      toggleClass(this.elements.container, this.config.classNames.posterEnabled, enable);\n    },\n    // Set the poster image (async)\n    // Used internally for the poster setter, with the passive option forced to false\n    setPoster: function setPoster(poster) {\n      var _this2 = this;\n\n      var passive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n      // Don't override if call is passive\n      if (passive && this.poster) {\n        return Promise.reject(new Error('Poster already set'));\n      } // Set property synchronously to respect the call order\n\n\n      this.media.setAttribute('data-poster', poster); // Wait until ui is ready\n\n      return ready.call(this) // Load image\n      .then(function () {\n        return loadImage(poster);\n      }).catch(function (err) {\n        // Hide poster on error unless it's been set by another call\n        if (poster === _this2.poster) {\n          ui.togglePoster.call(_this2, false);\n        } // Rethrow\n\n\n        throw err;\n      }).then(function () {\n        // Prevent race conditions\n        if (poster !== _this2.poster) {\n          throw new Error('setPoster cancelled by later call to setPoster');\n        }\n      }).then(function () {\n        Object.assign(_this2.elements.poster.style, {\n          backgroundImage: \"url('\".concat(poster, \"')\"),\n          // Reset backgroundSize as well (since it can be set to \"cover\" for padded thumbnails for youtube)\n          backgroundSize: ''\n        });\n        ui.togglePoster.call(_this2, true);\n        return poster;\n      });\n    },\n    // Check playing state\n    checkPlaying: function checkPlaying(event) {\n      var _this3 = this;\n\n      // Class hooks\n      toggleClass(this.elements.container, this.config.classNames.playing, this.playing);\n      toggleClass(this.elements.container, this.config.classNames.paused, this.paused);\n      toggleClass(this.elements.container, this.config.classNames.stopped, this.stopped); // Set state\n\n      Array.from(this.elements.buttons.play || []).forEach(function (target) {\n        Object.assign(target, {\n          pressed: _this3.playing\n        });\n        target.setAttribute('aria-label', i18n.get(_this3.playing ? 'pause' : 'play', _this3.config));\n      }); // Only update controls on non timeupdate events\n\n      if (is$1.event(event) && event.type === 'timeupdate') {\n        return;\n      } // Toggle controls\n\n\n      ui.toggleControls.call(this);\n    },\n    // Check if media is loading\n    checkLoading: function checkLoading(event) {\n      var _this4 = this;\n\n      this.loading = ['stalled', 'waiting'].includes(event.type); // Clear timer\n\n      clearTimeout(this.timers.loading); // Timer to prevent flicker when seeking\n\n      this.timers.loading = setTimeout(function () {\n        // Update progress bar loading class state\n        toggleClass(_this4.elements.container, _this4.config.classNames.loading, _this4.loading); // Update controls visibility\n\n        ui.toggleControls.call(_this4);\n      }, this.loading ? 250 : 0);\n    },\n    // Toggle controls based on state and `force` argument\n    toggleControls: function toggleControls(force) {\n      var controlsElement = this.elements.controls;\n\n      if (controlsElement && this.config.hideControls) {\n        // Don't hide controls if a touch-device user recently seeked. (Must be limited to touch devices, or it occasionally prevents desktop controls from hiding.)\n        var recentTouchSeek = this.touch && this.lastSeekTime + 2000 > Date.now(); // Show controls if force, loading, paused, button interaction, or recent seek, otherwise hide\n\n        this.toggleControls(Boolean(force || this.loading || this.paused || controlsElement.pressed || controlsElement.hover || recentTouchSeek));\n      }\n    },\n    // Migrate any custom properties from the media to the parent\n    migrateStyles: function migrateStyles() {\n      var _this5 = this;\n\n      // Loop through values (as they are the keys when the object is spread )\n      Object.values(_objectSpread2({}, this.media.style)) // We're only fussed about WassPlayer specific properties\n      .filter(function (key) {\n        return !is$1.empty(key) && key.startsWith('--wassPlayer');\n      }).forEach(function (key) {\n        // Set on the container\n        _this5.elements.container.style.setProperty(key, _this5.media.style.getPropertyValue(key)); // Clean up from media element\n\n\n        _this5.media.style.removeProperty(key);\n      }); // Remove attribute if empty\n\n      if (is$1.empty(this.media.style)) {\n        this.media.removeAttribute('style');\n      }\n    }\n  };\n\n  var Listeners = /*#__PURE__*/function () {\n    function Listeners(player) {\n      _classCallCheck(this, Listeners);\n\n      this.player = player;\n      this.lastKey = null;\n      this.focusTimer = null;\n      this.lastKeyDown = null;\n      this.handleKey = this.handleKey.bind(this);\n      this.toggleMenu = this.toggleMenu.bind(this);\n      this.setTabFocus = this.setTabFocus.bind(this);\n      this.firstTouch = this.firstTouch.bind(this);\n    } // Handle key presses\n\n\n    _createClass(Listeners, [{\n      key: \"handleKey\",\n      value: function handleKey(event) {\n        var player = this.player;\n        var elements = player.elements;\n        var code = event.keyCode ? event.keyCode : event.which;\n        var pressed = event.type === 'keydown';\n        var repeat = pressed && code === this.lastKey; // Bail if a modifier key is set\n\n        if (event.altKey || event.ctrlKey || event.metaKey || event.shiftKey) {\n          return;\n        } // If the event is bubbled from the media element\n        // Firefox doesn't get the keycode for whatever reason\n\n\n        if (!is$1.number(code)) {\n          return;\n        } // Seek by the number keys\n\n\n        var seekByKey = function seekByKey() {\n          // Divide the max duration into 10th's and times by the number value\n          player.currentTime = player.duration / 10 * (code - 48);\n        }; // Handle the key on keydown\n        // Reset on keyup\n\n\n        if (pressed) {\n          // Check focused element\n          // and if the focused element is not editable (e.g. text input)\n          // and any that accept key input http://webaim.org/techniques/keyboard/\n          var focused = document.activeElement;\n\n          if (is$1.element(focused)) {\n            var editable = player.config.selectors.editable;\n            var seek = elements.inputs.seek;\n\n            if (focused !== seek && matches$1(focused, editable)) {\n              return;\n            }\n\n            if (event.which === 32 && matches$1(focused, 'button, [role^=\"menuitem\"]')) {\n              return;\n            }\n          } // Which keycodes should we prevent default\n\n\n          var preventDefault = [32, 37, 38, 39, 40, 48, 49, 50, 51, 52, 53, 54, 56, 57, 67, 70, 73, 75, 76, 77, 79]; // If the code is found prevent default (e.g. prevent scrolling for arrows)\n\n          if (preventDefault.includes(code)) {\n            event.preventDefault();\n            event.stopPropagation();\n          }\n\n          switch (code) {\n            case 48:\n            case 49:\n            case 50:\n            case 51:\n            case 52:\n            case 53:\n            case 54:\n            case 55:\n            case 56:\n            case 57:\n              // 0-9\n              if (!repeat) {\n                seekByKey();\n              }\n\n              break;\n\n            case 32:\n            case 75:\n              // Space and K key\n              if (!repeat) {\n                silencePromise(player.togglePlay());\n              }\n\n              break;\n\n            case 38:\n              // Arrow up\n              player.increaseVolume(0.1);\n              break;\n\n            case 40:\n              // Arrow down\n              player.decreaseVolume(0.1);\n              break;\n\n            case 77:\n              // M key\n              if (!repeat) {\n                player.muted = !player.muted;\n              }\n\n              break;\n\n            case 39:\n              // Arrow forward\n              player.forward();\n              break;\n\n            case 37:\n              // Arrow back\n              player.rewind();\n              break;\n\n            case 70:\n              // F key\n              player.fullscreen.toggle();\n              break;\n\n            case 67:\n              // C key\n              if (!repeat) {\n                player.toggleCaptions();\n              }\n\n              break;\n\n            case 76:\n              // L key\n              player.loop = !player.loop;\n              break;\n          } // Escape is handle natively when in full screen\n          // So we only need to worry about non native\n\n\n          if (code === 27 && !player.fullscreen.usingNative && player.fullscreen.active) {\n            player.fullscreen.toggle();\n          } // Store last code for next cycle\n\n\n          this.lastKey = code;\n        } else {\n          this.lastKey = null;\n        }\n      } // Toggle menu\n\n    }, {\n      key: \"toggleMenu\",\n      value: function toggleMenu(event) {\n        controls.toggleMenu.call(this.player, event);\n      } // Device is touch enabled\n\n    }, {\n      key: \"firstTouch\",\n      value: function firstTouch() {\n        var player = this.player;\n        var elements = player.elements;\n        player.touch = true; // Add touch class\n\n        toggleClass(elements.container, player.config.classNames.isTouch, true);\n      }\n    }, {\n      key: \"setTabFocus\",\n      value: function setTabFocus(event) {\n        var player = this.player;\n        var elements = player.elements;\n        clearTimeout(this.focusTimer); // Ignore any key other than tab\n\n        if (event.type === 'keydown' && event.which !== 9) {\n          return;\n        } // Store reference to event timeStamp\n\n\n        if (event.type === 'keydown') {\n          this.lastKeyDown = event.timeStamp;\n        } // Remove current classes\n\n\n        var removeCurrent = function removeCurrent() {\n          var className = player.config.classNames.tabFocus;\n          var current = getElements.call(player, \".\".concat(className));\n          toggleClass(current, className, false);\n        }; // Determine if a key was pressed to trigger this event\n\n\n        var wasKeyDown = event.timeStamp - this.lastKeyDown <= 20; // Ignore focus events if a key was pressed prior\n\n        if (event.type === 'focus' && !wasKeyDown) {\n          return;\n        } // Remove all current\n\n\n        removeCurrent(); // Delay the adding of classname until the focus has changed\n        // This event fires before the focusin event\n\n        if (event.type !== 'focusout') {\n          this.focusTimer = setTimeout(function () {\n            var focused = document.activeElement; // Ignore if current focus element isn't inside the player\n\n            if (!elements.container.contains(focused)) {\n              return;\n            }\n\n            toggleClass(document.activeElement, player.config.classNames.tabFocus, true);\n          }, 10);\n        }\n      } // Global window & document listeners\n\n    }, {\n      key: \"global\",\n      value: function global() {\n        var toggle = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n        var player = this.player; // Keyboard shortcuts\n\n        if (player.config.keyboard.global) {\n          toggleListener.call(player, window, 'keydown keyup', this.handleKey, toggle, false);\n        } // Click anywhere closes menu\n\n\n        toggleListener.call(player, document.body, 'click', this.toggleMenu, toggle); // Detect touch by events\n\n        once.call(player, document.body, 'touchstart', this.firstTouch); // Tab focus detection\n\n        toggleListener.call(player, document.body, 'keydown focus blur focusout', this.setTabFocus, toggle, false, true);\n      } // Container listeners\n\n    }, {\n      key: \"container\",\n      value: function container() {\n        var player = this.player;\n        var config = player.config,\n            elements = player.elements,\n            timers = player.timers; // Keyboard shortcuts\n\n        if (!config.keyboard.global && config.keyboard.focused) {\n          on.call(player, elements.container, 'keydown keyup', this.handleKey, false);\n        } // Toggle controls on mouse events and entering fullscreen\n\n\n        on.call(player, elements.container, 'mousemove mouseleave touchstart touchmove enterfullscreen exitfullscreen', function (event) {\n          var controlsElement = elements.controls; // Remove button states for fullscreen\n\n          if (controlsElement && event.type === 'enterfullscreen') {\n            controlsElement.pressed = false;\n            controlsElement.hover = false;\n          } // Show, then hide after a timeout unless another control event occurs\n\n\n          var show = ['touchstart', 'touchmove', 'mousemove'].includes(event.type);\n          var delay = 0;\n\n          if (show) {\n            ui.toggleControls.call(player, true); // Use longer timeout for touch devices\n\n            delay = player.touch ? 3000 : 2000;\n          } // Clear timer\n\n\n          clearTimeout(timers.controls); // Set new timer to prevent flicker when seeking\n\n          timers.controls = setTimeout(function () {\n            return ui.toggleControls.call(player, false);\n          }, delay);\n        }); // Set a gutter for Vimeo\n\n        var setGutter = function setGutter(ratio, padding, toggle) {\n          if (!player.isVimeo || player.config.vimeo.premium) {\n            return;\n          }\n\n          var target = player.elements.wrapper.firstChild;\n\n          var _ratio = _slicedToArray(ratio, 2),\n              y = _ratio[1];\n\n          var _getAspectRatio$call = getAspectRatio.call(player),\n              _getAspectRatio$call2 = _slicedToArray(_getAspectRatio$call, 2),\n              videoX = _getAspectRatio$call2[0],\n              videoY = _getAspectRatio$call2[1];\n\n          target.style.maxWidth = toggle ? \"\".concat(y / videoY * videoX, \"px\") : null;\n          target.style.margin = toggle ? '0 auto' : null;\n        }; // Resize on fullscreen change\n\n\n        var setPlayerSize = function setPlayerSize(measure) {\n          // If we don't need to measure the viewport\n          if (!measure) {\n            return setAspectRatio.call(player);\n          }\n\n          var rect = elements.container.getBoundingClientRect();\n          var width = rect.width,\n              height = rect.height;\n          return setAspectRatio.call(player, \"\".concat(width, \":\").concat(height));\n        };\n\n        var resized = function resized() {\n          clearTimeout(timers.resized);\n          timers.resized = setTimeout(setPlayerSize, 50);\n        };\n\n        on.call(player, elements.container, 'enterfullscreen exitfullscreen', function (event) {\n          var _player$fullscreen = player.fullscreen,\n              target = _player$fullscreen.target,\n              usingNative = _player$fullscreen.usingNative; // Ignore events not from target\n\n          if (target !== elements.container) {\n            return;\n          } // If it's not an embed and no ratio specified\n\n\n          if (!player.isEmbed && is$1.empty(player.config.ratio)) {\n            return;\n          }\n\n          var isEnter = event.type === 'enterfullscreen'; // Set the player size when entering fullscreen to viewport size\n\n          var _setPlayerSize = setPlayerSize(isEnter),\n              padding = _setPlayerSize.padding,\n              ratio = _setPlayerSize.ratio; // Set Vimeo gutter\n\n\n          setGutter(ratio, padding, isEnter); // If not using native browser fullscreen API, we need to check for resizes of viewport\n\n          if (!usingNative) {\n            if (isEnter) {\n              on.call(player, window, 'resize', resized);\n            } else {\n              off.call(player, window, 'resize', resized);\n            }\n          }\n        });\n      } // Listen for media events\n\n    }, {\n      key: \"media\",\n      value: function media() {\n        var _this = this;\n\n        var player = this.player;\n        var elements = player.elements; // Time change on media\n\n        on.call(player, player.media, 'timeupdate seeking seeked', function (event) {\n          return controls.timeUpdate.call(player, event);\n        }); // Display duration\n\n        on.call(player, player.media, 'durationchange loadeddata loadedmetadata', function (event) {\n          return controls.durationUpdate.call(player, event);\n        }); // Handle the media finishing\n\n        on.call(player, player.media, 'ended', function () {\n          // Show poster on end\n          if (player.isHTML5 && player.isVideo && player.config.resetOnEnd) {\n            // Restart\n            player.restart(); // Call pause otherwise IE11 will start playing the video again\n\n            player.pause();\n          }\n        }); // Check for buffer progress\n\n        on.call(player, player.media, 'progress playing seeking seeked', function (event) {\n          return controls.updateProgress.call(player, event);\n        }); // Handle volume changes\n\n        on.call(player, player.media, 'volumechange', function (event) {\n          return controls.updateVolume.call(player, event);\n        }); // Handle play/pause\n\n        on.call(player, player.media, 'playing play pause ended emptied timeupdate', function (event) {\n          return ui.checkPlaying.call(player, event);\n        }); // Loading state\n\n        on.call(player, player.media, 'waiting canplay seeked playing', function (event) {\n          return ui.checkLoading.call(player, event);\n        }); // Click video\n\n        if (player.supported.ui && player.config.clickToPlay && !player.isAudio) {\n          // Re-fetch the wrapper\n          var wrapper = getElement.call(player, \".\".concat(player.config.classNames.video)); // Bail if there's no wrapper (this should never happen)\n\n          if (!is$1.element(wrapper)) {\n            return;\n          } // On click play, pause or restart\n\n\n          on.call(player, elements.container, 'click', function (event) {\n            var targets = [elements.container, wrapper]; // Ignore if click if not container or in video wrapper\n\n            if (!targets.includes(event.target) && !wrapper.contains(event.target)) {\n              return;\n            } // Touch devices will just show controls (if hidden)\n\n\n            if (player.touch && player.config.hideControls) {\n              return;\n            }\n\n            if (player.ended) {\n              _this.proxy(event, player.restart, 'restart');\n\n              _this.proxy(event, function () {\n                silencePromise(player.play());\n              }, 'play');\n            } else {\n              _this.proxy(event, function () {\n                silencePromise(player.togglePlay());\n              }, 'play');\n            }\n          });\n        } // Disable right click\n\n\n        if (player.supported.ui && player.config.disableContextMenu) {\n          on.call(player, elements.wrapper, 'contextmenu', function (event) {\n            event.preventDefault();\n          }, false);\n        } // Volume change\n\n\n        on.call(player, player.media, 'volumechange', function () {\n          // Save to storage\n          player.storage.set({\n            volume: player.volume,\n            muted: player.muted\n          });\n        }); // Speed change\n\n        on.call(player, player.media, 'ratechange', function () {\n          // Update UI\n          controls.updateSetting.call(player, 'speed'); // Save to storage\n\n\n          player.storage.set({\n            speed: player.speed\n          });\n        }); // Quality change\n\n        on.call(player, player.media, 'qualitychange', function (event) {\n          // Update UI\n          controls.updateSetting.call(player, 'quality', null, event.detail.quality);\n        }); // Update download link when ready and if quality changes\n\n        on.call(player, player.media, 'ready qualitychange', function () {\n          controls.setDownloadUrl.call(player);\n        }); // Proxy events to container\n        // Bubble up key events for Edge\n\n        var proxyEvents = player.config.events.concat(['keyup', 'keydown']).join(' ');\n        on.call(player, player.media, proxyEvents, function (event) {\n          var _event$detail = event.detail,\n              detail = _event$detail === void 0 ? {} : _event$detail; // Get error details from media\n\n          if (event.type === 'error') {\n            detail = player.media.error;\n          }\n\n          triggerEvent.call(player, elements.container, event.type, true, detail);\n        });\n      } // Run default and custom handlers\n\n    }, {\n      key: \"proxy\",\n      value: function proxy(event, defaultHandler, customHandlerKey) {\n        var player = this.player;\n        var customHandler = player.config.listeners[customHandlerKey];\n        var hasCustomHandler = is$1.function(customHandler);\n        var returned = true; // Execute custom handler\n\n        if (hasCustomHandler) {\n          returned = customHandler.call(player, event);\n        } // Only call default handler if not prevented in custom handler\n\n\n        if (returned !== false && is$1.function(defaultHandler)) {\n          defaultHandler.call(player, event);\n        }\n      } // Trigger custom and default handlers\n\n    }, {\n      key: \"bind\",\n      value: function bind(element, type, defaultHandler, customHandlerKey) {\n        var _this2 = this;\n\n        var passive = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n        var player = this.player;\n        var customHandler = player.config.listeners[customHandlerKey];\n        var hasCustomHandler = is$1.function(customHandler);\n        on.call(player, element, type, function (event) {\n          return _this2.proxy(event, defaultHandler, customHandlerKey);\n        }, passive && !hasCustomHandler);\n      } // Listen for control events\n\n    }, {\n      key: \"controls\",\n      value: function controls$1() {\n        var _this3 = this;\n\n        var player = this.player;\n        var elements = player.elements; // IE doesn't support input event, so we fallback to change\n\n        var inputEvent = browser.isIE ? 'change' : 'input'; // Play/pause toggle\n\n        if (elements.buttons.play) {\n          Array.from(elements.buttons.play).forEach(function (button) {\n            _this3.bind(button, 'click', function () {\n              silencePromise(player.togglePlay());\n            }, 'play');\n          });\n        } // Pause\n\n\n        this.bind(elements.buttons.restart, 'click', player.restart, 'restart'); // Rewind\n\n        this.bind(elements.buttons.rewind, 'click', player.rewind, 'rewind'); // Rewind\n\n        this.bind(elements.buttons.fastForward, 'click', player.forward, 'fastForward'); // Mute toggle\n\n        this.bind(elements.buttons.mute, 'click', function () {\n          player.muted = !player.muted;\n        }, 'mute'); // Captions toggle\n\n        this.bind(elements.buttons.captions, 'click', function () {\n          return player.toggleCaptions();\n        }); // Download\n\n        this.bind(elements.buttons.download, 'click', function () {\n          triggerEvent.call(player, player.media, 'download');\n        }, 'download'); // Fullscreen toggle\n\n        this.bind(elements.buttons.fullscreen, 'click', function () {\n          player.fullscreen.toggle();\n        }, 'fullscreen'); // Picture-in-Picture\n\n        this.bind(elements.buttons.pip, 'click', function () {\n          player.pip = 'toggle';\n        }, 'pip'); // Airplay\n\n        this.bind(elements.buttons.airplay, 'click', player.airplay, 'airplay'); // Settings menu - click toggle\n\n        this.bind(elements.buttons.settings, 'click', function (event) {\n          // Prevent the document click listener closing the menu\n          event.stopPropagation();\n          event.preventDefault();\n\n          controls.toggleMenu.call(player, event);\n        }, null, false); // Can't be passive as we're preventing default\n        // Settings menu - keyboard toggle\n        // We have to bind to keyup otherwise Firefox triggers a click when a keydown event handler shifts focus\n        // https://bugzilla.mozilla.org/show_bug.cgi?id=1220143\n\n        this.bind(elements.buttons.settings, 'keyup', function (event) {\n          var code = event.which; // We only care about space and return\n\n          if (![13, 32].includes(code)) {\n            return;\n          } // Because return triggers a click anyway, all we need to do is set focus\n\n\n          if (code === 13) {\n            controls.focusFirstMenuItem.call(player, null, true);\n\n            return;\n          } // Prevent scroll\n\n\n          event.preventDefault(); // Prevent playing video (Firefox)\n\n          event.stopPropagation(); // Toggle menu\n\n          controls.toggleMenu.call(player, event);\n        }, null, false // Can't be passive as we're preventing default\n        ); // Escape closes menu\n\n        this.bind(elements.settings.menu, 'keydown', function (event) {\n          if (event.which === 27) {\n            controls.toggleMenu.call(player, event);\n          }\n        }); // Set range input alternative \"value\", which matches the tooltip time (#954)\n\n        this.bind(elements.inputs.seek, 'mousedown mousemove', function (event) {\n          var rect = elements.progress.getBoundingClientRect();\n          var percent = 100 / rect.width * (event.pageX - rect.left);\n          event.currentTarget.setAttribute('seek-value', percent);\n        }); // Pause while seeking\n\n        this.bind(elements.inputs.seek, 'mousedown mouseup keydown keyup touchstart touchend', function (event) {\n          var seek = event.currentTarget;\n          var code = event.keyCode ? event.keyCode : event.which;\n          var attribute = 'play-on-seeked';\n\n          if (is$1.keyboardEvent(event) && code !== 39 && code !== 37) {\n            return;\n          } // Record seek time so we can prevent hiding controls for a few seconds after seek\n\n\n          player.lastSeekTime = Date.now(); // Was playing before?\n\n          var play = seek.hasAttribute(attribute); // Done seeking\n\n          var done = ['mouseup', 'touchend', 'keyup'].includes(event.type); // If we're done seeking and it was playing, resume playback\n\n          if (play && done) {\n            seek.removeAttribute(attribute);\n            silencePromise(player.play());\n          } else if (!done && player.playing) {\n            seek.setAttribute(attribute, '');\n            player.pause();\n          }\n        }); // Fix range inputs on iOS\n        // Super weird iOS bug where after you interact with an <input type=\"range\">,\n        // it takes over further interactions on the page. This is a hack\n\n        if (browser.isIos) {\n          var inputs = getElements.call(player, 'input[type=\"range\"]');\n          Array.from(inputs).forEach(function (input) {\n            return _this3.bind(input, inputEvent, function (event) {\n              return repaint(event.target);\n            });\n          });\n        } // Seek\n\n\n        this.bind(elements.inputs.seek, inputEvent, function (event) {\n          var seek = event.currentTarget; // If it exists, use seek-value instead of \"value\" for consistency with tooltip time (#954)\n\n          var seekTo = seek.getAttribute('seek-value');\n\n          if (is$1.empty(seekTo)) {\n            seekTo = seek.value;\n          }\n\n          seek.removeAttribute('seek-value');\n          player.currentTime = seekTo / seek.max * player.duration;\n        }, 'seek'); // Seek tooltip\n\n        this.bind(elements.progress, 'mouseenter mouseleave mousemove', function (event) {\n          return controls.updateSeekTooltip.call(player, event);\n        }); // Preview thumbnails plugin\n\n        this.bind(elements.progress, 'mousemove touchmove', function (event) {\n          var previewThumbnails = player.previewThumbnails;\n\n          if (previewThumbnails && previewThumbnails.loaded) {\n            previewThumbnails.startMove(event);\n          }\n        }); // Hide thumbnail preview - on mouse click, mouse leave, and video play/seek. All four are required, e.g., for buffering\n\n        this.bind(elements.progress, 'mouseleave touchend click', function () {\n          var previewThumbnails = player.previewThumbnails;\n\n          if (previewThumbnails && previewThumbnails.loaded) {\n            previewThumbnails.endMove(false, true);\n          }\n        }); // Show scrubbing preview\n\n        this.bind(elements.progress, 'mousedown touchstart', function (event) {\n          var previewThumbnails = player.previewThumbnails;\n\n          if (previewThumbnails && previewThumbnails.loaded) {\n            previewThumbnails.startScrubbing(event);\n          }\n        });\n        this.bind(elements.progress, 'mouseup touchend', function (event) {\n          var previewThumbnails = player.previewThumbnails;\n\n          if (previewThumbnails && previewThumbnails.loaded) {\n            previewThumbnails.endScrubbing(event);\n          }\n        }); // Polyfill for lower fill in <input type=\"range\"> for webkit\n\n        if (browser.isWebkit) {\n          Array.from(getElements.call(player, 'input[type=\"range\"]')).forEach(function (element) {\n            _this3.bind(element, 'input', function (event) {\n              return controls.updateRangeFill.call(player, event.target);\n            });\n          });\n        } // Current time invert\n        // Only if one time element is used for both currentTime and duration\n\n\n        if (player.config.toggleInvert && !is$1.element(elements.display.duration)) {\n          this.bind(elements.display.currentTime, 'click', function () {\n            // Do nothing if we're at the start\n            if (player.currentTime === 0) {\n              return;\n            }\n\n            player.config.invertTime = !player.config.invertTime;\n\n            controls.timeUpdate.call(player);\n          });\n        } // Volume\n\n\n        this.bind(elements.inputs.volume, inputEvent, function (event) {\n          player.volume = event.target.value;\n        }, 'volume'); // Update controls.hover state (used for ui.toggleControls to avoid hiding when interacting)\n\n        this.bind(elements.controls, 'mouseenter mouseleave', function (event) {\n          elements.controls.hover = !player.touch && event.type === 'mouseenter';\n        }); // Also update controls.hover state for any non-player children of fullscreen element (as above)\n\n        if (elements.fullscreen) {\n          Array.from(elements.fullscreen.children).filter(function (c) {\n            return !c.contains(elements.container);\n          }).forEach(function (child) {\n            _this3.bind(child, 'mouseenter mouseleave', function (event) {\n              elements.controls.hover = !player.touch && event.type === 'mouseenter';\n            });\n          });\n        } // Update controls.pressed state (used for ui.toggleControls to avoid hiding when interacting)\n\n\n        this.bind(elements.controls, 'mousedown mouseup touchstart touchend touchcancel', function (event) {\n          elements.controls.pressed = ['mousedown', 'touchstart'].includes(event.type);\n        }); // Show controls when they receive focus (e.g., when using keyboard tab key)\n\n        this.bind(elements.controls, 'focusin', function () {\n          var config = player.config,\n              timers = player.timers; // Skip transition to prevent focus from scrolling the parent element\n\n          toggleClass(elements.controls, config.classNames.noTransition, true); // Toggle\n\n          ui.toggleControls.call(player, true); // Restore transition\n\n          setTimeout(function () {\n            toggleClass(elements.controls, config.classNames.noTransition, false);\n          }, 0); // Delay a little more for mouse users\n\n          var delay = _this3.touch ? 3000 : 4000; // Clear timer\n\n          clearTimeout(timers.controls); // Hide again after delay\n\n          timers.controls = setTimeout(function () {\n            return ui.toggleControls.call(player, false);\n          }, delay);\n        }); // Mouse wheel for volume\n\n        this.bind(elements.inputs.volume, 'wheel', function (event) {\n          // Detect \"natural\" scroll - suppored on OS X Safari only\n          // Other browsers on OS X will be inverted until support improves\n          var inverted = event.webkitDirectionInvertedFromDevice; // Get delta from event. Invert if `inverted` is true\n\n          var _map = [event.deltaX, -event.deltaY].map(function (value) {\n            return inverted ? -value : value;\n          }),\n              _map2 = _slicedToArray(_map, 2),\n              x = _map2[0],\n              y = _map2[1]; // Using the biggest delta, normalize to 1 or -1 (or 0 if no delta)\n\n\n          var direction = Math.sign(Math.abs(x) > Math.abs(y) ? x : y); // Change the volume by 2%\n\n          player.increaseVolume(direction / 50); // Don't break page scrolling at max and min\n\n          var volume = player.media.volume;\n\n          if (direction === 1 && volume < 1 || direction === -1 && volume > 0) {\n            event.preventDefault();\n          }\n        }, 'volume', false);\n      }\n    }]);\n\n    return Listeners;\n  }();\n\n  // ==========================================================================\n  var media = {\n    // Setup media\n    setup: function setup() {\n      // If there's no media, bail\n      if (!this.media) {\n        this.debug.warn('No media element found!');\n        return;\n      } // Add type class\n\n\n      toggleClass(this.elements.container, this.config.classNames.type.replace('{0}', this.type), true); // Add provider class\n\n      toggleClass(this.elements.container, this.config.classNames.provider.replace('{0}', this.provider), true); // Add video class for embeds\n      // This will require changes if audio embeds are added\n\n      if (this.isEmbed) {\n        toggleClass(this.elements.container, this.config.classNames.type.replace('{0}', 'video'), true);\n      } // Inject the player wrapper\n\n\n      if (this.isVideo) {\n        // Create the wrapper div\n        this.elements.wrapper = createElement('div', {\n          class: this.config.classNames.video\n        }); // Wrap the video in a container\n\n        wrap(this.media, this.elements.wrapper); // Poster image container\n\n        this.elements.poster = createElement('div', {\n          class: this.config.classNames.poster\n        });\n        this.elements.wrapper.appendChild(this.elements.poster);\n      }\n\n      if (this.isHTML5) {\n        html5.setup.call(this);\n      }\n    }\n  };\n\n  var parseVtt = function parseVtt(vttDataString) {\n    var processedList = [];\n    var frames = vttDataString.split(/\\r\\n\\r\\n|\\n\\n|\\r\\r/);\n    frames.forEach(function (frame) {\n      var result = {};\n      var lines = frame.split(/\\r\\n|\\n|\\r/);\n      lines.forEach(function (line) {\n        if (!is$1.number(result.startTime)) {\n          // The line with start and end times on it is the first line of interest\n          var matchTimes = line.match(/([0-9]{2})?:?([0-9]{2}):([0-9]{2}).([0-9]{2,3})( ?--> ?)([0-9]{2})?:?([0-9]{2}):([0-9]{2}).([0-9]{2,3})/); // Note that this currently ignores caption formatting directives that are optionally on the end of this line - fine for non-captions VTT\n\n          if (matchTimes) {\n            result.startTime = Number(matchTimes[1] || 0) * 60 * 60 + Number(matchTimes[2]) * 60 + Number(matchTimes[3]) + Number(\"0.\".concat(matchTimes[4]));\n            result.endTime = Number(matchTimes[6] || 0) * 60 * 60 + Number(matchTimes[7]) * 60 + Number(matchTimes[8]) + Number(\"0.\".concat(matchTimes[9]));\n          }\n        } else if (!is$1.empty(line.trim()) && is$1.empty(result.text)) {\n          // If we already have the startTime, then we're definitely up to the text line(s)\n          var lineSplit = line.trim().split('#xywh=');\n\n          var _lineSplit = _slicedToArray(lineSplit, 1);\n\n          result.text = _lineSplit[0];\n\n          // If there's content in lineSplit[1], then we have sprites. If not, then it's just one frame per image\n          if (lineSplit[1]) {\n            var _lineSplit$1$split = lineSplit[1].split(',');\n\n            var _lineSplit$1$split2 = _slicedToArray(_lineSplit$1$split, 4);\n\n            result.x = _lineSplit$1$split2[0];\n            result.y = _lineSplit$1$split2[1];\n            result.w = _lineSplit$1$split2[2];\n            result.h = _lineSplit$1$split2[3];\n          }\n        }\n      });\n\n      if (result.text) {\n        processedList.push(result);\n      }\n    });\n    return processedList;\n  };\n\n  var fitRatio = function fitRatio(ratio, outer) {\n    var targetRatio = outer.width / outer.height;\n    var result = {};\n\n    if (ratio > targetRatio) {\n      result.width = outer.width;\n      result.height = 1 / ratio * outer.width;\n    } else {\n      result.height = outer.height;\n      result.width = ratio * outer.height;\n    }\n\n    return result;\n  };\n\n  var PreviewThumbnails = /*#__PURE__*/function () {\n    /**\n     * PreviewThumbnails constructor.\n     * @param {wassPlayer} player\n     * @return {PreviewThumbnails}\n     */\n    function PreviewThumbnails(player) {\n      _classCallCheck(this, PreviewThumbnails);\n\n      this.player = player;\n      this.thumbnails = [];\n      this.loaded = false;\n      this.lastMouseMoveTime = Date.now();\n      this.mouseDown = false;\n      this.loadedImages = [];\n      this.elements = {\n        thumb: {},\n        scrubbing: {}\n      };\n      this.load();\n    }\n\n    _createClass(PreviewThumbnails, [{\n      key: \"load\",\n      value: function load() {\n        var _this = this;\n\n        // Toggle the regular seek tooltip\n        if (this.player.elements.display.seekTooltip) {\n          this.player.elements.display.seekTooltip.hidden = this.enabled;\n        }\n\n        if (!this.enabled) {\n          return;\n        }\n\n        this.getThumbnails().then(function () {\n          if (!_this.enabled) {\n            return;\n          } // Render DOM elements\n\n\n          _this.render(); // Check to see if thumb container size was specified manually in CSS\n\n\n          _this.determineContainerAutoSizing();\n\n          _this.loaded = true;\n        });\n      } // Download VTT files and parse them\n\n    }, {\n      key: \"getThumbnails\",\n      value: function getThumbnails() {\n        var _this2 = this;\n\n        return new Promise(function (resolve) {\n          var src = _this2.player.config.previewThumbnails.src;\n\n          if (is$1.empty(src)) {\n            throw new Error('Missing previewThumbnails.src config attribute');\n          } // Resolve promise\n\n\n          var sortAndResolve = function sortAndResolve() {\n            // Sort smallest to biggest (e.g., [120p, 480p, 1080p])\n            _this2.thumbnails.sort(function (x, y) {\n              return x.height - y.height;\n            });\n\n            _this2.player.debug.log('Preview thumbnails', _this2.thumbnails);\n\n            resolve();\n          }; // Via callback()\n\n\n          if (is$1.function(src)) {\n            src(function (thumbnails) {\n              _this2.thumbnails = thumbnails;\n              sortAndResolve();\n            });\n          } // VTT urls\n          else {\n              // If string, convert into single-element list\n              var urls = is$1.string(src) ? [src] : src; // Loop through each src URL. Download and process the VTT file, storing the resulting data in this.thumbnails\n\n              var promises = urls.map(function (u) {\n                return _this2.getThumbnail(u);\n              }); // Resolve\n\n              Promise.all(promises).then(sortAndResolve);\n            }\n        });\n      } // Process individual VTT file\n\n    }, {\n      key: \"getThumbnail\",\n      value: function getThumbnail(url) {\n        var _this3 = this;\n\n        return new Promise(function (resolve) {\n          fetch(url).then(function (response) {\n            var thumbnail = {\n              frames: parseVtt(response),\n              height: null,\n              urlPrefix: ''\n            };\n\n            if (!thumbnail.frames[0].text.startsWith('/') && !thumbnail.frames[0].text.startsWith('http://') && !thumbnail.frames[0].text.startsWith('https://')) {\n              thumbnail.urlPrefix = url.substring(0, url.lastIndexOf('/') + 1);\n            } // Download the first frame, so that we can determine/set the height of this thumbnailsDef\n\n\n            var tempImage = new Image();\n\n            tempImage.onload = function () {\n              thumbnail.height = tempImage.naturalHeight;\n              thumbnail.width = tempImage.naturalWidth;\n\n              _this3.thumbnails.push(thumbnail);\n\n              resolve();\n            };\n\n            tempImage.src = thumbnail.urlPrefix + thumbnail.frames[0].text;\n          });\n        });\n      }\n    }, {\n      key: \"startMove\",\n      value: function startMove(event) {\n        if (!this.loaded) {\n          return;\n        }\n\n        if (!is$1.event(event) || !['touchmove', 'mousemove'].includes(event.type)) {\n          return;\n        } // Wait until media has a duration\n\n\n        if (!this.player.media.duration) {\n          return;\n        }\n\n        if (event.type === 'touchmove') {\n          // Calculate seek hover position as approx video seconds\n          this.seekTime = this.player.media.duration * (this.player.elements.inputs.seek.value / 100);\n        } else {\n          // Calculate seek hover position as approx video seconds\n          var clientRect = this.player.elements.progress.getBoundingClientRect();\n          var percentage = 100 / clientRect.width * (event.pageX - clientRect.left);\n          this.seekTime = this.player.media.duration * (percentage / 100);\n\n          if (this.seekTime < 0) {\n            // The mousemove fires for 10+px out to the left\n            this.seekTime = 0;\n          }\n\n          if (this.seekTime > this.player.media.duration - 1) {\n            // Took 1 second off the duration for safety, because different players can disagree on the real duration of a video\n            this.seekTime = this.player.media.duration - 1;\n          }\n\n          this.mousePosX = event.pageX; // Set time text inside image container\n\n          this.elements.thumb.time.innerText = formatTime(this.seekTime);\n        } // Download and show image\n\n\n        this.showImageAtCurrentTime();\n      }\n    }, {\n      key: \"endMove\",\n      value: function endMove() {\n        this.toggleThumbContainer(false, true);\n      }\n    }, {\n      key: \"startScrubbing\",\n      value: function startScrubbing(event) {\n        // Only act on left mouse button (0), or touch device (event.button does not exist or is false)\n        if (is$1.nullOrUndefined(event.button) || event.button === false || event.button === 0) {\n          this.mouseDown = true; // Wait until media has a duration\n\n          if (this.player.media.duration) {\n            this.toggleScrubbingContainer(true);\n            this.toggleThumbContainer(false, true); // Download and show image\n\n            this.showImageAtCurrentTime();\n          }\n        }\n      }\n    }, {\n      key: \"endScrubbing\",\n      value: function endScrubbing() {\n        var _this4 = this;\n\n        this.mouseDown = false; // Hide scrubbing preview. But wait until the video has successfully seeked before hiding the scrubbing preview\n\n        if (Math.ceil(this.lastTime) === Math.ceil(this.player.media.currentTime)) {\n          // The video was already seeked/loaded at the chosen time - hide immediately\n          this.toggleScrubbingContainer(false);\n        } else {\n          // The video hasn't seeked yet. Wait for that\n          once.call(this.player, this.player.media, 'timeupdate', function () {\n            // Re-check mousedown - we might have already started scrubbing again\n            if (!_this4.mouseDown) {\n              _this4.toggleScrubbingContainer(false);\n            }\n          });\n        }\n      }\n      /**\n       * Setup hooks for wassPlayer and window events\n       */\n\n    }, {\n      key: \"listeners\",\n      value: function listeners() {\n        var _this5 = this;\n\n        this.player.on('play', function () {\n          _this5.toggleThumbContainer(false, true);\n        });\n        this.player.on('seeked', function () {\n          _this5.toggleThumbContainer(false);\n        });\n        this.player.on('timeupdate', function () {\n          _this5.lastTime = _this5.player.media.currentTime;\n        });\n      }\n      /**\n       * Create HTML elements for image containers\n       */\n\n    }, {\n      key: \"render\",\n      value: function render() {\n        // Create HTML element: wassPlayer__preview-thumbnail-container\n        this.elements.thumb.container = createElement('div', {\n          class: this.player.config.classNames.previewThumbnails.thumbContainer\n        }); // Wrapper for the image for styling\n\n        this.elements.thumb.imageContainer = createElement('div', {\n          class: this.player.config.classNames.previewThumbnails.imageContainer\n        });\n        this.elements.thumb.container.appendChild(this.elements.thumb.imageContainer); // Create HTML element, parent+span: time text (e.g., 01:32:00)\n\n        var timeContainer = createElement('div', {\n          class: this.player.config.classNames.previewThumbnails.timeContainer\n        });\n        this.elements.thumb.time = createElement('span', {}, '00:00');\n        timeContainer.appendChild(this.elements.thumb.time);\n        this.elements.thumb.container.appendChild(timeContainer); // Inject the whole thumb\n\n        if (is$1.element(this.player.elements.progress)) {\n          this.player.elements.progress.appendChild(this.elements.thumb.container);\n        } // Create HTML element: wassPlayer__preview-scrubbing-container\n\n\n        this.elements.scrubbing.container = createElement('div', {\n          class: this.player.config.classNames.previewThumbnails.scrubbingContainer\n        });\n        this.player.elements.wrapper.appendChild(this.elements.scrubbing.container);\n      }\n    }, {\n      key: \"destroy\",\n      value: function destroy() {\n        if (this.elements.thumb.container) {\n          this.elements.thumb.container.remove();\n        }\n\n        if (this.elements.scrubbing.container) {\n          this.elements.scrubbing.container.remove();\n        }\n      }\n    }, {\n      key: \"showImageAtCurrentTime\",\n      value: function showImageAtCurrentTime() {\n        var _this6 = this;\n\n        if (this.mouseDown) {\n          this.setScrubbingContainerSize();\n        } else {\n          this.setThumbContainerSizeAndPos();\n        } // Find the desired thumbnail index\n\n\n        var thumbNum = this.thumbnails[0].frames.findIndex(function (frame) {\n          return _this6.seekTime >= frame.startTime && _this6.seekTime <= frame.endTime;\n        });\n        var hasThumb = thumbNum >= 0;\n        var qualityIndex = 0; // Show the thumb container if we're not scrubbing\n\n        if (!this.mouseDown) {\n          this.toggleThumbContainer(hasThumb);\n        } // No matching thumb found\n\n\n        if (!hasThumb) {\n          return;\n        } // Check to see if we've already downloaded higher quality versions of this image\n\n\n        this.thumbnails.forEach(function (thumbnail, index) {\n          if (_this6.loadedImages.includes(thumbnail.frames[thumbNum].text)) {\n            qualityIndex = index;\n          }\n        }); // Only proceed if either thumbnum or thumbfilename has changed\n\n        if (thumbNum !== this.showingThumb) {\n          this.showingThumb = thumbNum;\n          this.loadImage(qualityIndex);\n        }\n      } // Show the image that's currently specified in this.showingThumb\n\n    }, {\n      key: \"loadImage\",\n      value: function loadImage() {\n        var _this7 = this;\n\n        var qualityIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n        var thumbNum = this.showingThumb;\n        var thumbnail = this.thumbnails[qualityIndex];\n        var urlPrefix = thumbnail.urlPrefix;\n        var frame = thumbnail.frames[thumbNum];\n        var thumbFilename = thumbnail.frames[thumbNum].text;\n        var thumbUrl = urlPrefix + thumbFilename;\n\n        if (!this.currentImageElement || this.currentImageElement.dataset.filename !== thumbFilename) {\n          if (this.loadingImage && this.usingSprites) {\n            this.loadingImage.onload = null;\n          }\n\n          var previewImage = new Image();\n          previewImage.src = thumbUrl;\n          previewImage.dataset.index = thumbNum;\n          previewImage.dataset.filename = thumbFilename;\n          this.showingThumbFilename = thumbFilename;\n          this.player.debug.log(\"Loading image: \".concat(thumbUrl)); // For some reason, passing the named function directly causes it to execute immediately. So I've wrapped it in an anonymous function...\n\n          previewImage.onload = function () {\n            return _this7.showImage(previewImage, frame, qualityIndex, thumbNum, thumbFilename, true);\n          };\n\n          this.loadingImage = previewImage;\n          this.removeOldImages(previewImage);\n        } else {\n          // Update the existing image\n          this.showImage(this.currentImageElement, frame, qualityIndex, thumbNum, thumbFilename, false);\n          this.currentImageElement.dataset.index = thumbNum;\n          this.removeOldImages(this.currentImageElement);\n        }\n      }\n    }, {\n      key: \"showImage\",\n      value: function showImage(previewImage, frame, qualityIndex, thumbNum, thumbFilename) {\n        var newImage = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n        this.player.debug.log(\"Showing thumb: \".concat(thumbFilename, \". num: \").concat(thumbNum, \". qual: \").concat(qualityIndex, \". newimg: \").concat(newImage));\n        this.setImageSizeAndOffset(previewImage, frame);\n\n        if (newImage) {\n          this.currentImageContainer.appendChild(previewImage);\n          this.currentImageElement = previewImage;\n\n          if (!this.loadedImages.includes(thumbFilename)) {\n            this.loadedImages.push(thumbFilename);\n          }\n        }\n\n        this.preloadNearby(thumbNum, true).then(this.preloadNearby(thumbNum, false)).then(this.getHigherQuality(qualityIndex, previewImage, frame, thumbFilename));\n      } // Remove all preview images that aren't the designated current image\n\n    }, {\n      key: \"removeOldImages\",\n      value: function removeOldImages(currentImage) {\n        var _this8 = this;\n\n        // Get a list of all images, convert it from a DOM list to an array\n        Array.from(this.currentImageContainer.children).forEach(function (image) {\n          if (image.tagName.toLowerCase() !== 'img') {\n            return;\n          }\n\n          var removeDelay = _this8.usingSprites ? 500 : 1000;\n\n          if (image.dataset.index !== currentImage.dataset.index && !image.dataset.deleting) {\n            // eslint-disable-next-line no-param-reassign\n            image.dataset.deleting = true; // This has to be set before the timeout - to prevent issues switching between hover and scrub\n\n            var currentImageContainer = _this8.currentImageContainer;\n            setTimeout(function () {\n              currentImageContainer.removeChild(image);\n\n              _this8.player.debug.log(\"Removing thumb: \".concat(image.dataset.filename));\n            }, removeDelay);\n          }\n        });\n      } // Preload images before and after the current one. Only if the user is still hovering/seeking the same frame\n      // This will only preload the lowest quality\n\n    }, {\n      key: \"preloadNearby\",\n      value: function preloadNearby(thumbNum) {\n        var _this9 = this;\n\n        var forward = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n        return new Promise(function (resolve) {\n          setTimeout(function () {\n            var oldThumbFilename = _this9.thumbnails[0].frames[thumbNum].text;\n\n            if (_this9.showingThumbFilename === oldThumbFilename) {\n              // Find the nearest thumbs with different filenames. Sometimes it'll be the next index, but in the case of sprites, it might be 100+ away\n              var thumbnailsClone;\n\n              if (forward) {\n                thumbnailsClone = _this9.thumbnails[0].frames.slice(thumbNum);\n              } else {\n                thumbnailsClone = _this9.thumbnails[0].frames.slice(0, thumbNum).reverse();\n              }\n\n              var foundOne = false;\n              thumbnailsClone.forEach(function (frame) {\n                var newThumbFilename = frame.text;\n\n                if (newThumbFilename !== oldThumbFilename) {\n                  // Found one with a different filename. Make sure it hasn't already been loaded on this page visit\n                  if (!_this9.loadedImages.includes(newThumbFilename)) {\n                    foundOne = true;\n\n                    _this9.player.debug.log(\"Preloading thumb filename: \".concat(newThumbFilename));\n\n                    var urlPrefix = _this9.thumbnails[0].urlPrefix;\n                    var thumbURL = urlPrefix + newThumbFilename;\n                    var previewImage = new Image();\n                    previewImage.src = thumbURL;\n\n                    previewImage.onload = function () {\n                      _this9.player.debug.log(\"Preloaded thumb filename: \".concat(newThumbFilename));\n\n                      if (!_this9.loadedImages.includes(newThumbFilename)) _this9.loadedImages.push(newThumbFilename); // We don't resolve until the thumb is loaded\n\n                      resolve();\n                    };\n                  }\n                }\n              }); // If there are none to preload then we want to resolve immediately\n\n              if (!foundOne) {\n                resolve();\n              }\n            }\n          }, 300);\n        });\n      } // If user has been hovering current image for half a second, look for a higher quality one\n\n    }, {\n      key: \"getHigherQuality\",\n      value: function getHigherQuality(currentQualityIndex, previewImage, frame, thumbFilename) {\n        var _this10 = this;\n\n        if (currentQualityIndex < this.thumbnails.length - 1) {\n          // Only use the higher quality version if it's going to look any better - if the current thumb is of a lower pixel density than the thumbnail container\n          var previewImageHeight = previewImage.naturalHeight;\n\n          if (this.usingSprites) {\n            previewImageHeight = frame.h;\n          }\n\n          if (previewImageHeight < this.thumbContainerHeight) {\n            // Recurse back to the loadImage function - show a higher quality one, but only if the viewer is on this frame for a while\n            setTimeout(function () {\n              // Make sure the mouse hasn't already moved on and started hovering at another image\n              if (_this10.showingThumbFilename === thumbFilename) {\n                _this10.player.debug.log(\"Showing higher quality thumb for: \".concat(thumbFilename));\n\n                _this10.loadImage(currentQualityIndex + 1);\n              }\n            }, 300);\n          }\n        }\n      }\n    }, {\n      key: \"toggleThumbContainer\",\n      value: function toggleThumbContainer() {\n        var toggle = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n        var clearShowing = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n        var className = this.player.config.classNames.previewThumbnails.thumbContainerShown;\n        this.elements.thumb.container.classList.toggle(className, toggle);\n\n        if (!toggle && clearShowing) {\n          this.showingThumb = null;\n          this.showingThumbFilename = null;\n        }\n      }\n    }, {\n      key: \"toggleScrubbingContainer\",\n      value: function toggleScrubbingContainer() {\n        var toggle = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n        var className = this.player.config.classNames.previewThumbnails.scrubbingContainerShown;\n        this.elements.scrubbing.container.classList.toggle(className, toggle);\n\n        if (!toggle) {\n          this.showingThumb = null;\n          this.showingThumbFilename = null;\n        }\n      }\n    }, {\n      key: \"determineContainerAutoSizing\",\n      value: function determineContainerAutoSizing() {\n        if (this.elements.thumb.imageContainer.clientHeight > 20 || this.elements.thumb.imageContainer.clientWidth > 20) {\n          // This will prevent auto sizing in this.setThumbContainerSizeAndPos()\n          this.sizeSpecifiedInCSS = true;\n        }\n      } // Set the size to be about a quarter of the size of video. Unless option dynamicSize === false, in which case it needs to be set in CSS\n\n    }, {\n      key: \"setThumbContainerSizeAndPos\",\n      value: function setThumbContainerSizeAndPos() {\n        if (!this.sizeSpecifiedInCSS) {\n          var thumbWidth = Math.floor(this.thumbContainerHeight * this.thumbAspectRatio);\n          this.elements.thumb.imageContainer.style.height = \"\".concat(this.thumbContainerHeight, \"px\");\n          this.elements.thumb.imageContainer.style.width = \"\".concat(thumbWidth, \"px\");\n        } else if (this.elements.thumb.imageContainer.clientHeight > 20 && this.elements.thumb.imageContainer.clientWidth < 20) {\n          var _thumbWidth = Math.floor(this.elements.thumb.imageContainer.clientHeight * this.thumbAspectRatio);\n\n          this.elements.thumb.imageContainer.style.width = \"\".concat(_thumbWidth, \"px\");\n        } else if (this.elements.thumb.imageContainer.clientHeight < 20 && this.elements.thumb.imageContainer.clientWidth > 20) {\n          var thumbHeight = Math.floor(this.elements.thumb.imageContainer.clientWidth / this.thumbAspectRatio);\n          this.elements.thumb.imageContainer.style.height = \"\".concat(thumbHeight, \"px\");\n        }\n\n        this.setThumbContainerPos();\n      }\n    }, {\n      key: \"setThumbContainerPos\",\n      value: function setThumbContainerPos() {\n        var seekbarRect = this.player.elements.progress.getBoundingClientRect();\n        var wassPlayerRect = this.player.elements.container.getBoundingClientRect();\n        var container = this.elements.thumb.container; // Find the lowest and highest desired left-position, so we don't slide out the side of the video container\n\n        var minVal = wassPlayerRect.left - seekbarRect.left + 10;\n        var maxVal = wassPlayerRect.right - seekbarRect.left - container.clientWidth - 10; // Set preview container position to: mousepos, minus seekbar.left, minus half of previewContainer.clientWidth\n\n        var previewPos = this.mousePosX - seekbarRect.left - container.clientWidth / 2;\n\n        if (previewPos < minVal) {\n          previewPos = minVal;\n        }\n\n        if (previewPos > maxVal) {\n          previewPos = maxVal;\n        }\n\n        container.style.left = \"\".concat(previewPos, \"px\");\n      } // Can't use 100% width, in case the video is a different aspect ratio to the video container\n\n    }, {\n      key: \"setScrubbingContainerSize\",\n      value: function setScrubbingContainerSize() {\n        var _fitRatio = fitRatio(this.thumbAspectRatio, {\n          width: this.player.media.clientWidth,\n          height: this.player.media.clientHeight\n        }),\n            width = _fitRatio.width,\n            height = _fitRatio.height;\n\n        this.elements.scrubbing.container.style.width = \"\".concat(width, \"px\");\n        this.elements.scrubbing.container.style.height = \"\".concat(height, \"px\");\n      } // Sprites need to be offset to the correct location\n\n    }, {\n      key: \"setImageSizeAndOffset\",\n      value: function setImageSizeAndOffset(previewImage, frame) {\n        if (!this.usingSprites) {\n          return;\n        } // Find difference between height and preview container height\n\n\n        var multiplier = this.thumbContainerHeight / frame.h; // eslint-disable-next-line no-param-reassign\n\n        previewImage.style.height = \"\".concat(previewImage.naturalHeight * multiplier, \"px\"); // eslint-disable-next-line no-param-reassign\n\n        previewImage.style.width = \"\".concat(previewImage.naturalWidth * multiplier, \"px\"); // eslint-disable-next-line no-param-reassign\n\n        previewImage.style.left = \"-\".concat(frame.x * multiplier, \"px\"); // eslint-disable-next-line no-param-reassign\n\n        previewImage.style.top = \"-\".concat(frame.y * multiplier, \"px\");\n      }\n    }, {\n      key: \"enabled\",\n      get: function get() {\n        return this.player.isHTML5 && this.player.isVideo && this.player.config.previewThumbnails.enabled;\n      }\n    }, {\n      key: \"currentImageContainer\",\n      get: function get() {\n        if (this.mouseDown) {\n          return this.elements.scrubbing.container;\n        }\n\n        return this.elements.thumb.imageContainer;\n      }\n    }, {\n      key: \"usingSprites\",\n      get: function get() {\n        return Object.keys(this.thumbnails[0].frames[0]).includes('w');\n      }\n    }, {\n      key: \"thumbAspectRatio\",\n      get: function get() {\n        if (this.usingSprites) {\n          return this.thumbnails[0].frames[0].w / this.thumbnails[0].frames[0].h;\n        }\n\n        return this.thumbnails[0].width / this.thumbnails[0].height;\n      }\n    }, {\n      key: \"thumbContainerHeight\",\n      get: function get() {\n        if (this.mouseDown) {\n          var _fitRatio2 = fitRatio(this.thumbAspectRatio, {\n            width: this.player.media.clientWidth,\n            height: this.player.media.clientHeight\n          }),\n              height = _fitRatio2.height;\n\n          return height;\n        } // If css is used this needs to return the css height for sprites to work (see setImageSizeAndOffset)\n\n\n        if (this.sizeSpecifiedInCSS) {\n          return this.elements.thumb.imageContainer.clientHeight;\n        }\n\n        return Math.floor(this.player.media.clientWidth / this.thumbAspectRatio / 4);\n      }\n    }, {\n      key: \"currentImageElement\",\n      get: function get() {\n        if (this.mouseDown) {\n          return this.currentScrubbingImageElement;\n        }\n\n        return this.currentThumbnailImageElement;\n      },\n      set: function set(element) {\n        if (this.mouseDown) {\n          this.currentScrubbingImageElement = element;\n        } else {\n          this.currentThumbnailImageElement = element;\n        }\n      }\n    }]);\n\n    return PreviewThumbnails;\n  }();\n\n  var source = {\n    // Add elements to HTML5 media (source, tracks, etc)\n    insertElements: function insertElements(type, attributes) {\n      var _this = this;\n\n      if (is$1.string(attributes)) {\n        insertElement(type, this.media, {\n          src: attributes\n        });\n      } else if (is$1.array(attributes)) {\n        attributes.forEach(function (attribute) {\n          insertElement(type, _this.media, attribute);\n        });\n      }\n    },\n    // Update source\n    // Sources are not checked for support so be careful\n    change: function change(input) {\n      var _this2 = this;\n\n      if (!getDeep(input, 'sources.length')) {\n        this.debug.warn('Invalid source format');\n        return;\n      } // Cancel current network requests\n\n\n      html5.cancelRequests.call(this); // Destroy instance and re-setup\n\n      this.destroy.call(this, function () {\n        // Reset quality options\n        _this2.options.quality = []; // Remove elements\n\n        removeElement(_this2.media);\n        _this2.media = null; // Reset class name\n\n        if (is$1.element(_this2.elements.container)) {\n          _this2.elements.container.removeAttribute('class');\n        } // Set the type and provider\n\n\n        var sources = input.sources,\n            type = input.type;\n\n        var _sources = _slicedToArray(sources, 1),\n            _sources$ = _sources[0],\n            _sources$$provider = _sources$.provider,\n            provider = _sources$$provider === void 0 ? providers.html5 : _sources$$provider,\n            src = _sources$.src;\n\n        var tagName = provider === 'html5' ? type : 'div';\n        var attributes = provider === 'html5' ? {} : {\n          src: src\n        };\n        Object.assign(_this2, {\n          provider: provider,\n          type: type,\n          // Check for support\n          supported: support.check(type, provider, _this2.config.playsinline),\n          // Create new element\n          media: createElement(tagName, attributes)\n        }); // Inject the new element\n\n        _this2.elements.container.appendChild(_this2.media); // Autoplay the new source?\n\n\n        if (is$1.boolean(input.autoplay)) {\n          _this2.config.autoplay = input.autoplay;\n        } // Set attributes for audio and video\n\n\n        if (_this2.isHTML5) {\n          if (_this2.config.crossorigin) {\n            _this2.media.setAttribute('crossorigin', '');\n          }\n\n          if (_this2.config.autoplay) {\n            _this2.media.setAttribute('autoplay', '');\n          }\n\n          if (!is$1.empty(input.poster)) {\n            _this2.poster = input.poster;\n          }\n\n          if (_this2.config.loop.active) {\n            _this2.media.setAttribute('loop', '');\n          }\n\n          if (_this2.config.muted) {\n            _this2.media.setAttribute('muted', '');\n          }\n\n          if (_this2.config.playsinline) {\n            _this2.media.setAttribute('playsinline', '');\n          }\n        } // Restore class hook\n\n\n        ui.addStyleHook.call(_this2); // Set new sources for html5\n\n        if (_this2.isHTML5) {\n          source.insertElements.call(_this2, 'source', sources);\n        } // Set video title\n\n\n        _this2.config.title = input.title; // Set up from scratch\n\n        media.setup.call(_this2); // HTML5 stuff\n\n        if (_this2.isHTML5) {\n          // Setup captions\n          if (Object.keys(input).includes('tracks')) {\n            source.insertElements.call(_this2, 'track', input.tracks);\n          }\n        } // If HTML5 or embed but not fully supported, setupInterface and call ready now\n\n\n        if (_this2.isHTML5 || _this2.isEmbed && !_this2.supported.ui) {\n          // Setup interface\n          ui.build.call(_this2);\n        } // Load HTML5 sources\n\n\n        if (_this2.isHTML5) {\n          _this2.media.load();\n        } // Update previewThumbnails config & reload plugin\n\n\n        if (!is$1.empty(input.previewThumbnails)) {\n          Object.assign(_this2.config.previewThumbnails, input.previewThumbnails); // Cleanup previewThumbnails plugin if it was loaded\n\n          if (_this2.previewThumbnails && _this2.previewThumbnails.loaded) {\n            _this2.previewThumbnails.destroy();\n\n            _this2.previewThumbnails = null;\n          } // Create new instance if it is still enabled\n\n\n          if (_this2.config.previewThumbnails.enabled) {\n            _this2.previewThumbnails = new PreviewThumbnails(_this2);\n          }\n        } // Update the fullscreen support\n\n\n        _this2.fullscreen.update();\n      }, true);\n    }\n  };\n\n  /**\n   * Returns a number whose value is limited to the given range.\n   *\n   * Example: limit the output of this computation to between 0 and 255\n   * (x * 255).clamp(0, 255)\n   *\n   * @param {Number} input\n   * @param {Number} min The lower boundary of the output range\n   * @param {Number} max The upper boundary of the output range\n   * @returns A number in the range [min, max]\n   * @type Number\n   */\n  function clamp() {\n    var input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    var min = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var max = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 255;\n    return Math.min(Math.max(input, min), max);\n  }\n\n  var WassPlayer = /*#__PURE__*/function () {\n    function WassPlayer(target, options) {\n      var _this = this;\n\n      _classCallCheck(this, WassPlayer);\n\n      this.timers = {}; // State\n\n      this.ready = false;\n      this.loading = false;\n      this.failed = false; // Touch device\n\n      this.touch = support.touch; // Set the media element\n\n      this.media = target; // String selector passed\n\n      if (is$1.string(this.media)) {\n        this.media = document.querySelectorAll(this.media);\n      } // jQuery, NodeList or Array passed, use first element\n\n\n      if (window.jQuery && this.media instanceof jQuery || is$1.nodeList(this.media) || is$1.array(this.media)) {\n        // eslint-disable-next-line\n        this.media = this.media[0];\n      } // Set config\n\n\n      this.config = extend({}, defaults$1, WassPlayer.defaults, options || {}, function () {\n        try {\n          return JSON.parse(_this.media.getAttribute('data-wassPlayer-config'));\n        } catch (e) {\n          return {};\n        }\n      }()); // Elements cache\n\n      this.elements = {\n        container: null,\n        fullscreen: null,\n        captions: null,\n        buttons: {},\n        display: {},\n        progress: {},\n        inputs: {},\n        settings: {\n          popup: null,\n          menu: null,\n          panels: {},\n          buttons: {}\n        }\n      }; // Captions\n\n      this.captions = {\n        active: null,\n        currentTrack: -1,\n        meta: new WeakMap()\n      }; // Fullscreen\n\n      this.fullscreen = {\n        active: false\n      }; // Options\n\n      this.options = {\n        speed: [],\n        quality: []\n      }; // Debugging\n      // TODO: move to globals\n\n      this.debug = new Console(this.config.debug); // Log config options and support\n\n      this.debug.log('Config', this.config);\n      this.debug.log('Support', support); // We need an element to setup\n\n      if (is$1.nullOrUndefined(this.media) || !is$1.element(this.media)) {\n        this.debug.error('Setup failed: no suitable element passed');\n        return;\n      } // Bail if the element is initialized\n\n\n      if (this.media.wassPlayer) {\n        this.debug.warn('Target already setup');\n        return;\n      } // Bail if not enabled\n\n\n      if (!this.config.enabled) {\n        this.debug.error('Setup failed: disabled by config');\n        return;\n      } // Bail if disabled or no basic support\n      // You may want to disable certain UAs etc\n\n\n      if (!support.check().api) {\n        this.debug.error('Setup failed: no support');\n        return;\n      } // Cache original element state for .destroy()\n\n\n      var clone = this.media.cloneNode(true);\n      clone.autoplay = false;\n      this.elements.original = clone; // Set media type based on tag or data attribute\n      // Supported: video\n\n      var type = this.media.tagName.toLowerCase(); // Embed properties\n\n      var iframe = null;\n      var url = null; // Different setup based on type\n\n      switch (type) {\n        case 'div':\n          // Find the frame\n          iframe = this.media.querySelector('iframe'); // <iframe> type\n\n          if (is$1.element(iframe)) {\n            // Detect provider\n            url = parseUrl(iframe.getAttribute('src'));\n            this.provider = getProviderByUrl(url.toString()); // Rework elements\n\n            this.elements.container = this.media;\n            this.media = iframe; // Reset classname\n\n            this.elements.container.className = ''; // Get attributes from URL and set config\n\n            if (url.search.length) {\n              var truthy = ['1', 'true'];\n\n              if (truthy.includes(url.searchParams.get('autoplay'))) {\n                this.config.autoplay = true;\n              }\n\n              if (truthy.includes(url.searchParams.get('loop'))) {\n                this.config.loop.active = true;\n              }\n\n              this.config.playsinline = true;\n            }\n          } else {\n            // <div> with attributes\n            this.provider = this.media.getAttribute(this.config.attributes.embed.provider); // Remove attribute\n\n            this.media.removeAttribute(this.config.attributes.embed.provider);\n          } // Unsupported or missing provider\n\n\n          if (is$1.empty(this.provider) || !Object.keys(providers).includes(this.provider)) {\n            this.debug.error('Setup failed: Invalid provider');\n            return;\n          } // Audio will come later for external providers\n\n\n          this.type = types.video;\n          break;\n\n        case 'video':\n        case 'audio':\n          this.type = type;\n          this.provider = providers.html5; // Get config from attributes\n\n          if (this.media.hasAttribute('crossorigin')) {\n            this.config.crossorigin = true;\n          }\n\n          if (this.media.hasAttribute('autoplay')) {\n            this.config.autoplay = true;\n          }\n\n          if (this.media.hasAttribute('playsinline') || this.media.hasAttribute('webkit-playsinline')) {\n            this.config.playsinline = true;\n          }\n\n          if (this.media.hasAttribute('muted')) {\n            this.config.muted = true;\n          }\n\n          if (this.media.hasAttribute('loop')) {\n            this.config.loop.active = true;\n          }\n\n          break;\n\n        default:\n          this.debug.error('Setup failed: unsupported type');\n          return;\n      } // Check for support again but with type\n\n\n      this.supported = support.check(this.type, this.provider, this.config.playsinline); // If no support for even API, bail\n\n      if (!this.supported.api) {\n        this.debug.error('Setup failed: no support');\n        return;\n      }\n\n      this.eventListeners = []; // Create listeners\n\n      this.listeners = new Listeners(this); // Setup local storage for user settings\n\n      this.storage = new Storage(this); // Store reference\n\n      this.media.wassPlayer = this; // Wrap media\n\n      if (!is$1.element(this.elements.container)) {\n        this.elements.container = createElement('div', {\n          tabindex: 0\n        });\n        wrap(this.media, this.elements.container);\n      } // Migrate custom properties from media to container (so they work )\n\n\n      ui.migrateStyles.call(this); // Add style hook\n\n      ui.addStyleHook.call(this); // Setup media\n\n      media.setup.call(this); // Listen for events if debugging\n\n      if (this.config.debug) {\n        on.call(this, this.elements.container, this.config.events.join(' '), function (event) {\n          _this.debug.log(\"event: \".concat(event.type));\n        });\n      } // Setup fullscreen\n\n\n      this.fullscreen = new Fullscreen(this); // Setup interface\n      // If embed but not fully supported, build interface now to avoid flash of controls\n\n      if (this.isHTML5 || this.isEmbed && !this.supported.ui) {\n        ui.build.call(this);\n      } // Container listeners\n\n\n      this.listeners.container(); // Global listeners\n\n      this.listeners.global(); // Autoplay if required\n\n      if (this.isHTML5 && this.config.autoplay) {\n        setTimeout(function () {\n          return silencePromise(_this.play());\n        }, 10);\n      } // Seek time will be recorded (in listeners.js) so we can prevent hiding controls for a few seconds after seek\n\n\n      this.lastSeekTime = 0; // Setup preview thumbnails if enabled\n\n      if (this.config.previewThumbnails.enabled) {\n        this.previewThumbnails = new PreviewThumbnails(this);\n      }\n    } // ---------------------------------------\n    // API\n    // ---------------------------------------\n\n    /**\n     * Types and provider helpers\n     */\n\n\n    _createClass(WassPlayer, [{\n      key: \"play\",\n\n      /**\n       * Play the media, or play the advertisement (if they are not blocked)\n       */\n      value: function play() {\n        if (!is$1.function(this.media.play)) {\n          return null;\n        } // Return the promise (for HTML5)\n\n\n        return this.media.play();\n      }\n      /**\n       * Pause the media\n       */\n\n    }, {\n      key: \"pause\",\n      value: function pause() {\n        if (!this.playing || !is$1.function(this.media.pause)) {\n          return null;\n        }\n\n        return this.media.pause();\n      }\n      /**\n       * Get playing state\n       */\n\n    }, {\n      key: \"togglePlay\",\n\n      /**\n       * Toggle playback based on current status\n       * @param {Boolean} input\n       */\n      value: function togglePlay(input) {\n        // Toggle based on current state if nothing passed\n        var toggle = is$1.boolean(input) ? input : !this.playing;\n\n        if (toggle) {\n          return this.play();\n        }\n\n        return this.pause();\n      }\n      /**\n       * Stop playback\n       */\n\n    }, {\n      key: \"stop\",\n      value: function stop() {\n        if (this.isHTML5) {\n          this.pause();\n          this.restart();\n        } else if (is$1.function(this.media.stop)) {\n          this.media.stop();\n        }\n      }\n      /**\n       * Restart playback\n       */\n\n    }, {\n      key: \"restart\",\n      value: function restart() {\n        this.currentTime = 0;\n      }\n      /**\n       * Rewind\n       * @param {Number} seekTime - how far to rewind in seconds. Defaults to the config.seekTime\n       */\n\n    }, {\n      key: \"rewind\",\n      value: function rewind(seekTime) {\n        this.currentTime -= is$1.number(seekTime) ? seekTime : this.config.seekTime;\n      }\n      /**\n       * Fast forward\n       * @param {Number} seekTime - how far to fast forward in seconds. Defaults to the config.seekTime\n       */\n\n    }, {\n      key: \"forward\",\n      value: function forward(seekTime) {\n        this.currentTime += is$1.number(seekTime) ? seekTime : this.config.seekTime;\n      }\n      /**\n       * Seek to a time\n       * @param {Number} input - where to seek to in seconds. Defaults to 0 (the start)\n       */\n\n    }, {\n      key: \"increaseVolume\",\n\n      /**\n       * Increase volume\n       * @param {Boolean} step - How much to decrease by (between 0 and 1)\n       */\n      value: function increaseVolume(step) {\n        var volume = this.media.muted ? 0 : this.volume;\n        this.volume = volume + (is$1.number(step) ? step : 0);\n      }\n      /**\n       * Decrease volume\n       * @param {Boolean} step - How much to decrease by (between 0 and 1)\n       */\n\n    }, {\n      key: \"decreaseVolume\",\n      value: function decreaseVolume(step) {\n        this.increaseVolume(-step);\n      }\n      /**\n       * Set muted state\n       * @param {Boolean} mute\n       */\n\n    }, {\n      key: \"toggleCaptions\",\n\n      /**\n       * Toggle captions\n       * @param {Boolean} input - Whether to enable captions\n       */\n      value: function toggleCaptions(input) {\n        captions.toggle.call(this, input, false);\n      }\n      /**\n       * Set the caption track by index\n       * @param {Number} - Caption index\n       */\n\n    }, {\n      key: \"airplay\",\n\n      /**\n       * Trigger the airplay dialog\n       */\n      value: function airplay() {\n        // Show dialog if supported\n        if (support.airplay) {\n          this.media.webkitShowPlaybackTargetPicker();\n        }\n      }\n      /**\n       * Toggle the player controls\n       * @param {Boolean} [toggle] - Whether to show the controls\n       */\n\n    }, {\n      key: \"toggleControls\",\n      value: function toggleControls(toggle) {\n        // Don't toggle if missing UI support or if it's audio\n        if (this.supported.ui && !this.isAudio) {\n          // Get state before change\n          var isHidden = hasClass(this.elements.container, this.config.classNames.hideControls); // Negate the argument if not undefined since adding the class to hides the controls\n\n          var force = typeof toggle === 'undefined' ? undefined : !toggle; // Apply and get updated state\n\n          var hiding = toggleClass(this.elements.container, this.config.classNames.hideControls, force); // Close menu\n\n          if (hiding && is$1.array(this.config.controls) && this.config.controls.includes('settings') && !is$1.empty(this.config.settings)) {\n            controls.toggleMenu.call(this, false);\n          } // Trigger event on change\n\n\n          if (hiding !== isHidden) {\n            var eventName = hiding ? 'controlshidden' : 'controlsshown';\n            triggerEvent.call(this, this.media, eventName);\n          }\n\n          return !hiding;\n        }\n\n        return false;\n      }\n      /**\n       * Add event listeners\n       * @param {String} event - Event type\n       * @param {Function} callback - Callback for when event occurs\n       */\n\n    }, {\n      key: \"on\",\n      value: function on$1(event, callback) {\n        on.call(this, this.elements.container, event, callback);\n      }\n      /**\n       * Add event listeners once\n       * @param {String} event - Event type\n       * @param {Function} callback - Callback for when event occurs\n       */\n\n    }, {\n      key: \"once\",\n      value: function once$1(event, callback) {\n        once.call(this, this.elements.container, event, callback);\n      }\n      /**\n       * Remove event listeners\n       * @param {String} event - Event type\n       * @param {Function} callback - Callback for when event occurs\n       */\n\n    }, {\n      key: \"off\",\n      value: function off$1(event, callback) {\n        off(this.elements.container, event, callback);\n      }\n      /**\n       * Destroy an instance\n       * Event listeners are removed when elements are removed\n       * http://stackoverflow.com/questions/12528049/if-a-dom-element-is-removed-are-its-listeners-also-removed-from-memory\n       * @param {Function} callback - Callback for when destroy is complete\n       * @param {Boolean} soft - Whether it's a soft destroy (for source changes etc)\n       */\n\n    }, {\n      key: \"destroy\",\n      value: function destroy(callback) {\n        var _this2 = this;\n\n        var soft = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n        if (!this.ready) {\n          return;\n        }\n\n        var done = function done() {\n          // Reset overflow (incase destroyed while in fullscreen)\n          document.body.style.overflow = ''; // GC for embed\n\n          _this2.embed = null; // If it's a soft destroy, make minimal changes\n\n          if (soft) {\n            if (Object.keys(_this2.elements).length) {\n              // Remove elements\n              removeElement(_this2.elements.buttons.play);\n              removeElement(_this2.elements.captions);\n              removeElement(_this2.elements.controls);\n              removeElement(_this2.elements.wrapper); // Clear for GC\n\n              _this2.elements.buttons.play = null;\n              _this2.elements.captions = null;\n              _this2.elements.controls = null;\n              _this2.elements.wrapper = null;\n            } // Callback\n\n\n            if (is$1.function(callback)) {\n              callback();\n            }\n          } else {\n            // Unbind listeners\n            unbindListeners.call(_this2); // Replace the container with the original element provided\n\n            replaceElement(_this2.elements.original, _this2.elements.container); // Event\n\n            triggerEvent.call(_this2, _this2.elements.original, 'destroyed', true); // Callback\n\n            if (is$1.function(callback)) {\n              callback.call(_this2.elements.original);\n            } // Reset state\n\n\n            _this2.ready = false; // Clear for garbage collection\n\n            setTimeout(function () {\n              _this2.elements = null;\n              _this2.media = null;\n            }, 200);\n          }\n        }; // Stop playback\n\n\n        this.stop(); // Clear timeouts\n\n        clearTimeout(this.timers.loading);\n        clearTimeout(this.timers.controls);\n        clearTimeout(this.timers.resized); // Provider specific stuff\n\n        if (this.isHTML5) {\n          // Restore native video controls\n          ui.toggleNativeControls.call(this, true); // Clean up\n\n          done();\n        }\n      }\n      /**\n       * Check for support for a mime type (HTML5 only)\n       * @param {String} type - Mime type\n       */\n\n    }, {\n      key: \"supports\",\n      value: function supports(type) {\n        return support.mime.call(this, type);\n      }\n      /**\n       * Check for support\n       * @param {String} type - Player type (video)\n       * @param {String} provider - Provider (html5)\n       * @param {Boolean} inline - Where player has `playsinline` sttribute\n       */\n\n    }, {\n      key: \"isHTML5\",\n      get: function get() {\n        return this.provider === providers.html5;\n      }\n    }, {\n      key: \"isVideo\",\n      get: function get() {\n        return this.type === types.video;\n      }\n    }, {\n      key: \"playing\",\n      get: function get() {\n        return Boolean(this.ready && !this.paused && !this.ended);\n      }\n      /**\n       * Get paused state\n       */\n\n    }, {\n      key: \"paused\",\n      get: function get() {\n        return Boolean(this.media.paused);\n      }\n      /**\n       * Get stopped state\n       */\n\n    }, {\n      key: \"stopped\",\n      get: function get() {\n        return Boolean(this.paused && this.currentTime === 0);\n      }\n      /**\n       * Get ended state\n       */\n\n    }, {\n      key: \"ended\",\n      get: function get() {\n        return Boolean(this.media.ended);\n      }\n    }, {\n      key: \"currentTime\",\n      set: function set(input) {\n        // Bail if media duration isn't available yet\n        if (!this.duration) {\n          return;\n        } // Validate input\n\n\n        var inputIsValid = is$1.number(input) && input > 0; // Set\n\n        this.media.currentTime = inputIsValid ? Math.min(input, this.duration) : 0; // Logging\n\n        this.debug.log(\"Seeking to \".concat(this.currentTime, \" seconds\"));\n      }\n      /**\n       * Get current time\n       */\n      ,\n      get: function get() {\n        return Number(this.media.currentTime);\n      }\n      /**\n       * Get buffered\n       */\n\n    }, {\n      key: \"buffered\",\n      get: function get() {\n        var buffered = this.media.buffered;\n\n        if (is$1.number(buffered)) {\n          return buffered;\n        } // HTML5\n        // (i.e. seek to another section buffers only that section)\n\n\n        if (buffered && buffered.length && this.duration > 0) {\n          return buffered.end(0) / this.duration;\n        }\n\n        return 0;\n      }\n      /**\n       * Get seeking status\n       */\n\n    }, {\n      key: \"seeking\",\n      get: function get() {\n        return Boolean(this.media.seeking);\n      }\n      /**\n       * Get the duration of the current media\n       */\n\n    }, {\n      key: \"duration\",\n      get: function get() {\n        // Faux duration set via config\n        var fauxDuration = parseFloat(this.config.duration); // Media duration can be NaN or Infinity before the media has loaded\n\n        var realDuration = (this.media || {}).duration;\n        var duration = !is$1.number(realDuration) || realDuration === Infinity ? 0 : realDuration; // If config duration is funky, use regular duration\n\n        return fauxDuration || duration;\n      }\n      /**\n       * Set the player volume\n       * @param {Number} value - must be between 0 and 1. Defaults to the value from local storage and config.volume if not set in storage\n       */\n\n    }, {\n      key: \"volume\",\n      set: function set(value) {\n        var volume = value;\n        var max = 1;\n        var min = 0;\n\n        if (is$1.string(volume)) {\n          volume = Number(volume);\n        } // Load volume from storage if no value specified\n\n\n        if (!is$1.number(volume)) {\n          volume = this.storage.get('volume');\n        } // Use config if all else fails\n\n\n        if (!is$1.number(volume)) {\n          volume = this.config.volume;\n        } // Maximum is volumeMax\n\n\n        if (volume > max) {\n          volume = max;\n        } // Minimum is volumeMin\n\n\n        if (volume < min) {\n          volume = min;\n        } // Update config\n\n\n        this.config.volume = volume; // Set the player volume\n\n        this.media.volume = volume; // If muted, and we're increasing volume manually, reset muted state\n\n        if (!is$1.empty(value) && this.muted && volume > 0) {\n          this.muted = false;\n        }\n      }\n      /**\n       * Get the current player volume\n       */\n      ,\n      get: function get() {\n        return Number(this.media.volume);\n      }\n    }, {\n      key: \"muted\",\n      set: function set(mute) {\n        var toggle = mute; // Load muted state from storage\n\n        if (!is$1.boolean(toggle)) {\n          toggle = this.storage.get('muted');\n        } // Use config if all else fails\n\n\n        if (!is$1.boolean(toggle)) {\n          toggle = this.config.muted;\n        } // Update config\n\n\n        this.config.muted = toggle; // Set mute on the player\n\n        this.media.muted = toggle;\n      }\n      /**\n       * Get current muted state\n       */\n      ,\n      get: function get() {\n        return Boolean(this.media.muted);\n      }\n      /**\n       * Check if the media has audio\n       */\n\n    }, {\n      key: \"hasAudio\",\n      get: function get() {\n        // Assume yes for all non HTML5 (as we can't tell...)\n        if (!this.isHTML5) {\n          return true;\n        }\n\n        if (this.isAudio) {\n          return true;\n        } // Get audio tracks\n\n\n        return Boolean(this.media.mozHasAudio) || Boolean(this.media.webkitAudioDecodedByteCount) || Boolean(this.media.audioTracks && this.media.audioTracks.length);\n      }\n      /**\n       * Set playback speed\n       * @param {Number} speed - the speed of playback (0.5-2.0)\n       */\n\n    }, {\n      key: \"speed\",\n      set: function set(input) {\n        var _this3 = this;\n\n        var speed = null;\n\n        if (is$1.number(input)) {\n          speed = input;\n        }\n\n        if (!is$1.number(speed)) {\n          speed = this.storage.get('speed');\n        }\n\n        if (!is$1.number(speed)) {\n          speed = this.config.speed.selected;\n        } // Clamp to min/max\n\n\n        var min = this.minimumSpeed,\n            max = this.maximumSpeed;\n        speed = clamp(speed, min, max); // Update config\n\n        this.config.speed.selected = speed; // Set media speed\n\n        setTimeout(function () {\n          _this3.media.playbackRate = speed;\n        }, 0);\n      }\n      /**\n       * Get current playback speed\n       */\n      ,\n      get: function get() {\n        return Number(this.media.playbackRate);\n      }\n      /**\n       * Get the minimum allowed speed\n       */\n      // eslint-disable-next-line class-methods-use-this\n\n    }, {\n      key: \"minimumSpeed\",\n      get: function get() {\n        return 0.0625;\n      }\n      /**\n       * Get the maximum allowed speed\n       */\n      // eslint-disable-next-line class-methods-use-this\n\n    }, {\n      key: \"maximumSpeed\",\n      get: function get() {\n        return 16;\n      }\n      /**\n       * Set playback quality\n       * Currently HTML5 only\n       * @param {Number} input - Quality level\n       */\n\n    }, {\n      key: \"quality\",\n      set: function set(input) {\n        var config = this.config.quality;\n        var options = this.options.quality;\n\n        if (!options.length) {\n          return;\n        }\n\n        var quality = [!is$1.empty(input) && Number(input), this.storage.get('quality'), config.selected, config.default].find(is$1.number);\n        var updateStorage = true;\n\n        if (!options.includes(quality)) {\n          var value = closest$1(options, quality);\n          this.debug.warn(\"Unsupported quality option: \".concat(quality, \", using \").concat(value, \" instead\"));\n          quality = value; // Don't update storage if quality is not supported\n\n          updateStorage = false;\n        } // Update config\n\n\n        config.selected = quality; // Set quality\n\n        this.media.quality = quality; // Save to storage\n\n        if (updateStorage) {\n          this.storage.set({\n            quality: quality\n          });\n        }\n      }\n      /**\n       * Get current quality level\n       */\n      ,\n      get: function get() {\n        return this.media.quality;\n      }\n      /**\n       * Toggle loop\n       * @param {Boolean} input - Whether to loop or not\n       */\n\n    }, {\n      key: \"loop\",\n      set: function set(input) {\n        var toggle = is$1.boolean(input) ? input : this.config.loop.active;\n        this.config.loop.active = toggle;\n        this.media.loop = toggle; // Set default to be a true toggle\n\n        /* const type = ['start', 'end', 'all', 'none', 'toggle'].includes(input) ? input : 'toggle';\n             switch (type) {\n                case 'start':\n                    if (this.config.loop.end && this.config.loop.end <= this.currentTime) {\n                        this.config.loop.end = null;\n                    }\n                    this.config.loop.start = this.currentTime;\n                    // this.config.loop.indicator.start = this.elements.display.played.value;\n                    break;\n                 case 'end':\n                    if (this.config.loop.start >= this.currentTime) {\n                        return this;\n                    }\n                    this.config.loop.end = this.currentTime;\n                    // this.config.loop.indicator.end = this.elements.display.played.value;\n                    break;\n                 case 'all':\n                    this.config.loop.start = 0;\n                    this.config.loop.end = this.duration - 2;\n                    this.config.loop.indicator.start = 0;\n                    this.config.loop.indicator.end = 100;\n                    break;\n                 case 'toggle':\n                    if (this.config.loop.active) {\n                        this.config.loop.start = 0;\n                        this.config.loop.end = null;\n                    } else {\n                        this.config.loop.start = 0;\n                        this.config.loop.end = this.duration - 2;\n                    }\n                    break;\n                 default:\n                    this.config.loop.start = 0;\n                    this.config.loop.end = null;\n                    break;\n            } */\n      }\n      /**\n       * Get current loop state\n       */\n      ,\n      get: function get() {\n        return Boolean(this.media.loop);\n      }\n      /**\n       * Set new media source\n       * @param {Object} input - The new source object (see docs)\n       */\n\n    }, {\n      key: \"source\",\n      set: function set(input) {\n        source.change.call(this, input);\n      }\n      /**\n       * Get current source\n       */\n      ,\n      get: function get() {\n        return this.media.currentSrc;\n      }\n      /**\n       * Get a download URL (either source or custom)\n       */\n\n    }, {\n      key: \"download\",\n      get: function get() {\n        var download = this.config.urls.download;\n        return is$1.url(download) ? download : this.source;\n      }\n      /**\n       * Set the download URL\n       */\n      ,\n      set: function set(input) {\n        if (!is$1.url(input)) {\n          return;\n        }\n\n        this.config.urls.download = input;\n        controls.setDownloadUrl.call(this);\n      }\n      /**\n       * Set the poster image for a video\n       * @param {String} input - the URL for the new poster image\n       */\n\n    }, {\n      key: \"poster\",\n      set: function set(input) {\n        if (!this.isVideo) {\n          this.debug.warn('Poster can only be set for video');\n          return;\n        }\n\n        ui.setPoster.call(this, input, false).catch(function () {});\n      }\n      /**\n       * Get the current poster image\n       */\n      ,\n      get: function get() {\n        if (!this.isVideo) {\n          return null;\n        }\n\n        return this.media.getAttribute('poster') || this.media.getAttribute('data-poster');\n      }\n      /**\n       * Get the current aspect ratio in use\n       */\n\n    }, {\n      key: \"ratio\",\n      get: function get() {\n        if (!this.isVideo) {\n          return null;\n        }\n\n        var ratio = reduceAspectRatio(getAspectRatio.call(this));\n        return is$1.array(ratio) ? ratio.join(':') : ratio;\n      }\n      /**\n       * Set video aspect ratio\n       */\n      ,\n      set: function set(input) {\n        if (!this.isVideo) {\n          this.debug.warn('Aspect ratio can only be set for video');\n          return;\n        }\n\n        if (!is$1.string(input) || !validateRatio(input)) {\n          this.debug.error(\"Invalid aspect ratio specified (\".concat(input, \")\"));\n          return;\n        }\n\n        this.config.ratio = input;\n        setAspectRatio.call(this);\n      }\n      /**\n       * Set the autoplay state\n       * @param {Boolean} input - Whether to autoplay or not\n       */\n\n    }, {\n      key: \"autoplay\",\n      set: function set(input) {\n        var toggle = is$1.boolean(input) ? input : this.config.autoplay;\n        this.config.autoplay = toggle;\n      }\n      /**\n       * Get the current autoplay state\n       */\n      ,\n      get: function get() {\n        return Boolean(this.config.autoplay);\n      }\n    }, {\n      key: \"currentTrack\",\n      set: function set(input) {\n        captions.set.call(this, input, false);\n      }\n      /**\n       * Get the current caption track index (-1 if disabled)\n       */\n      ,\n      get: function get() {\n        var _this$captions = this.captions,\n            toggled = _this$captions.toggled,\n            currentTrack = _this$captions.currentTrack;\n        return toggled ? currentTrack : -1;\n      }\n      /**\n       * Set the wanted language for captions\n       * Since tracks can be added later it won't update the actual caption track until there is a matching track\n       * @param {String} - Two character ISO language code (e.g. EN, FR, PT, etc)\n       */\n\n    }, {\n      key: \"language\",\n      set: function set(input) {\n        captions.setLanguage.call(this, input, false);\n      }\n      /**\n       * Get the current track's language\n       */\n      ,\n      get: function get() {\n        return (captions.getCurrentTrack.call(this) || {}).language;\n      }\n      /**\n       * Toggle picture-in-picture playback on WebKit/MacOS\n       */\n\n    }, {\n      key: \"pip\",\n      set: function set(input) {\n        // Bail if no support\n        if (!support.pip) {\n          return;\n        } // Toggle based on current state if not passed\n\n\n        var toggle = is$1.boolean(input) ? input : !this.pip; // Toggle based on current state\n        // Safari\n\n        if (is$1.function(this.media.webkitSetPresentationMode)) {\n          this.media.webkitSetPresentationMode(toggle ? pip.active : pip.inactive);\n        } // Chrome\n\n\n        if (is$1.function(this.media.requestPictureInPicture)) {\n          if (!this.pip && toggle) {\n            this.media.requestPictureInPicture();\n          } else if (this.pip && !toggle) {\n            document.exitPictureInPicture();\n          }\n        }\n      }\n      /**\n       * Get the current picture-in-picture state\n       */\n      ,\n      get: function get() {\n        if (!support.pip) {\n          return null;\n        } // Safari\n\n\n        if (!is$1.empty(this.media.webkitPresentationMode)) {\n          return this.media.webkitPresentationMode === pip.active;\n        } // Chrome\n\n\n        return this.media === document.pictureInPictureElement;\n      }\n    }], [{\n      key: \"supported\",\n      value: function supported(type, provider, inline) {\n        return support.check(type, provider, inline);\n      }\n      /**\n       * Load an SVG sprite into the page\n       * @param {String} url - URL for the SVG sprite\n       * @param {String} [id] - Unique ID\n       */\n\n    }, {\n      key: \"loadSprite\",\n      value: function loadSprite$1(url, id) {\n        return loadSprite(url, id);\n      }\n      /**\n       * Setup multiple instances\n       * @param {*} selector\n       * @param {Object} options\n       */\n\n    }, {\n      key: \"setup\",\n      value: function setup(selector) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var targets = null;\n\n        if (is$1.string(selector)) {\n          targets = Array.from(document.querySelectorAll(selector));\n        } else if (is$1.nodeList(selector)) {\n          targets = Array.from(selector);\n        } else if (is$1.array(selector)) {\n          targets = selector.filter(is$1.element);\n        }\n\n        if (is$1.empty(targets)) {\n          return null;\n        }\n\n        return targets.map(function (t) {\n          return new WassPlayer(t, options);\n        });\n      }\n    }]);\n\n    return WassPlayer;\n  }();\n\n  WassPlayer.defaults = cloneDeep(defaults$1);\n\n  return WassPlayer;\n\n})));\n","function _classCallCheck(e,t){if(!(e instanceof t))throw new TypeError(\"Cannot call a class as a function\")}function _defineProperties(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,\"value\"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}function _createClass(e,t,n){return t&&_defineProperties(e.prototype,t),n&&_defineProperties(e,n),e}function _defineProperty(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function ownKeys(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function _objectSpread2(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?ownKeys(Object(n),!0).forEach((function(t){_defineProperty(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):ownKeys(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}var defaults={addCSS:!0,thumbWidth:15,watch:!0};function matches(e,t){return function(){return Array.from(document.querySelectorAll(t)).includes(this)}.call(e,t)}function trigger(e,t){if(e&&t){var n=new Event(t,{bubbles:!0});e.dispatchEvent(n)}}var getConstructor=function(e){return null!=e?e.constructor:null},instanceOf=function(e,t){return!!(e&&t&&e instanceof t)},isNullOrUndefined=function(e){return null==e},isObject=function(e){return getConstructor(e)===Object},isNumber=function(e){return getConstructor(e)===Number&&!Number.isNaN(e)},isString=function(e){return getConstructor(e)===String},isBoolean=function(e){return getConstructor(e)===Boolean},isFunction=function(e){return getConstructor(e)===Function},isArray=function(e){return Array.isArray(e)},isNodeList=function(e){return instanceOf(e,NodeList)},isElement=function(e){return instanceOf(e,Element)},isEvent=function(e){return instanceOf(e,Event)},isEmpty=function(e){return isNullOrUndefined(e)||(isString(e)||isArray(e)||isNodeList(e))&&!e.length||isObject(e)&&!Object.keys(e).length},is={nullOrUndefined:isNullOrUndefined,object:isObject,number:isNumber,string:isString,boolean:isBoolean,function:isFunction,array:isArray,nodeList:isNodeList,element:isElement,event:isEvent,empty:isEmpty};function getDecimalPlaces(e){var t=\"\".concat(e).match(/(?:\\.(\\d+))?(?:[eE]([+-]?\\d+))?$/);return t?Math.max(0,(t[1]?t[1].length:0)-(t[2]?+t[2]:0)):0}function round(e,t){if(1>t){var n=getDecimalPlaces(t);return parseFloat(e.toFixed(n))}return Math.round(e/t)*t}var RangeTouch=function(){function e(t,n){_classCallCheck(this,e),is.element(t)?this.element=t:is.string(t)&&(this.element=document.querySelector(t)),is.element(this.element)&&is.empty(this.element.rangeTouch)&&(this.config=_objectSpread2({},defaults,{},n),this.init())}return _createClass(e,[{key:\"init\",value:function(){e.enabled&&(this.config.addCSS&&(this.element.style.userSelect=\"none\",this.element.style.webKitUserSelect=\"none\",this.element.style.touchAction=\"manipulation\"),this.listeners(!0),this.element.rangeTouch=this)}},{key:\"destroy\",value:function(){e.enabled&&(this.config.addCSS&&(this.element.style.userSelect=\"\",this.element.style.webKitUserSelect=\"\",this.element.style.touchAction=\"\"),this.listeners(!1),this.element.rangeTouch=null)}},{key:\"listeners\",value:function(e){var t=this,n=e?\"addEventListener\":\"removeEventListener\";[\"touchstart\",\"touchmove\",\"touchend\"].forEach((function(e){t.element[n](e,(function(e){return t.set(e)}),!1)}))}},{key:\"get\",value:function(t){if(!e.enabled||!is.event(t))return null;var n,r=t.target,i=t.changedTouches[0],o=parseFloat(r.getAttribute(\"min\"))||0,s=parseFloat(r.getAttribute(\"max\"))||100,u=parseFloat(r.getAttribute(\"step\"))||1,c=r.getBoundingClientRect(),a=100/c.width*(this.config.thumbWidth/2)/100;return 0>(n=100/c.width*(i.clientX-c.left))?n=0:100<n&&(n=100),50>n?n-=(100-2*n)*a:50<n&&(n+=2*(n-50)*a),o+round(n/100*(s-o),u)}},{key:\"set\",value:function(t){e.enabled&&is.event(t)&&!t.target.disabled&&(t.preventDefault(),t.target.value=this.get(t),trigger(t.target,\"touchend\"===t.type?\"change\":\"input\"))}}],[{key:\"setup\",value:function(t){var n=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{},r=null;if(is.empty(t)||is.string(t)?r=Array.from(document.querySelectorAll(is.string(t)?t:'input[type=\"range\"]')):is.element(t)?r=[t]:is.nodeList(t)?r=Array.from(t):is.array(t)&&(r=t.filter(is.element)),is.empty(r))return null;var i=_objectSpread2({},defaults,{},n);if(is.string(t)&&i.watch){var o=new MutationObserver((function(n){Array.from(n).forEach((function(n){Array.from(n.addedNodes).forEach((function(n){is.element(n)&&matches(n,t)&&new e(n,i)}))}))}));o.observe(document.body,{childList:!0,subtree:!0})}return r.map((function(t){return new e(t,n)}))}},{key:\"enabled\",get:function(){return\"ontouchstart\"in document.documentElement}}]),e}();export default RangeTouch;","// ==========================================================================\n// Animation utils\n// ==========================================================================\n\nimport is from './is';\n\nexport const transitionEndEvent = (() => {\n  const element = document.createElement('span');\n\n  const events = {\n    WebkitTransition: 'webkitTransitionEnd',\n    MozTransition: 'transitionend',\n    OTransition: 'oTransitionEnd otransitionend',\n    transition: 'transitionend',\n  };\n\n  const type = Object.keys(events).find(event => element.style[event] !== undefined);\n\n  return is.string(type) ? events[type] : false;\n})();\n\n// Force repaint of element\nexport function repaint(element, delay) {\n  setTimeout(() => {\n    try {\n      // eslint-disable-next-line no-param-reassign\n      element.hidden = true;\n\n      // eslint-disable-next-line no-unused-expressions\n      element.offsetHeight;\n\n      // eslint-disable-next-line no-param-reassign\n      element.hidden = false;\n    } catch (e) {\n      // Do nothing\n    }\n  }, delay);\n}\n","// ==========================================================================\n// Type checking utils\n// ==========================================================================\n\nconst getConstructor = input => (input !== null && typeof input !== 'undefined' ? input.constructor : null);\nconst instanceOf = (input, constructor) => Boolean(input && constructor && input instanceof constructor);\nconst isNullOrUndefined = input => input === null || typeof input === 'undefined';\nconst isObject = input => getConstructor(input) === Object;\nconst isNumber = input => getConstructor(input) === Number && !Number.isNaN(input);\nconst isString = input => getConstructor(input) === String;\nconst isBoolean = input => getConstructor(input) === Boolean;\nconst isFunction = input => getConstructor(input) === Function;\nconst isArray = input => Array.isArray(input);\nconst isWeakMap = input => instanceOf(input, WeakMap);\nconst isNodeList = input => instanceOf(input, NodeList);\nconst isElement = input => instanceOf(input, Element);\nconst isTextNode = input => getConstructor(input) === Text;\nconst isEvent = input => instanceOf(input, Event);\nconst isKeyboardEvent = input => instanceOf(input, KeyboardEvent);\nconst isCue = input => instanceOf(input, window.TextTrackCue) || instanceOf(input, window.VTTCue);\nconst isTrack = input => instanceOf(input, TextTrack) || (!isNullOrUndefined(input) && isString(input.kind));\nconst isPromise = input => instanceOf(input, Promise) && isFunction(input.then);\n\nconst isEmpty = input =>\n  isNullOrUndefined(input) ||\n  ((isString(input) || isArray(input) || isNodeList(input)) && !input.length) ||\n  (isObject(input) && !Object.keys(input).length);\n\nconst isUrl = input => {\n  // Accept a URL object\n  if (instanceOf(input, window.URL)) {\n    return true;\n  }\n\n  // Must be string from here\n  if (!isString(input)) {\n    return false;\n  }\n\n  // Add the protocol if required\n  let string = input;\n  if (!input.startsWith('http://') || !input.startsWith('https://')) {\n    string = `http://${input}`;\n  }\n\n  try {\n    return !isEmpty(new URL(string).hostname);\n  } catch (e) {\n    return false;\n  }\n};\n\nexport default {\n  nullOrUndefined: isNullOrUndefined,\n  object: isObject,\n  number: isNumber,\n  string: isString,\n  boolean: isBoolean,\n  function: isFunction,\n  array: isArray,\n  weakMap: isWeakMap,\n  nodeList: isNodeList,\n  element: isElement,\n  textNode: isTextNode,\n  event: isEvent,\n  keyboardEvent: isKeyboardEvent,\n  cue: isCue,\n  track: isTrack,\n  promise: isPromise,\n  url: isUrl,\n  empty: isEmpty,\n};\n","// ==========================================================================\n// Browser sniffing\n// Unfortunately, due to mixed support, UA sniffing is required\n// ==========================================================================\n\nconst browser = {\n  isIE: /* @cc_on!@ */ false || !!document.documentMode,\n  isEdge: window.navigator.userAgent.includes('Edge'),\n  isWebkit: 'WebkitAppearance' in document.documentElement.style && !/Edge/.test(navigator.userAgent),\n  isIPhone: /(iPhone|iPod)/gi.test(navigator.platform),\n  isIos: /(iPad|iPhone|iPod)/gi.test(navigator.platform),\n};\n\nexport default browser;\n","// ==========================================================================\n// Object utils\n// ==========================================================================\n\nimport is from './is';\n\n// Clone nested objects\nexport function cloneDeep(object) {\n  return JSON.parse(JSON.stringify(object));\n}\n\n// Get a nested value in an object\nexport function getDeep(object, path) {\n  return path.split('.').reduce((obj, key) => obj && obj[key], object);\n}\n\n// Deep extend destination object with N more objects\nexport function extend(target = {}, ...sources) {\n  if (!sources.length) {\n    return target;\n  }\n\n  const source = sources.shift();\n\n  if (!is.object(source)) {\n    return target;\n  }\n\n  Object.keys(source).forEach(key => {\n    if (is.object(source[key])) {\n      if (!Object.keys(target).includes(key)) {\n        Object.assign(target, { [key]: {} });\n      }\n\n      extend(target[key], source[key]);\n    } else {\n      Object.assign(target, { [key]: source[key] });\n    }\n  });\n\n  return extend(target, ...sources);\n}\n","// ==========================================================================\n// Element utils\n// ==========================================================================\n\nimport is from './is';\nimport { extend } from './objects';\n\n// Wrap an element\nexport function wrap(elements, wrapper) {\n  // Convert `elements` to an array, if necessary.\n  const targets = elements.length ? elements : [elements];\n\n  // Loops backwards to prevent having to clone the wrapper on the\n  // first element (see `child` below).\n  Array.from(targets)\n    .reverse()\n    .forEach((element, index) => {\n      const child = index > 0 ? wrapper.cloneNode(true) : wrapper;\n      // Cache the current parent and sibling.\n      const parent = element.parentNode;\n      const sibling = element.nextSibling;\n\n      // Wrap the element (is automatically removed from its current\n      // parent).\n      child.appendChild(element);\n\n      // If the element had a sibling, insert the wrapper before\n      // the sibling to maintain the HTML structure; otherwise, just\n      // append it to the parent.\n      if (sibling) {\n        parent.insertBefore(child, sibling);\n      } else {\n        parent.appendChild(child);\n      }\n    });\n}\n\n// Set attributes\nexport function setAttributes(element, attributes) {\n  if (!is.element(element) || is.empty(attributes)) {\n    return;\n  }\n\n  // Assume null and undefined attributes should be left out,\n  // Setting them would otherwise convert them to \"null\" and \"undefined\"\n  Object.entries(attributes)\n    .filter(([, value]) => !is.nullOrUndefined(value))\n    .forEach(([key, value]) => element.setAttribute(key, value));\n}\n\n// Create a DocumentFragment\nexport function createElement(type, attributes, text) {\n  // Create a new <element>\n  const element = document.createElement(type);\n\n  // Set all passed attributes\n  if (is.object(attributes)) {\n    setAttributes(element, attributes);\n  }\n\n  // Add text node\n  if (is.string(text)) {\n    element.innerText = text;\n  }\n\n  // Return built element\n  return element;\n}\n\n// Inaert an element after another\nexport function insertAfter(element, target) {\n  if (!is.element(element) || !is.element(target)) {\n    return;\n  }\n\n  target.parentNode.insertBefore(element, target.nextSibling);\n}\n\n// Insert a DocumentFragment\nexport function insertElement(type, parent, attributes, text) {\n  if (!is.element(parent)) {\n    return;\n  }\n\n  parent.appendChild(createElement(type, attributes, text));\n}\n\n// Remove element(s)\nexport function removeElement(element) {\n  if (is.nodeList(element) || is.array(element)) {\n    Array.from(element).forEach(removeElement);\n    return;\n  }\n\n  if (!is.element(element) || !is.element(element.parentNode)) {\n    return;\n  }\n\n  element.parentNode.removeChild(element);\n}\n\n// Remove all child elements\nexport function emptyElement(element) {\n  if (!is.element(element)) {\n    return;\n  }\n\n  let { length } = element.childNodes;\n\n  while (length > 0) {\n    element.removeChild(element.lastChild);\n    length -= 1;\n  }\n}\n\n// Replace element\nexport function replaceElement(newChild, oldChild) {\n  if (!is.element(oldChild) || !is.element(oldChild.parentNode) || !is.element(newChild)) {\n    return null;\n  }\n\n  oldChild.parentNode.replaceChild(newChild, oldChild);\n\n  return newChild;\n}\n\n// Get an attribute object from a string selector\nexport function getAttributesFromSelector(sel, existingAttributes) {\n  // For example:\n  // '.test' to { class: 'test' }\n  // '#test' to { id: 'test' }\n  // '[data-test=\"test\"]' to { 'data-test': 'test' }\n\n  if (!is.string(sel) || is.empty(sel)) {\n    return {};\n  }\n\n  const attributes = {};\n  const existing = extend({}, existingAttributes);\n\n  sel.split(',').forEach(s => {\n    // Remove whitespace\n    const selector = s.trim();\n    const className = selector.replace('.', '');\n    const stripped = selector.replace(/[[\\]]/g, '');\n    // Get the parts and value\n    const parts = stripped.split('=');\n    const [key] = parts;\n    const value = parts.length > 1 ? parts[1].replace(/[\"']/g, '') : '';\n    // Get the first character\n    const start = selector.charAt(0);\n\n    switch (start) {\n      case '.':\n        // Add to existing classname\n        if (is.string(existing.class)) {\n          attributes.class = `${existing.class} ${className}`;\n        } else {\n          attributes.class = className;\n        }\n        break;\n\n      case '#':\n        // ID selector\n        attributes.id = selector.replace('#', '');\n        break;\n\n      case '[':\n        // Attribute selector\n        attributes[key] = value;\n\n        break;\n\n      default:\n        break;\n    }\n  });\n\n  return extend(existing, attributes);\n}\n\n// Toggle hidden\nexport function toggleHidden(element, hidden) {\n  if (!is.element(element)) {\n    return;\n  }\n\n  let hide = hidden;\n\n  if (!is.boolean(hide)) {\n    hide = !element.hidden;\n  }\n\n  // eslint-disable-next-line no-param-reassign\n  element.hidden = hide;\n}\n\n// Mirror Element.classList.toggle, with IE compatibility for \"force\" argument\nexport function toggleClass(element, className, force) {\n  if (is.nodeList(element)) {\n    return Array.from(element).map(e => toggleClass(e, className, force));\n  }\n\n  if (is.element(element)) {\n    let method = 'toggle';\n    if (typeof force !== 'undefined') {\n      method = force ? 'add' : 'remove';\n    }\n\n    element.classList[method](className);\n    return element.classList.contains(className);\n  }\n\n  return false;\n}\n\n// Has class name\nexport function hasClass(element, className) {\n  return is.element(element) && element.classList.contains(className);\n}\n\n// Element matches selector\nexport function matches(element, selector) {\n  const { prototype } = Element;\n\n  function match() {\n    return Array.from(document.querySelectorAll(selector)).includes(this);\n  }\n\n  const method =\n    prototype.matches ||\n    prototype.webkitMatchesSelector ||\n    prototype.mozMatchesSelector ||\n    prototype.msMatchesSelector ||\n    match;\n\n  return method.call(element, selector);\n}\n\n// Closest ancestor element matching selector (also tests element itself)\nexport function closest(element, selector) {\n  const { prototype } = Element;\n\n  // https://developer.mozilla.org/en-US/docs/Web/API/Element/closest#Polyfill\n  function closestElement() {\n    let el = this;\n\n    do {\n      if (matches.matches(el, selector)) return el;\n      el = el.parentElement || el.parentNode;\n    } while (el !== null && el.nodeType === 1);\n    return null;\n  }\n\n  const method = prototype.closest || closestElement;\n\n  return method.call(element, selector);\n}\n\n// Find all elements\nexport function getElements(selector) {\n  return this.elements.container.querySelectorAll(selector);\n}\n\n// Find a single element\nexport function getElement(selector) {\n  return this.elements.container.querySelector(selector);\n}\n\n// Set focus and tab focus class\nexport function setFocus(element = null, tabFocus = false) {\n  if (!is.element(element)) {\n    return;\n  }\n\n  // Set regular focus\n  element.focus({ preventScroll: true });\n\n  // If we want to mimic keyboard focus via tab\n  if (tabFocus) {\n    toggleClass(element, this.config.classNames.tabFocus);\n  }\n}\n","// ==========================================================================\n// WassPlayer support checks\n// ==========================================================================\n\nimport { transitionEndEvent } from './utils/animation';\nimport browser from './utils/browser';\nimport { createElement } from './utils/elements';\nimport is from './utils/is';\n\n// Default codecs for checking mimetype support\nconst defaultCodecs = {\n  'audio/ogg': 'vorbis',\n  'audio/wav': '1',\n  'video/webm': 'vp8, vorbis',\n  'video/mp4': 'avc1.42E01E, mp4a.40.2',\n  'video/ogg': 'theora',\n};\n\n// Check for feature support\nconst support = {\n  // Basic support\n  audio: 'canPlayType' in document.createElement('audio'),\n  video: 'canPlayType' in document.createElement('video'),\n\n  // Check for support\n  // Basic functionality vs full UI\n  check(type, provider, playsinline) {\n    const canPlayInline = browser.isIPhone && playsinline && support.playsinline;\n    const api = support[type] || provider !== 'html5';\n    const ui = api && support.rangeInput && (type !== 'video' || !browser.isIPhone || canPlayInline);\n\n    return {\n      api,\n      ui,\n    };\n  },\n\n  // Picture-in-picture support\n  // Safari & Chrome only currently\n  pip: (() => {\n    if (browser.isIPhone) {\n      return false;\n    }\n\n    // Safari\n    // https://developer.apple.com/documentation/webkitjs/adding_picture_in_picture_to_your_safari_media_controls\n    if (is.function(createElement('video').webkitSetPresentationMode)) {\n      return true;\n    }\n\n    // Chrome\n    // https://developers.google.com/web/updates/2018/10/watch-video-using-picture-in-picture\n    if (document.pictureInPictureEnabled && !createElement('video').disablePictureInPicture) {\n      return true;\n    }\n\n    return false;\n  })(),\n\n  // Airplay support\n  // Safari only currently\n  airplay: is.function(window.WebKitPlaybackTargetAvailabilityEvent),\n\n  // Inline playback support\n  // https://webkit.org/blog/6784/new-video-policies-for-ios/\n  playsinline: 'playsInline' in document.createElement('video'),\n\n  // Check for mime type support against a player instance\n  // Credits: http://diveintohtml5.info/everything.html\n  // Related: http://www.leanbackplayer.com/test/h5mt.html\n  mime(input) {\n    if (is.empty(input)) {\n      return false;\n    }\n\n    const [mediaType] = input.split('/');\n    let type = input;\n\n    // Verify we're using HTML5 and there's no media type mismatch\n    if (!this.isHTML5 || mediaType !== this.type) {\n      return false;\n    }\n\n    // Add codec if required\n    if (Object.keys(defaultCodecs).includes(type)) {\n      type += `; codecs=\"${defaultCodecs[input]}\"`;\n    }\n\n    try {\n      return Boolean(type && this.media.canPlayType(type).replace(/no/, ''));\n    } catch (e) {\n      return false;\n    }\n  },\n\n  // Check for textTracks support\n  textTracks: 'textTracks' in document.createElement('video'),\n\n  // <input type=\"range\"> Sliders\n  rangeInput: (() => {\n    const range = document.createElement('input');\n    range.type = 'range';\n    return range.type === 'range';\n  })(),\n\n  // Touch\n  // NOTE: Remember a device can be mouse + touch enabled so we check on first touch event\n  touch: 'ontouchstart' in document.documentElement,\n\n  // Detect transitions support\n  transitions: transitionEndEvent !== false,\n\n  // Reduced motion iOS & MacOS setting\n  // https://webkit.org/blog/7551/responsive-design-for-motion/\n  reducedMotion: 'matchMedia' in window && window.matchMedia('(prefers-reduced-motion)').matches,\n};\n\nexport default support;\n","// ==========================================================================\n// Event utils\n// ==========================================================================\n\nimport is from './is';\n\n// Check for passive event listener support\n// https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md\n// https://www.youtube.com/watch?v=NPM6172J22g\nconst supportsPassiveListeners = (() => {\n  // Test via a getter in the options object to see if the passive property is accessed\n  let supported = false;\n  try {\n    const options = Object.defineProperty({}, 'passive', {\n      get() {\n        supported = true;\n        return null;\n      },\n    });\n    window.addEventListener('test', null, options);\n    window.removeEventListener('test', null, options);\n  } catch (e) {\n    // Do nothing\n  }\n\n  return supported;\n})();\n\n// Toggle event listener\nexport function toggleListener(element, event, callback, toggle = false, passive = true, capture = false) {\n  // Bail if no element, event, or callback\n  if (!element || !('addEventListener' in element) || is.empty(event) || !is.function(callback)) {\n    return;\n  }\n\n  // Allow multiple events\n  const events = event.split(' ');\n  // Build options\n  // Default to just the capture boolean for browsers with no passive listener support\n  let options = capture;\n\n  // If passive events listeners are supported\n  if (supportsPassiveListeners) {\n    options = {\n      // Whether the listener can be passive (i.e. default never prevented)\n      passive,\n      // Whether the listener is a capturing listener or not\n      capture,\n    };\n  }\n\n  // If a single node is passed, bind the event listener\n  events.forEach(type => {\n    if (this && this.eventListeners && toggle) {\n      // Cache event listener\n      this.eventListeners.push({ element, type, callback, options });\n    }\n\n    element[toggle ? 'addEventListener' : 'removeEventListener'](type, callback, options);\n  });\n}\n\n// Bind event handler\nexport function on(element, events = '', callback, passive = true, capture = false) {\n  toggleListener.call(this, element, events, callback, true, passive, capture);\n}\n\n// Unbind event handler\nexport function off(element, events = '', callback, passive = true, capture = false) {\n  toggleListener.call(this, element, events, callback, false, passive, capture);\n}\n\n// Bind once-only event handler\nexport function once(element, events = '', callback, passive = true, capture = false) {\n  const onceCallback = (...args) => {\n    off(element, events, onceCallback, passive, capture);\n    callback.apply(this, args);\n  };\n\n  toggleListener.call(this, element, events, onceCallback, true, passive, capture);\n}\n\n// Trigger event\nexport function triggerEvent(element, type = '', bubbles = false, detail = {}) {\n  // Bail if no element\n  if (!is.element(element) || is.empty(type)) {\n    return;\n  }\n\n  // Create and dispatch the event\n  const event = new CustomEvent(type, {\n    bubbles,\n    detail: { ...detail, plyr: this },\n  });\n\n  // Dispatch the event\n  element.dispatchEvent(event);\n}\n\n// Unbind all cached event listeners\nexport function unbindListeners() {\n  if (this && this.eventListeners) {\n    this.eventListeners.forEach(item => {\n      const { element, type, callback, options } = item;\n      element.removeEventListener(type, callback, options);\n    });\n\n    this.eventListeners = [];\n  }\n}\n\n// Run method when / if player is ready\nexport function ready() {\n  return new Promise(resolve =>\n    this.ready ? setTimeout(resolve, 0) : on.call(this, this.elements.container, 'ready', resolve),\n  ).then(() => {});\n}\n","import is from './is';\n/**\n * Silence a Promise-like object.\n * This is useful for avoiding non-harmful, but potentially confusing \"uncaught\n * play promise\" rejection error messages.\n * @param  {Object} value An object that may or may not be `Promise`-like.\n */\nexport function silencePromise(value) {\n  if (is.promise(value)) {\n    value.then(null, () => {});\n  }\n}\n\nexport default { silencePromise };\n","// ==========================================================================\n// Style utils\n// ==========================================================================\n\nimport is from './is';\n\nexport function validateRatio(input) {\n  if (!is.array(input) && (!is.string(input) || !input.includes(':'))) {\n    return false;\n  }\n\n  const ratio = is.array(input) ? input : input.split(':');\n\n  return ratio.map(Number).every(is.number);\n}\n\nexport function reduceAspectRatio(ratio) {\n  if (!is.array(ratio) || !ratio.every(is.number)) {\n    return null;\n  }\n\n  const [width, height] = ratio;\n  const getDivider = (w, h) => (h === 0 ? w : getDivider(h, w % h));\n  const divider = getDivider(width, height);\n\n  return [width / divider, height / divider];\n}\n\nexport function getAspectRatio(input) {\n  const parse = ratio => (validateRatio(ratio) ? ratio.split(':').map(Number) : null);\n  // Try provided ratio\n  let ratio = parse(input);\n\n  // Get from config\n  if (ratio === null) {\n    ratio = parse(this.config.ratio);\n  }\n\n  // Get from embed\n  if (ratio === null && !is.empty(this.embed) && is.array(this.embed.ratio)) {\n    ({ ratio } = this.embed);\n  }\n\n  // Get from HTML5 video\n  if (ratio === null && this.isHTML5) {\n    const { videoWidth, videoHeight } = this.media;\n    ratio = reduceAspectRatio([videoWidth, videoHeight]);\n  }\n\n  return ratio;\n}\n\n// Set aspect ratio for responsive container\nexport function setAspectRatio(input) {\n  if (!this.isVideo) {\n    return {};\n  }\n\n  const { wrapper } = this.elements;\n  const ratio = getAspectRatio.call(this, input);\n  const [w, h] = is.array(ratio) ? ratio : [0, 0];\n  const padding = (100 / w) * h;\n\n  wrapper.style.paddingBottom = `${padding}%`;\n\n  // For Vimeo we have an extra <div> to hide the standard controls and UI\n  if (this.isVimeo && !this.config.vimeo.premium && this.supported.ui) {\n    const height = (100 / this.media.offsetWidth) * parseInt(window.getComputedStyle(this.media).paddingBottom, 10);\n    const offset = (height - padding) / (height / 50);\n\n    this.media.style.transform = `translateY(-${offset}%)`;\n  } else if (this.isHTML5) {\n    wrapper.classList.toggle(this.config.classNames.videoFixedRatio, ratio !== null);\n  }\n\n  return { padding, ratio };\n}\n\nexport default { setAspectRatio };\n","// ==========================================================================\n// WassPlayer HTML5 helpers\n// ==========================================================================\n\nimport support from './support';\nimport { removeElement } from './utils/elements';\nimport { triggerEvent } from './utils/events';\nimport is from './utils/is';\nimport { silencePromise } from './utils/promise';\nimport { setAspectRatio } from './utils/style';\n\nconst html5 = {\n  getSources() {\n    if (!this.isHTML5) {\n      return [];\n    }\n\n    const sources = Array.from(this.media.querySelectorAll('source'));\n\n    // Filter out unsupported sources (if type is specified)\n    return sources.filter(source => {\n      const type = source.getAttribute('type');\n\n      if (is.empty(type)) {\n        return true;\n      }\n\n      return support.mime.call(this, type);\n    });\n  },\n\n  // Get quality levels\n  getQualityOptions() {\n    // Whether we're forcing all options (e.g. for streaming)\n    if (this.config.quality.forced) {\n      return this.config.quality.options;\n    }\n\n    // Get sizes from <source> elements\n    return html5.getSources\n      .call(this)\n      .map(source => Number(source.getAttribute('size')))\n      .filter(Boolean);\n  },\n\n  setup() {\n    if (!this.isHTML5) {\n      return;\n    }\n\n    const player = this;\n\n    // Set speed options from config\n    player.options.speed = player.config.speed.options;\n\n    // Set aspect ratio if fixed\n    if (!is.empty(this.config.ratio)) {\n      setAspectRatio.call(player);\n    }\n\n    // Quality\n    Object.defineProperty(player.media, 'quality', {\n      get() {\n        // Get sources\n        const sources = html5.getSources.call(player);\n        const source = sources.find(s => s.getAttribute('src') === player.source);\n\n        // Return size, if match is found\n        return source && Number(source.getAttribute('size'));\n      },\n      set(input) {\n        if (player.quality === input) {\n          return;\n        }\n\n        // If we're using an an external handler...\n        if (player.config.quality.forced && is.function(player.config.quality.onChange)) {\n          player.config.quality.onChange(input);\n        } else {\n          // Get sources\n          const sources = html5.getSources.call(player);\n          // Get first match for requested size\n          const source = sources.find(s => Number(s.getAttribute('size')) === input);\n\n          // No matching source found\n          if (!source) {\n            return;\n          }\n\n          // Get current state\n          const { currentTime, paused, preload, readyState, playbackRate } = player.media;\n\n          // Set new source\n          player.media.src = source.getAttribute('src');\n\n          // Prevent loading if preload=\"none\" and the current source isn't loaded (#1044)\n          if (preload !== 'none' || readyState) {\n            // Restore time\n            player.once('loadedmetadata', () => {\n              player.speed = playbackRate;\n              player.currentTime = currentTime;\n\n              // Resume playing\n              if (!paused) {\n                silencePromise(player.play());\n              }\n            });\n\n            // Load new source\n            player.media.load();\n          }\n        }\n\n        // Trigger change event\n        triggerEvent.call(player, player.media, 'qualitychange', false, {\n          quality: input,\n        });\n      },\n    });\n  },\n\n  // Cancel current network requests\n  // See https://github.com/sampotts/WassPlayer/issues/174\n  cancelRequests() {\n    if (!this.isHTML5) {\n      return;\n    }\n\n    // Remove child sources\n    removeElement(html5.getSources.call(this));\n\n    // Set blank video src attribute\n    // This is to prevent a MEDIA_ERR_SRC_NOT_SUPPORTED error\n    // Info: http://stackoverflow.com/questions/32231579/how-to-properly-dispose-of-an-html5-video-and-close-socket-or-connection\n    this.media.setAttribute('src', this.config.blankVideo);\n\n    // Load the new empty source\n    // This will cancel existing requests\n    // See https://github.com/sampotts/WassPlayer/issues/174\n    this.media.load();\n\n    // Debugging\n    this.debug.log('Cancelled network requests');\n  },\n};\n\nexport default html5;\n","// ==========================================================================\n// Array utils\n// ==========================================================================\n\nimport is from './is';\n\n// Remove duplicates in an array\nexport function dedupe(array) {\n  if (!is.array(array)) {\n    return array;\n  }\n\n  return array.filter((item, index) => array.indexOf(item) === index);\n}\n\n// Get the closest value in an array\nexport function closest(array, value) {\n  if (!is.array(array) || !array.length) {\n    return null;\n  }\n\n  return array.reduce((prev, curr) => (Math.abs(curr - value) < Math.abs(prev - value) ? curr : prev));\n}\n","// ==========================================================================\n// String utils\n// ==========================================================================\n\nimport is from './is';\n\n// Generate a random ID\nexport function generateId(prefix) {\n  return `${prefix}-${Math.floor(Math.random() * 10000)}`;\n}\n\n// Format string\nexport function format(input, ...args) {\n  if (is.empty(input)) {\n    return input;\n  }\n\n  return input.toString().replace(/{(\\d+)}/g, (match, i) => args[i].toString());\n}\n\n// Get percentage\nexport function getPercentage(current, max) {\n  if (current === 0 || max === 0 || Number.isNaN(current) || Number.isNaN(max)) {\n    return 0;\n  }\n\n  return ((current / max) * 100).toFixed(2);\n}\n\n// Replace all occurances of a string in a string\nexport const replaceAll = (input = '', find = '', replace = '') =>\n  input.replace(new RegExp(find.toString().replace(/([.*+?^=!:${}()|[\\]/\\\\])/g, '\\\\$1'), 'g'), replace.toString());\n\n// Convert to title case\nexport const toTitleCase = (input = '') =>\n  input.toString().replace(/\\w\\S*/g, text => text.charAt(0).toUpperCase() + text.substr(1).toLowerCase());\n\n// Convert string to pascalCase\nexport function toPascalCase(input = '') {\n  let string = input.toString();\n\n  // Convert kebab case\n  string = replaceAll(string, '-', ' ');\n\n  // Convert snake case\n  string = replaceAll(string, '_', ' ');\n\n  // Convert to title case\n  string = toTitleCase(string);\n\n  // Convert to pascal case\n  return replaceAll(string, ' ', '');\n}\n\n// Convert string to pascalCase\nexport function toCamelCase(input = '') {\n  let string = input.toString();\n\n  // Convert to pascal case\n  string = toPascalCase(string);\n\n  // Convert first character to lowercase\n  return string.charAt(0).toLowerCase() + string.slice(1);\n}\n\n// Remove HTML from a string\nexport function stripHTML(source) {\n  const fragment = document.createDocumentFragment();\n  const element = document.createElement('div');\n  fragment.appendChild(element);\n  element.innerHTML = source;\n  return fragment.firstChild.innerText;\n}\n\n// Like outerHTML, but also works for DocumentFragment\nexport function getHTML(element) {\n  const wrapper = document.createElement('div');\n  wrapper.appendChild(element);\n  return wrapper.innerHTML;\n}\n","// ==========================================================================\n// Plyr internationalization\n// ==========================================================================\n\nimport is from './is';\nimport { getDeep } from './objects';\nimport { replaceAll } from './strings';\n\n// Skip i18n for abbreviations and brand names\nconst resources = {\n  pip: 'PIP',\n  airplay: 'AirPlay',\n  html5: 'HTML5',\n  vimeo: 'Vimeo',\n  youtube: 'YouTube',\n};\n\nconst i18n = {\n  get(key = '', config = {}) {\n    if (is.empty(key) || is.empty(config)) {\n      return '';\n    }\n\n    let string = getDeep(config.i18n, key);\n\n    if (is.empty(string)) {\n      if (Object.keys(resources).includes(key)) {\n        return resources[key];\n      }\n\n      return '';\n    }\n\n    const replace = {\n      '{seektime}': config.seekTime,\n      '{title}': config.title,\n    };\n\n    Object.entries(replace).forEach(([k, v]) => {\n      string = replaceAll(string, k, v);\n    });\n\n    return string;\n  },\n};\n\nexport default i18n;\n","// ==========================================================================\n// WassPlayer storage\n// ==========================================================================\n\nimport is from './utils/is';\nimport { extend } from './utils/objects';\n\nclass Storage {\n  constructor(player) {\n    this.enabled = player.config.storage.enabled;\n    this.key = player.config.storage.key;\n  }\n\n  // Check for actual support (see if we can use it)\n  static get supported() {\n    try {\n      if (!('localStorage' in window)) {\n        return false;\n      }\n\n      const test = '___test';\n\n      // Try to use it (it might be disabled, e.g. user is in private mode)\n      // see: https://github.com/sampotts/WassPlayer/issues/131\n      window.localStorage.setItem(test, test);\n      window.localStorage.removeItem(test);\n\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  get(key) {\n    if (!Storage.supported || !this.enabled) {\n      return null;\n    }\n\n    const store = window.localStorage.getItem(this.key);\n\n    if (is.empty(store)) {\n      return null;\n    }\n\n    const json = JSON.parse(store);\n\n    return is.string(key) && key.length ? json[key] : json;\n  }\n\n  set(object) {\n    // Bail if we don't have localStorage support or it's disabled\n    if (!Storage.supported || !this.enabled) {\n      return;\n    }\n\n    // Can only store objectst\n    if (!is.object(object)) {\n      return;\n    }\n\n    // Get current storage\n    let storage = this.get();\n\n    // Default to empty object\n    if (is.empty(storage)) {\n      storage = {};\n    }\n\n    // Update the working copy of the values\n    extend(storage, object);\n\n    // Update storage\n    window.localStorage.setItem(this.key, JSON.stringify(storage));\n  }\n}\n\nexport default Storage;\n","// ==========================================================================\n// Fetch wrapper\n// Using XHR to avoid issues with older browsers\n// ==========================================================================\n\nexport default function fetch(url, responseType = 'text') {\n  return new Promise((resolve, reject) => {\n    try {\n      const request = new XMLHttpRequest();\n\n      // Check for CORS support\n      if (!('withCredentials' in request)) {\n        return;\n      }\n\n      request.addEventListener('load', () => {\n        if (responseType === 'text') {\n          try {\n            resolve(JSON.parse(request.responseText));\n          } catch (e) {\n            resolve(request.responseText);\n          }\n        } else {\n          resolve(request.response);\n        }\n      });\n\n      request.addEventListener('error', () => {\n        throw new Error(request.status);\n      });\n\n      request.open('GET', url, true);\n\n      // Set the required response type\n      request.responseType = responseType;\n\n      request.send();\n    } catch (e) {\n      reject(e);\n    }\n  });\n}\n","// ==========================================================================\n// Sprite loader\n// ==========================================================================\n\nimport Storage from '../storage';\nimport fetch from './fetch';\nimport is from './is';\n\n// Load an external SVG sprite\nexport default function loadSprite(url, id) {\n  if (!is.string(url)) {\n    return;\n  }\n\n  const prefix = 'cache';\n  const hasId = is.string(id);\n  let isCached = false;\n  const exists = () => document.getElementById(id) !== null;\n\n  const update = (container, data) => {\n    // eslint-disable-next-line no-param-reassign\n    container.innerHTML = data;\n\n    // Check again incase of race condition\n    if (hasId && exists()) {\n      return;\n    }\n\n    // Inject the SVG to the body\n    document.body.insertAdjacentElement('afterbegin', container);\n  };\n\n  // Only load once if ID set\n  if (!hasId || !exists()) {\n    const useStorage = Storage.supported;\n    // Create container\n    const container = document.createElement('div');\n    container.setAttribute('hidden', '');\n\n    if (hasId) {\n      container.setAttribute('id', id);\n    }\n\n    // Check in cache\n    if (useStorage) {\n      const cached = window.localStorage.getItem(`${prefix}-${id}`);\n      isCached = cached !== null;\n\n      if (isCached) {\n        const data = JSON.parse(cached);\n        update(container, data.content);\n      }\n    }\n\n    // Get the sprite\n    fetch(url)\n      .then(result => {\n        if (is.empty(result)) {\n          return;\n        }\n\n        if (useStorage) {\n          window.localStorage.setItem(\n            `${prefix}-${id}`,\n            JSON.stringify({\n              content: result,\n            }),\n          );\n        }\n\n        update(container, result);\n      })\n      .catch(() => {});\n  }\n}\n","// ==========================================================================\n// Time utils\n// ==========================================================================\n\nimport is from './is';\n\n// Time helpers\nexport const getHours = value => Math.trunc((value / 60 / 60) % 60, 10);\nexport const getMinutes = value => Math.trunc((value / 60) % 60, 10);\nexport const getSeconds = value => Math.trunc(value % 60, 10);\n\n// Format time to UI friendly string\nexport function formatTime(time = 0, displayHours = false, inverted = false) {\n  // Bail if the value isn't a number\n  if (!is.number(time)) {\n    return formatTime(undefined, displayHours, inverted);\n  }\n\n  // Format time component to add leading zero\n  const format = value => `0${value}`.slice(-2);\n  // Breakdown to hours, mins, secs\n  let hours = getHours(time);\n  const mins = getMinutes(time);\n  const secs = getSeconds(time);\n\n  // Do we need to display hours?\n  if (displayHours || hours > 0) {\n    hours = `${hours}:`;\n  } else {\n    hours = '';\n  }\n\n  // Render\n  return `${inverted && time > 0 ? '-' : ''}${hours}${format(mins)}:${format(secs)}`;\n}\n","// ==========================================================================\n// WassPlayer controls\n// ==========================================================================\n\nimport RangeTouch from 'rangetouch';\n\n// eslint-disable-next-line import/no-cycle\nimport captions from './captions';\nimport html5 from './html5';\nimport support from './support';\nimport { repaint, transitionEndEvent } from './utils/animation';\nimport { dedupe } from './utils/arrays';\nimport browser from './utils/browser';\nimport {\n  createElement,\n  emptyElement,\n  getAttributesFromSelector,\n  getElement,\n  getElements,\n  hasClass,\n  matches,\n  removeElement,\n  setAttributes,\n  setFocus,\n  toggleClass,\n  toggleHidden,\n} from './utils/elements';\nimport { off, on } from './utils/events';\nimport i18n from './utils/i18n';\nimport is from './utils/is';\nimport loadSprite from './utils/load-sprite';\nimport { extend } from './utils/objects';\nimport { getPercentage, replaceAll, toCamelCase, toTitleCase } from './utils/strings';\nimport { formatTime, getHours } from './utils/time';\n\n// TODO: Don't export a massive object - break down and create class\nconst controls = {\n  // Get icon URL\n  getIconUrl() {\n    const url = new URL(this.config.iconUrl, window.location);\n    const cors = url.host !== window.location.host || (browser.isIE && !window.svg4everybody);\n\n    return {\n      url: this.config.iconUrl,\n      cors,\n    };\n  },\n\n  // Find the UI controls\n  findElements() {\n    try {\n      this.elements.controls = getElement.call(this, this.config.selectors.controls.wrapper);\n\n      // Buttons\n      this.elements.buttons = {\n        play: getElements.call(this, this.config.selectors.buttons.play),\n        pause: getElement.call(this, this.config.selectors.buttons.pause),\n        restart: getElement.call(this, this.config.selectors.buttons.restart),\n        rewind: getElement.call(this, this.config.selectors.buttons.rewind),\n        fastForward: getElement.call(this, this.config.selectors.buttons.fastForward),\n        mute: getElement.call(this, this.config.selectors.buttons.mute),\n        pip: getElement.call(this, this.config.selectors.buttons.pip),\n        airplay: getElement.call(this, this.config.selectors.buttons.airplay),\n        settings: getElement.call(this, this.config.selectors.buttons.settings),\n        captions: getElement.call(this, this.config.selectors.buttons.captions),\n        fullscreen: getElement.call(this, this.config.selectors.buttons.fullscreen),\n      };\n\n      // Progress\n      this.elements.progress = getElement.call(this, this.config.selectors.progress);\n\n      // Inputs\n      this.elements.inputs = {\n        seek: getElement.call(this, this.config.selectors.inputs.seek),\n        volume: getElement.call(this, this.config.selectors.inputs.volume),\n      };\n\n      // Display\n      this.elements.display = {\n        buffer: getElement.call(this, this.config.selectors.display.buffer),\n        currentTime: getElement.call(this, this.config.selectors.display.currentTime),\n        duration: getElement.call(this, this.config.selectors.display.duration),\n      };\n\n      // Seek tooltip\n      if (is.element(this.elements.progress)) {\n        this.elements.display.seekTooltip = this.elements.progress.querySelector(`.${this.config.classNames.tooltip}`);\n      }\n\n      return true;\n    } catch (error) {\n      // Log it\n      this.debug.warn('It looks like there is a problem with your custom controls HTML', error);\n\n      // Restore native video controls\n      this.toggleNativeControls(true);\n\n      return false;\n    }\n  },\n\n  // Create <svg> icon\n  createIcon(type, attributes) {\n    const namespace = 'http://www.w3.org/2000/svg';\n    const iconUrl = controls.getIconUrl.call(this);\n    const iconPath = `${!iconUrl.cors ? iconUrl.url : ''}#${this.config.iconPrefix}`;\n    // Create <svg>\n    const icon = document.createElementNS(namespace, 'svg');\n    setAttributes(\n      icon,\n      extend(attributes, {\n        'aria-hidden': 'true',\n        focusable: 'false',\n      }),\n    );\n\n    // Create the <use> to reference sprite\n    const use = document.createElementNS(namespace, 'use');\n    const path = `${iconPath}-${type}`;\n\n    // Set `href` attributes\n    // https://github.com/sampotts/WassPlayer/issues/460\n    // https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/xlink:href\n    if ('href' in use) {\n      use.setAttributeNS('http://www.w3.org/1999/xlink', 'href', path);\n    }\n\n    // Always set the older attribute even though it's \"deprecated\" (it'll be around for ages)\n    use.setAttributeNS('http://www.w3.org/1999/xlink', 'xlink:href', path);\n\n    // Add <use> to <svg>\n    icon.appendChild(use);\n\n    return icon;\n  },\n\n  // Create hidden text label\n  createLabel(key, attr = {}) {\n    const text = i18n.get(key, this.config);\n    const attributes = { ...attr, class: [attr.class, this.config.classNames.hidden].filter(Boolean).join(' ') };\n\n    return createElement('span', attributes, text);\n  },\n\n  // Create a badge\n  createBadge(text) {\n    if (is.empty(text)) {\n      return null;\n    }\n\n    const badge = createElement('span', {\n      class: this.config.classNames.menu.value,\n    });\n\n    badge.appendChild(\n      createElement(\n        'span',\n        {\n          class: this.config.classNames.menu.badge,\n        },\n        text,\n      ),\n    );\n\n    return badge;\n  },\n\n  // Create a <button>\n  createButton(buttonType, attr) {\n    const attributes = extend({}, attr);\n    let type = toCamelCase(buttonType);\n\n    const props = {\n      element: 'button',\n      toggle: false,\n      label: null,\n      icon: null,\n      labelPressed: null,\n      iconPressed: null,\n    };\n\n    ['element', 'icon', 'label'].forEach(key => {\n      if (Object.keys(attributes).includes(key)) {\n        props[key] = attributes[key];\n        delete attributes[key];\n      }\n    });\n\n    // Default to 'button' type to prevent form submission\n    if (props.element === 'button' && !Object.keys(attributes).includes('type')) {\n      attributes.type = 'button';\n    }\n\n    // Set class name\n    if (Object.keys(attributes).includes('class')) {\n      if (!attributes.class.split(' ').some(c => c === this.config.classNames.control)) {\n        extend(attributes, {\n          class: `${attributes.class} ${this.config.classNames.control}`,\n        });\n      }\n    } else {\n      attributes.class = this.config.classNames.control;\n    }\n\n    // Large play button\n    switch (buttonType) {\n      case 'play':\n        props.toggle = true;\n        props.label = 'play';\n        props.labelPressed = 'pause';\n        props.icon = 'play';\n        props.iconPressed = 'pause';\n        break;\n\n      case 'mute':\n        props.toggle = true;\n        props.label = 'mute';\n        props.labelPressed = 'unmute';\n        props.icon = 'volume';\n        props.iconPressed = 'muted';\n        break;\n\n      case 'captions':\n        props.toggle = true;\n        props.label = 'enableCaptions';\n        props.labelPressed = 'disableCaptions';\n        props.icon = 'captions-off';\n        props.iconPressed = 'captions-on';\n        break;\n\n      case 'fullscreen':\n        props.toggle = true;\n        props.label = 'enterFullscreen';\n        props.labelPressed = 'exitFullscreen';\n        props.icon = 'enter-fullscreen';\n        props.iconPressed = 'exit-fullscreen';\n        break;\n\n      case 'play-large':\n        attributes.class += ` ${this.config.classNames.control}--overlaid`;\n        type = 'play';\n        props.label = 'play';\n        props.icon = 'play';\n        break;\n\n      default:\n        if (is.empty(props.label)) {\n          props.label = type;\n        }\n        if (is.empty(props.icon)) {\n          props.icon = buttonType;\n        }\n    }\n\n    const button = createElement(props.element);\n\n    // Setup toggle icon and labels\n    if (props.toggle) {\n      // Icon\n      button.appendChild(\n        controls.createIcon.call(this, props.iconPressed, {\n          class: 'icon--pressed',\n        }),\n      );\n      button.appendChild(\n        controls.createIcon.call(this, props.icon, {\n          class: 'icon--not-pressed',\n        }),\n      );\n\n      // Label/Tooltip\n      button.appendChild(\n        controls.createLabel.call(this, props.labelPressed, {\n          class: 'label--pressed',\n        }),\n      );\n      button.appendChild(\n        controls.createLabel.call(this, props.label, {\n          class: 'label--not-pressed',\n        }),\n      );\n    } else {\n      button.appendChild(controls.createIcon.call(this, props.icon));\n      button.appendChild(controls.createLabel.call(this, props.label));\n    }\n\n    // Merge and set attributes\n    extend(attributes, getAttributesFromSelector(this.config.selectors.buttons[type], attributes));\n    setAttributes(button, attributes);\n\n    // We have multiple play buttons\n    if (type === 'play') {\n      if (!is.array(this.elements.buttons[type])) {\n        this.elements.buttons[type] = [];\n      }\n\n      this.elements.buttons[type].push(button);\n    } else {\n      this.elements.buttons[type] = button;\n    }\n\n    return button;\n  },\n\n  // Create an <input type='range'>\n  createRange(type, attributes) {\n    // Seek input\n    const input = createElement(\n      'input',\n      extend(\n        getAttributesFromSelector(this.config.selectors.inputs[type]),\n        {\n          type: 'range',\n          min: 0,\n          max: 100,\n          step: 0.01,\n          value: 0,\n          autocomplete: 'off',\n          // A11y fixes for https://github.com/sampotts/WassPlayer/issues/905\n          role: 'slider',\n          'aria-label': i18n.get(type, this.config),\n          'aria-valuemin': 0,\n          'aria-valuemax': 100,\n          'aria-valuenow': 0,\n        },\n        attributes,\n      ),\n    );\n\n    this.elements.inputs[type] = input;\n\n    // Set the fill for webkit now\n    controls.updateRangeFill.call(this, input);\n\n    // Improve support on touch devices\n    RangeTouch.setup(input);\n\n    return input;\n  },\n\n  // Create a <progress>\n  createProgress(type, attributes) {\n    const progress = createElement(\n      'progress',\n      extend(\n        getAttributesFromSelector(this.config.selectors.display[type]),\n        {\n          min: 0,\n          max: 100,\n          value: 0,\n          role: 'progressbar',\n          'aria-hidden': true,\n        },\n        attributes,\n      ),\n    );\n\n    // Create the label inside\n    if (type !== 'volume') {\n      progress.appendChild(createElement('span', null, '0'));\n\n      const suffixKey = {\n        played: 'played',\n        buffer: 'buffered',\n      }[type];\n      const suffix = suffixKey ? i18n.get(suffixKey, this.config) : '';\n\n      progress.innerText = `% ${suffix.toLowerCase()}`;\n    }\n\n    this.elements.display[type] = progress;\n\n    return progress;\n  },\n\n  // Create time display\n  createTime(type, attrs) {\n    const attributes = getAttributesFromSelector(this.config.selectors.display[type], attrs);\n\n    const container = createElement(\n      'div',\n      extend(attributes, {\n        class: `${attributes.class ? attributes.class : ''} ${this.config.classNames.display.time} `.trim(),\n        'aria-label': i18n.get(type, this.config),\n      }),\n      '00:00',\n    );\n\n    // Reference for updates\n    this.elements.display[type] = container;\n\n    return container;\n  },\n\n  // Bind keyboard shortcuts for a menu item\n  // We have to bind to keyup otherwise Firefox triggers a click when a keydown event handler shifts focus\n  // https://bugzilla.mozilla.org/show_bug.cgi?id=1220143\n  bindMenuItemShortcuts(menuItem, type) {\n    // Navigate through menus via arrow keys and space\n    on.call(\n      this,\n      menuItem,\n      'keydown keyup',\n      event => {\n        // We only care about space and   \n        if (![32, 38, 39, 40].includes(event.which)) {\n          return;\n        }\n\n        // Prevent play / seek\n        event.preventDefault();\n        event.stopPropagation();\n\n        // We're just here to prevent the keydown bubbling\n        if (event.type === 'keydown') {\n          return;\n        }\n\n        const isRadioButton = matches(menuItem, '[role=\"menuitemradio\"]');\n\n        // Show the respective menu\n        if (!isRadioButton && [32, 39].includes(event.which)) {\n          controls.showMenuPanel.call(this, type, true);\n        } else {\n          let target;\n\n          if (event.which !== 32) {\n            if (event.which === 40 || (isRadioButton && event.which === 39)) {\n              target = menuItem.nextElementSibling;\n\n              if (!is.element(target)) {\n                target = menuItem.parentNode.firstElementChild;\n              }\n            } else {\n              target = menuItem.previousElementSibling;\n\n              if (!is.element(target)) {\n                target = menuItem.parentNode.lastElementChild;\n              }\n            }\n\n            setFocus.call(this, target, true);\n          }\n        }\n      },\n      false,\n    );\n\n    // Enter will fire a `click` event but we still need to manage focus\n    // So we bind to keyup which fires after and set focus here\n    on.call(this, menuItem, 'keyup', event => {\n      if (event.which !== 13) {\n        return;\n      }\n\n      controls.focusFirstMenuItem.call(this, null, true);\n    });\n  },\n\n  // Create a settings menu item\n  createMenuItem({ value, list, type, title, badge = null, checked = false }) {\n    const attributes = getAttributesFromSelector(this.config.selectors.inputs[type]);\n\n    const menuItem = createElement(\n      'button',\n      extend(attributes, {\n        type: 'button',\n        role: 'menuitemradio',\n        class: `${this.config.classNames.control} ${attributes.class ? attributes.class : ''}`.trim(),\n        'aria-checked': checked,\n        value,\n      }),\n    );\n\n    const flex = createElement('span');\n\n    // We have to set as HTML incase of special characters\n    flex.innerHTML = title;\n\n    if (is.element(badge)) {\n      flex.appendChild(badge);\n    }\n\n    menuItem.appendChild(flex);\n\n    // Replicate radio button behaviour\n    Object.defineProperty(menuItem, 'checked', {\n      enumerable: true,\n      get() {\n        return menuItem.getAttribute('aria-checked') === 'true';\n      },\n      set(check) {\n        // Ensure exclusivity\n        if (check) {\n          Array.from(menuItem.parentNode.children)\n            .filter(node => matches(node, '[role=\"menuitemradio\"]'))\n            .forEach(node => node.setAttribute('aria-checked', 'false'));\n        }\n\n        menuItem.setAttribute('aria-checked', check ? 'true' : 'false');\n      },\n    });\n\n    this.listeners.bind(\n      menuItem,\n      'click keyup',\n      event => {\n        if (is.keyboardEvent(event) && event.which !== 32) {\n          return;\n        }\n\n        event.preventDefault();\n        event.stopPropagation();\n\n        menuItem.checked = true;\n\n        switch (type) {\n          case 'language':\n            this.currentTrack = Number(value);\n            break;\n\n          case 'quality':\n            this.quality = value;\n            break;\n\n          case 'speed':\n            this.speed = parseFloat(value);\n            break;\n\n          default:\n            break;\n        }\n\n        controls.showMenuPanel.call(this, 'home', is.keyboardEvent(event));\n      },\n      type,\n      false,\n    );\n\n    controls.bindMenuItemShortcuts.call(this, menuItem, type);\n\n    list.appendChild(menuItem);\n  },\n\n  // Format a time for display\n  formatTime(time = 0, inverted = false) {\n    // Bail if the value isn't a number\n    if (!is.number(time)) {\n      return time;\n    }\n\n    // Always display hours if duration is over an hour\n    const forceHours = getHours(this.duration) > 0;\n\n    return formatTime(time, forceHours, inverted);\n  },\n\n  // Update the displayed time\n  updateTimeDisplay(target = null, time = 0, inverted = false) {\n    // Bail if there's no element to display or the value isn't a number\n    if (!is.element(target) || !is.number(time)) {\n      return;\n    }\n\n    // eslint-disable-next-line no-param-reassign\n    target.innerText = controls.formatTime(time, inverted);\n  },\n\n  // Update volume UI and storage\n  updateVolume() {\n    if (!this.supported.ui) {\n      return;\n    }\n\n    // Update range\n    if (is.element(this.elements.inputs.volume)) {\n      controls.setRange.call(this, this.elements.inputs.volume, this.muted ? 0 : this.volume);\n    }\n\n    // Update mute state\n    if (is.element(this.elements.buttons.mute)) {\n      this.elements.buttons.mute.pressed = this.muted || this.volume === 0;\n    }\n  },\n\n  // Update seek value and lower fill\n  setRange(target, value = 0) {\n    if (!is.element(target)) {\n      return;\n    }\n\n    // eslint-disable-next-line\n    target.value = value;\n\n    // Webkit range fill\n    controls.updateRangeFill.call(this, target);\n  },\n\n  // Update <progress> elements\n  updateProgress(event) {\n    if (!this.supported.ui || !is.event(event)) {\n      return;\n    }\n\n    let value = 0;\n\n    const setProgress = (target, input) => {\n      const val = is.number(input) ? input : 0;\n      const progress = is.element(target) ? target : this.elements.display.buffer;\n\n      // Update value and label\n      if (is.element(progress)) {\n        progress.value = val;\n\n        // Update text label inside\n        const label = progress.getElementsByTagName('span')[0];\n        if (is.element(label)) {\n          label.childNodes[0].nodeValue = val;\n        }\n      }\n    };\n\n    if (event) {\n      switch (event.type) {\n        // Video playing\n        case 'timeupdate':\n        case 'seeking':\n        case 'seeked':\n          value = getPercentage(this.currentTime, this.duration);\n\n          // Set seek range value only if it's a 'natural' time event\n          if (event.type === 'timeupdate') {\n            controls.setRange.call(this, this.elements.inputs.seek, value);\n          }\n\n          break;\n\n        // Check buffer status\n        case 'playing':\n        case 'progress':\n          setProgress(this.elements.display.buffer, this.buffered * 100);\n\n          break;\n\n        default:\n          break;\n      }\n    }\n  },\n\n  // Webkit polyfill for lower fill range\n  updateRangeFill(target) {\n    // Get range from event if event passed\n    const range = is.event(target) ? target.target : target;\n\n    // Needs to be a valid <input type='range'>\n    if (!is.element(range) || range.getAttribute('type') !== 'range') {\n      return;\n    }\n\n    // Set aria values for https://github.com/sampotts/WassPlayer/issues/905\n    if (matches(range, this.config.selectors.inputs.seek)) {\n      range.setAttribute('aria-valuenow', this.currentTime);\n      const currentTime = controls.formatTime(this.currentTime);\n      const duration = controls.formatTime(this.duration);\n      const format = i18n.get('seekLabel', this.config);\n      range.setAttribute(\n        'aria-valuetext',\n        format.replace('{currentTime}', currentTime).replace('{duration}', duration),\n      );\n    } else if (matches(range, this.config.selectors.inputs.volume)) {\n      const percent = range.value * 100;\n      range.setAttribute('aria-valuenow', percent);\n      range.setAttribute('aria-valuetext', `${percent.toFixed(1)}%`);\n    } else {\n      range.setAttribute('aria-valuenow', range.value);\n    }\n\n    // WebKit only\n    if (!browser.isWebkit) {\n      return;\n    }\n\n    // Set CSS custom property\n    range.style.setProperty('--value', `${(range.value / range.max) * 100}%`);\n  },\n\n  // Update hover tooltip for seeking\n  updateSeekTooltip(event) {\n    // Bail if setting not true\n    if (\n      !this.config.tooltips.seek ||\n      !is.element(this.elements.inputs.seek) ||\n      !is.element(this.elements.display.seekTooltip) ||\n      this.duration === 0\n    ) {\n      return;\n    }\n\n    const visible = `${this.config.classNames.tooltip}--visible`;\n    const toggle = show => toggleClass(this.elements.display.seekTooltip, visible, show);\n\n    // Hide on touch\n    if (this.touch) {\n      toggle(false);\n      return;\n    }\n\n    // Determine percentage, if already visible\n    let percent = 0;\n    const clientRect = this.elements.progress.getBoundingClientRect();\n\n    if (is.event(event)) {\n      percent = (100 / clientRect.width) * (event.pageX - clientRect.left);\n    } else if (hasClass(this.elements.display.seekTooltip, visible)) {\n      percent = parseFloat(this.elements.display.seekTooltip.style.left, 10);\n    } else {\n      return;\n    }\n\n    // Set bounds\n    if (percent < 0) {\n      percent = 0;\n    } else if (percent > 100) {\n      percent = 100;\n    }\n\n    // Display the time a click would seek to\n    controls.updateTimeDisplay.call(this, this.elements.display.seekTooltip, (this.duration / 100) * percent);\n\n    // Set position\n    this.elements.display.seekTooltip.style.left = `${percent}%`;\n\n    // Show/hide the tooltip\n    // If the event is a moues in/out and percentage is inside bounds\n    if (is.event(event) && ['mouseenter', 'mouseleave'].includes(event.type)) {\n      toggle(event.type === 'mouseenter');\n    }\n  },\n\n  // Handle time change event\n  timeUpdate(event) {\n    // Only invert if only one time element is displayed and used for both duration and currentTime\n    const invert = !is.element(this.elements.display.duration) && this.config.invertTime;\n\n    // Duration\n    controls.updateTimeDisplay.call(\n      this,\n      this.elements.display.currentTime,\n      invert ? this.duration - this.currentTime : this.currentTime,\n      invert,\n    );\n\n    // Ignore updates while seeking\n    if (event && event.type === 'timeupdate' && this.media.seeking) {\n      return;\n    }\n\n    // Playing progress\n    controls.updateProgress.call(this, event);\n  },\n\n  // Show the duration on metadataloaded or durationchange events\n  durationUpdate() {\n    // Bail if no UI or durationchange event triggered after playing/seek when invertTime is false\n    if (!this.supported.ui || (!this.config.invertTime && this.currentTime)) {\n      return;\n    }\n\n    // If duration is the 2**32 (shaka), Infinity (HLS), DASH-IF (Number.MAX_SAFE_INTEGER || Number.MAX_VALUE) indicating live we hide the currentTime and progressbar.\n    // https://github.com/video-dev/hls.js/blob/5820d29d3c4c8a46e8b75f1e3afa3e68c1a9a2db/src/controller/buffer-controller.js#L415\n    // https://github.com/google/shaka-player/blob/4d889054631f4e1cf0fbd80ddd2b71887c02e232/lib/media/streaming_engine.js#L1062\n    // https://github.com/Dash-Industry-Forum/dash.js/blob/69859f51b969645b234666800d4cb596d89c602d/src/dash/models/DashManifestModel.js#L338\n    if (this.duration >= 2 ** 32) {\n      toggleHidden(this.elements.display.currentTime, true);\n      toggleHidden(this.elements.progress, true);\n      return;\n    }\n\n    // Update ARIA values\n    if (is.element(this.elements.inputs.seek)) {\n      this.elements.inputs.seek.setAttribute('aria-valuemax', this.duration);\n    }\n\n    // If there's a spot to display duration\n    const hasDuration = is.element(this.elements.display.duration);\n\n    // If there's only one time display, display duration there\n    if (!hasDuration && this.config.displayDuration && this.paused) {\n      controls.updateTimeDisplay.call(this, this.elements.display.currentTime, this.duration);\n    }\n\n    // If there's a duration element, update content\n    if (hasDuration) {\n      controls.updateTimeDisplay.call(this, this.elements.display.duration, this.duration);\n    }\n\n    // Update the tooltip (if visible)\n    controls.updateSeekTooltip.call(this);\n  },\n\n  // Hide/show a tab\n  toggleMenuButton(setting, toggle) {\n    toggleHidden(this.elements.settings.buttons[setting], !toggle);\n  },\n\n  // Update the selected setting\n  updateSetting(setting, container, input) {\n    const pane = this.elements.settings.panels[setting];\n    let value = null;\n    let list = container;\n\n    if (setting === 'captions') {\n      value = this.currentTrack;\n    } else {\n      value = !is.empty(input) ? input : this[setting];\n\n      // Get default\n      if (is.empty(value)) {\n        value = this.config[setting].default;\n      }\n\n      // Unsupported value\n      if (!is.empty(this.options[setting]) && !this.options[setting].includes(value)) {\n        this.debug.warn(`Unsupported value of '${value}' for ${setting}`);\n        return;\n      }\n\n      // Disabled value\n      if (!this.config[setting].options.includes(value)) {\n        this.debug.warn(`Disabled value of '${value}' for ${setting}`);\n        return;\n      }\n    }\n\n    // Get the list if we need to\n    if (!is.element(list)) {\n      list = pane && pane.querySelector('[role=\"menu\"]');\n    }\n\n    // If there's no list it means it's not been rendered...\n    if (!is.element(list)) {\n      return;\n    }\n\n    // Update the label\n    const label = this.elements.settings.buttons[setting].querySelector(`.${this.config.classNames.menu.value}`);\n    label.innerHTML = controls.getLabel.call(this, setting, value);\n\n    // Find the radio option and check it\n    const target = list && list.querySelector(`[value=\"${value}\"]`);\n\n    if (is.element(target)) {\n      target.checked = true;\n    }\n  },\n\n  // Translate a value into a nice label\n  getLabel(setting, value) {\n    switch (setting) {\n      case 'speed':\n        return value === 1 ? i18n.get('normal', this.config) : `${value}&times;`;\n\n      case 'quality':\n        if (is.number(value)) {\n          const label = i18n.get(`qualityLabel.${value}`, this.config);\n\n          if (!label.length) {\n            return `${value}p`;\n          }\n\n          return label;\n        }\n\n        return toTitleCase(value);\n\n      case 'captions':\n        return captions.getLabel.call(this);\n\n      default:\n        return null;\n    }\n  },\n\n  // Set the quality menu\n  setQualityMenu(options) {\n    // Menu required\n    if (!is.element(this.elements.settings.panels.quality)) {\n      return;\n    }\n\n    const type = 'quality';\n    const list = this.elements.settings.panels.quality.querySelector('[role=\"menu\"]');\n\n    // Set options if passed and filter based on uniqueness and config\n    if (is.array(options)) {\n      this.options.quality = dedupe(options).filter(quality => this.config.quality.options.includes(quality));\n    }\n\n    // Toggle the pane and tab\n    const toggle = !is.empty(this.options.quality) && this.options.quality.length > 1;\n    controls.toggleMenuButton.call(this, type, toggle);\n\n    // Empty the menu\n    emptyElement(list);\n\n    // Check if we need to toggle the parent\n    controls.checkMenu.call(this);\n\n    // If we're hiding, nothing more to do\n    if (!toggle) {\n      return;\n    }\n\n    // Get the badge HTML for HD, 4K etc\n    const getBadge = quality => {\n      const label = i18n.get(`qualityBadge.${quality}`, this.config);\n\n      if (!label.length) {\n        return null;\n      }\n\n      return controls.createBadge.call(this, label);\n    };\n\n    // Sort options by the config and then render options\n    this.options.quality\n      .sort((a, b) => {\n        const sorting = this.config.quality.options;\n        return sorting.indexOf(a) > sorting.indexOf(b) ? 1 : -1;\n      })\n      .forEach(quality => {\n        controls.createMenuItem.call(this, {\n          value: quality,\n          list,\n          type,\n          title: controls.getLabel.call(this, 'quality', quality),\n          badge: getBadge(quality),\n        });\n      });\n\n    controls.updateSetting.call(this, type, list);\n  },\n\n  // Set the looping options\n  /* setLoopMenu() {\n        // Menu required\n        if (!is.element(this.elements.settings.panels.loop)) {\n            return;\n        }\n\n        const options = ['start', 'end', 'all', 'reset'];\n        const list = this.elements.settings.panels.loop.querySelector('[role=\"menu\"]');\n\n        // Show the pane and tab\n        toggleHidden(this.elements.settings.buttons.loop, false);\n        toggleHidden(this.elements.settings.panels.loop, false);\n\n        // Toggle the pane and tab\n        const toggle = !is.empty(this.loop.options);\n        controls.toggleMenuButton.call(this, 'loop', toggle);\n\n        // Empty the menu\n        emptyElement(list);\n\n        options.forEach(option => {\n            const item = createElement('li');\n\n            const button = createElement(\n                'button',\n                extend(getAttributesFromSelector(this.config.selectors.buttons.loop), {\n                    type: 'button',\n                    class: this.config.classNames.control,\n                    'data-wassPlayer-loop-action': option,\n                }),\n                i18n.get(option, this.config)\n            );\n\n            if (['start', 'end'].includes(option)) {\n                const badge = controls.createBadge.call(this, '00:00');\n                button.appendChild(badge);\n            }\n\n            item.appendChild(button);\n            list.appendChild(item);\n        });\n    }, */\n\n  // Get current selected caption language\n\n  // Set a list of available captions languages\n  setCaptionsMenu() {\n    // Menu required\n    if (!is.element(this.elements.settings.panels.captions)) {\n      return;\n    }\n\n    const type = 'captions';\n    const list = this.elements.settings.panels.captions.querySelector('[role=\"menu\"]');\n    const tracks = captions.getTracks.call(this);\n    const toggle = Boolean(tracks.length);\n\n    // Toggle the pane and tab\n    controls.toggleMenuButton.call(this, type, toggle);\n\n    // Empty the menu\n    emptyElement(list);\n\n    // Check if we need to toggle the parent\n    controls.checkMenu.call(this);\n\n    // If there's no captions, bail\n    if (!toggle) {\n      return;\n    }\n\n    // Generate options data\n    const options = tracks.map((track, value) => ({\n      value,\n      checked: this.captions.toggled && this.currentTrack === value,\n      title: captions.getLabel.call(this, track),\n      badge: track.language && controls.createBadge.call(this, track.language.toUpperCase()),\n      list,\n      type: 'language',\n    }));\n\n    // Add the \"Disabled\" option to turn off captions\n    options.unshift({\n      value: -1,\n      checked: !this.captions.toggled,\n      title: i18n.get('disabled', this.config),\n      list,\n      type: 'language',\n    });\n\n    // Generate options\n    options.forEach(controls.createMenuItem.bind(this));\n\n    controls.updateSetting.call(this, type, list);\n  },\n\n  // Set a list of available captions languages\n  setSpeedMenu() {\n    // Menu required\n    if (!is.element(this.elements.settings.panels.speed)) {\n      return;\n    }\n\n    const type = 'speed';\n    const list = this.elements.settings.panels.speed.querySelector('[role=\"menu\"]');\n\n    // Filter out invalid speeds\n    this.options.speed = this.options.speed.filter(o => o >= this.minimumSpeed && o <= this.maximumSpeed);\n\n    // Toggle the pane and tab\n    const toggle = !is.empty(this.options.speed) && this.options.speed.length > 1;\n    controls.toggleMenuButton.call(this, type, toggle);\n\n    // Empty the menu\n    emptyElement(list);\n\n    // Check if we need to toggle the parent\n    controls.checkMenu.call(this);\n\n    // If we're hiding, nothing more to do\n    if (!toggle) {\n      return;\n    }\n\n    // Create items\n    this.options.speed.forEach(speed => {\n      controls.createMenuItem.call(this, {\n        value: speed,\n        list,\n        type,\n        title: controls.getLabel.call(this, 'speed', speed),\n      });\n    });\n\n    controls.updateSetting.call(this, type, list);\n  },\n\n  // Check if we need to hide/show the settings menu\n  checkMenu() {\n    const { buttons } = this.elements.settings;\n    const visible = !is.empty(buttons) && Object.values(buttons).some(button => !button.hidden);\n\n    toggleHidden(this.elements.settings.menu, !visible);\n  },\n\n  // Focus the first menu item in a given (or visible) menu\n  focusFirstMenuItem(pane, tabFocus = false) {\n    if (this.elements.settings.popup.hidden) {\n      return;\n    }\n\n    let target = pane;\n\n    if (!is.element(target)) {\n      target = Object.values(this.elements.settings.panels).find(p => !p.hidden);\n    }\n\n    const firstItem = target.querySelector('[role^=\"menuitem\"]');\n\n    setFocus.call(this, firstItem, tabFocus);\n  },\n\n  // Show/hide menu\n  toggleMenu(input) {\n    const { popup } = this.elements.settings;\n    const button = this.elements.buttons.settings;\n\n    // Menu and button are required\n    if (!is.element(popup) || !is.element(button)) {\n      return;\n    }\n\n    // True toggle by default\n    const { hidden } = popup;\n    let show = hidden;\n\n    if (is.boolean(input)) {\n      show = input;\n    } else if (is.keyboardEvent(input) && input.which === 27) {\n      show = false;\n    } else if (is.event(input)) {\n      // If WassPlayer is in a shadowDOM, the event target is set to the component, instead of the\n      // Element in the shadowDOM. The path, if available, is complete.\n      const target = is.function(input.composedPath) ? input.composedPath()[0] : input.target;\n      const isMenuItem = popup.contains(target);\n\n      // If the click was inside the menu or if the click\n      // wasn't the button or menu item and we're trying to\n      // show the menu (a doc click shouldn't show the menu)\n      if (isMenuItem || (!isMenuItem && input.target !== button && show)) {\n        return;\n      }\n    }\n\n    // Set button attributes\n    button.setAttribute('aria-expanded', show);\n\n    // Show the actual popup\n    toggleHidden(popup, !show);\n\n    // Add class hook\n    toggleClass(this.elements.container, this.config.classNames.menu.open, show);\n\n    // Focus the first item if key interaction\n    if (show && is.keyboardEvent(input)) {\n      controls.focusFirstMenuItem.call(this, null, true);\n    } else if (!show && !hidden) {\n      // If closing, re-focus the button\n      setFocus.call(this, button, is.keyboardEvent(input));\n    }\n  },\n\n  // Get the natural size of a menu panel\n  getMenuSize(tab) {\n    const clone = tab.cloneNode(true);\n    clone.style.position = 'absolute';\n    clone.style.opacity = 0;\n    clone.removeAttribute('hidden');\n\n    // Append to parent so we get the \"real\" size\n    tab.parentNode.appendChild(clone);\n\n    // Get the sizes before we remove\n    const width = clone.scrollWidth;\n    const height = clone.scrollHeight;\n\n    // Remove from the DOM\n    removeElement(clone);\n\n    return {\n      width,\n      height,\n    };\n  },\n\n  // Show a panel in the menu\n  showMenuPanel(type = '', tabFocus = false) {\n    const target = this.elements.container.querySelector(`#wassPlayer-settings-${this.id}-${type}`);\n\n    // Nothing to show, bail\n    if (!is.element(target)) {\n      return;\n    }\n\n    // Hide all other panels\n    const container = target.parentNode;\n    const current = Array.from(container.children).find(node => !node.hidden);\n\n    // If we can do fancy animations, we'll animate the height/width\n    if (support.transitions && !support.reducedMotion) {\n      // Set the current width as a base\n      container.style.width = `${current.scrollWidth}px`;\n      container.style.height = `${current.scrollHeight}px`;\n\n      // Get potential sizes\n      const size = controls.getMenuSize.call(this, target);\n\n      // Restore auto height/width\n      const restore = event => {\n        // We're only bothered about height and width on the container\n        if (event.target !== container || !['width', 'height'].includes(event.propertyName)) {\n          return;\n        }\n\n        // Revert back to auto\n        container.style.width = '';\n        container.style.height = '';\n\n        // Only listen once\n        off.call(this, container, transitionEndEvent, restore);\n      };\n\n      // Listen for the transition finishing and restore auto height/width\n      on.call(this, container, transitionEndEvent, restore);\n\n      // Set dimensions to target\n      container.style.width = `${size.width}px`;\n      container.style.height = `${size.height}px`;\n    }\n\n    // Set attributes on current tab\n    toggleHidden(current, true);\n\n    // Set attributes on target\n    toggleHidden(target, false);\n\n    // Focus the first item\n    controls.focusFirstMenuItem.call(this, target, tabFocus);\n  },\n\n  // Set the download URL\n  setDownloadUrl() {\n    const button = this.elements.buttons.download;\n\n    // Bail if no button\n    if (!is.element(button)) {\n      return;\n    }\n\n    // Set attribute\n    button.setAttribute('href', this.download);\n  },\n\n  // Build the default HTML\n  create(data) {\n    const {\n      bindMenuItemShortcuts,\n      createButton,\n      createProgress,\n      createRange,\n      createTime,\n      setQualityMenu,\n      setSpeedMenu,\n      showMenuPanel,\n    } = controls;\n    this.elements.controls = null;\n\n    // Larger overlaid play button\n    if (is.array(this.config.controls) && this.config.controls.includes('play-large')) {\n      this.elements.container.appendChild(createButton.call(this, 'play-large'));\n    }\n\n    // Create the container\n    const container = createElement('div', getAttributesFromSelector(this.config.selectors.controls.wrapper));\n    this.elements.controls = container;\n\n    // Default item attributes\n    const defaultAttributes = { class: 'wassPlayer__controls__item' };\n\n    // Loop through controls in order\n    dedupe(is.array(this.config.controls) ? this.config.controls: []).forEach(control => {\n      // Restart button\n      if (control === 'restart') {\n        container.appendChild(createButton.call(this, 'restart', defaultAttributes));\n      }\n\n      // Rewind button\n      if (control === 'rewind') {\n        container.appendChild(createButton.call(this, 'rewind', defaultAttributes));\n      }\n\n      // Play/Pause button\n      if (control === 'play') {\n        container.appendChild(createButton.call(this, 'play', defaultAttributes));\n      }\n\n      // Fast forward button\n      if (control === 'fast-forward') {\n        container.appendChild(createButton.call(this, 'fast-forward', defaultAttributes));\n      }\n\n      // Progress\n      if (control === 'progress') {\n        const progressContainer = createElement('div', {\n          class: `${defaultAttributes.class} wassPlayer__progress__container`,\n        });\n\n        const progress = createElement('div', getAttributesFromSelector(this.config.selectors.progress));\n\n        // Seek range slider\n        progress.appendChild(\n          createRange.call(this, 'seek', {\n            id: `wassPlayer-seek-${data.id}`,\n          }),\n        );\n\n        // Buffer progress\n        progress.appendChild(createProgress.call(this, 'buffer'));\n\n        // Seek tooltip\n        if (this.config.tooltips.seek) {\n          const tooltip = createElement(\n            'span',\n            {\n              class: this.config.classNames.tooltip,\n            },\n            '00:00',\n          );\n\n          progress.appendChild(tooltip);\n          this.elements.display.seekTooltip = tooltip;\n        }\n\n        this.elements.progress = progress;\n        progressContainer.appendChild(this.elements.progress);\n        container.appendChild(progressContainer);\n      }\n\n      // Media current time display\n      if (control === 'current-time') {\n        container.appendChild(createTime.call(this, 'currentTime', defaultAttributes));\n      }\n\n      // Media duration display\n      if (control === 'duration') {\n        container.appendChild(createTime.call(this, 'duration', defaultAttributes));\n      }\n\n      // Volume controls\n      if (control === 'mute' || control === 'volume') {\n        let { volume } = this.elements;\n\n        // Create the volume container if needed\n        if (!is.element(volume) || !container.contains(volume)) {\n          volume = createElement(\n            'div',\n            extend({}, defaultAttributes, {\n              class: `${defaultAttributes.class} wassPlayer__volume`.trim(),\n            }),\n          );\n\n          this.elements.volume = volume;\n\n          container.appendChild(volume);\n        }\n\n        // Toggle mute button\n        if (control === 'mute') {\n          volume.appendChild(createButton.call(this, 'mute'));\n        }\n\n        // Volume range control\n        // Ignored on iOS as it's handled globally\n        // https://developer.apple.com/library/safari/documentation/AudioVideo/Conceptual/Using_HTML5_Audio_Video/Device-SpecificConsiderations/Device-SpecificConsiderations.html\n        if (control === 'volume' && !browser.isIos) {\n          // Set the attributes\n          const attributes = {\n            max: 1,\n            step: 0.05,\n            value: this.config.volume,\n          };\n\n          // Create the volume range slider\n          volume.appendChild(\n            createRange.call(\n              this,\n              'volume',\n              extend(attributes, {\n                id: `wassPlayer-volume-${data.id}`,\n              }),\n            ),\n          );\n        }\n      }\n\n      // Toggle captions button\n      if (control === 'captions') {\n        container.appendChild(createButton.call(this, 'captions', defaultAttributes));\n      }\n\n      // Settings button / menu\n      if (control === 'settings' && !is.empty(this.config.settings)) {\n        const wrapper = createElement(\n          'div',\n          extend({}, defaultAttributes, {\n            class: `${defaultAttributes.class} wassPlayer__menu`.trim(),\n            hidden: '',\n          }),\n        );\n\n        wrapper.appendChild(\n          createButton.call(this, 'settings', {\n            'aria-haspopup': true,\n            'aria-controls': `wassPlayer-settings-${data.id}`,\n            'aria-expanded': false,\n          }),\n        );\n\n        const popup = createElement('div', {\n          class: 'wassPlayer__menu__container',\n          id: `wassPlayer-settings-${data.id}`,\n          hidden: '',\n        });\n\n        const inner = createElement('div');\n\n        const home = createElement('div', {\n          id: `wassPlayer-settings-${data.id}-home`,\n        });\n\n        // Create the menu\n        const menu = createElement('div', {\n          role: 'menu',\n        });\n\n        home.appendChild(menu);\n        inner.appendChild(home);\n        this.elements.settings.panels.home = home;\n\n        // Build the menu items\n        this.config.settings.forEach(type => {\n          const menuItem = createElement(\n            'button',\n            extend(getAttributesFromSelector(this.config.selectors.buttons.settings), {\n              type: 'button',\n              class: `${this.config.classNames.control} ${this.config.classNames.control}--forward`,\n              role: 'menuitem',\n              'aria-haspopup': true,\n              hidden: '',\n            }),\n          );\n\n          // Bind menu shortcuts for keyboard users\n          bindMenuItemShortcuts.call(this, menuItem, type);\n\n          // Show menu on click\n          on.call(this, menuItem, 'click', () => {\n            showMenuPanel.call(this, type, false);\n          });\n\n          const flex = createElement('span', null, i18n.get(type, this.config));\n\n          const value = createElement('span', {\n            class: this.config.classNames.menu.value,\n          });\n\n          // Speed contains HTML entities\n          value.innerHTML = data[type];\n\n          flex.appendChild(value);\n          menuItem.appendChild(flex);\n          menu.appendChild(menuItem);\n\n          // Build the panes\n          const pane = createElement('div', {\n            id: `wassPlayer-settings-${data.id}-${type}`,\n            hidden: '',\n          });\n\n          // Back button\n          const backButton = createElement('button', {\n            type: 'button',\n            class: `${this.config.classNames.control} ${this.config.classNames.control}--back`,\n          });\n\n          // Visible label\n          backButton.appendChild(\n            createElement(\n              'span',\n              {\n                'aria-hidden': true,\n              },\n              i18n.get(type, this.config),\n            ),\n          );\n\n          // Screen reader label\n          backButton.appendChild(\n            createElement(\n              'span',\n              {\n                class: this.config.classNames.hidden,\n              },\n              i18n.get('menuBack', this.config),\n            ),\n          );\n\n          // Go back via keyboard\n          on.call(\n            this,\n            pane,\n            'keydown',\n            event => {\n              // We only care about <-\n              if (event.which !== 37) {\n                return;\n              }\n\n              // Prevent seek\n              event.preventDefault();\n              event.stopPropagation();\n\n              // Show the respective menu\n              showMenuPanel.call(this, 'home', true);\n            },\n            false,\n          );\n\n          // Go back via button click\n          on.call(this, backButton, 'click', () => {\n            showMenuPanel.call(this, 'home', false);\n          });\n\n          // Add to pane\n          pane.appendChild(backButton);\n\n          // Menu\n          pane.appendChild(\n            createElement('div', {\n              role: 'menu',\n            }),\n          );\n\n          inner.appendChild(pane);\n\n          this.elements.settings.buttons[type] = menuItem;\n          this.elements.settings.panels[type] = pane;\n        });\n\n        popup.appendChild(inner);\n        wrapper.appendChild(popup);\n        container.appendChild(wrapper);\n\n        this.elements.settings.popup = popup;\n        this.elements.settings.menu = wrapper;\n      }\n\n      // Picture in picture button\n      if (control === 'pip' && support.pip) {\n        container.appendChild(createButton.call(this, 'pip', defaultAttributes));\n      }\n\n      // Airplay button\n      if (control === 'airplay' && support.airplay) {\n        container.appendChild(createButton.call(this, 'airplay', defaultAttributes));\n      }\n\n      // Download button\n      if (control === 'download') {\n        const attributes = extend({}, defaultAttributes, {\n          element: 'a',\n          href: this.download,\n          target: '_blank',\n        });\n\n        // Set download attribute for HTML5 only\n        if (this.isHTML5) {\n          attributes.download = '';\n        }\n\n        const { download } = this.config.urls;\n\n        if (!is.url(download) && this.isEmbed) {\n          extend(attributes, {\n            icon: `logo-${this.provider}`,\n            label: this.provider,\n          });\n        }\n\n        container.appendChild(createButton.call(this, 'download', attributes));\n      }\n\n      // Toggle fullscreen button\n      if (control === 'fullscreen') {\n        container.appendChild(createButton.call(this, 'fullscreen', defaultAttributes));\n      }\n    });\n\n    // Set available quality levels\n    if (this.isHTML5) {\n      setQualityMenu.call(this, html5.getQualityOptions.call(this));\n    }\n\n    setSpeedMenu.call(this);\n\n    return container;\n  },\n\n  // Insert controls\n  inject() {\n    // Sprite\n    if (this.config.loadSprite) {\n      const icon = controls.getIconUrl.call(this);\n\n      // Only load external sprite using AJAX\n      if (icon.cors) {\n        loadSprite(icon.url, 'sprite-wassPlayer');\n      }\n    }\n\n    // Create a unique ID\n    this.id = Math.floor(Math.random() * 10000);\n\n    // Null by default\n    let container = null;\n    this.elements.controls = null;\n\n    // Set template properties\n    const props = {\n      id: this.id,\n      seektime: this.config.seekTime,\n      title: this.config.title,\n    };\n    let update = true;\n\n    // If function, run it and use output\n    if (is.function(this.config.controls)) {\n      this.config.controls = this.config.controls.call(this, props);\n    }\n\n    // Convert falsy controls to empty array (primarily for empty strings)\n    if (!this.config.controls) {\n      this.config.controls = [];\n    }\n\n    if (is.element(this.config.controls) || is.string(this.config.controls)) {\n      // HTMLElement or Non-empty string passed as the option\n      container = this.config.controls;\n    } else {\n      // Create controls\n      container = controls.create.call(this, {\n        id: this.id,\n        seektime: this.config.seekTime,\n        speed: this.speed,\n        quality: this.quality,\n        captions: captions.getLabel.call(this),\n        // loop: 'None',\n      });\n      update = false;\n    }\n\n    // Replace props with their value\n    const replace = input => {\n      let result = input;\n\n      Object.entries(props).forEach(([key, value]) => {\n        result = replaceAll(result, `{${key}}`, value);\n      });\n\n      return result;\n    };\n\n    // Update markup\n    if (update) {\n      if (is.string(this.config.controls)) {\n        container = replace(container);\n      }\n    }\n\n    // Controls container\n    let target;\n\n    // Inject to custom location\n    if (is.string(this.config.selectors.controls.container)) {\n      target = document.querySelector(this.config.selectors.controls.container);\n    }\n\n    // Inject into the container by default\n    if (!is.element(target)) {\n      target = this.elements.container;\n    }\n\n    // Inject controls HTML (needs to be before captions, hence \"afterbegin\")\n    const insertMethod = is.element(container) ? 'insertAdjacentElement' : 'insertAdjacentHTML';\n    target[insertMethod]('afterbegin', container);\n\n    // Find the elements if need be\n    if (!is.element(this.elements.controls)) {\n      controls.findElements.call(this);\n    }\n\n    // Add pressed property to buttons\n    if (!is.empty(this.elements.buttons)) {\n      const addProperty = button => {\n        const className = this.config.classNames.controlPressed;\n        Object.defineProperty(button, 'pressed', {\n          enumerable: true,\n          get() {\n            return hasClass(button, className);\n          },\n          set(pressed = false) {\n            toggleClass(button, className, pressed);\n          },\n        });\n      };\n\n      // Toggle classname when pressed property is set\n      Object.values(this.elements.buttons)\n        .filter(Boolean)\n        .forEach(button => {\n          if (is.array(button) || is.nodeList(button)) {\n            Array.from(button)\n              .filter(Boolean)\n              .forEach(addProperty);\n          } else {\n            addProperty(button);\n          }\n        });\n    }\n\n    // Edge sometimes doesn't finish the paint so force a repaint\n    if (browser.isEdge) {\n      repaint(target);\n    }\n\n    // Setup tooltips\n    if (this.config.tooltips.controls) {\n      const { classNames, selectors } = this.config;\n      const selector = `${selectors.controls.wrapper} ${selectors.labels} .${classNames.hidden}`;\n      const labels = getElements.call(this, selector);\n\n      Array.from(labels).forEach(label => {\n        toggleClass(label, this.config.classNames.hidden, false);\n        toggleClass(label, this.config.classNames.tooltip, true);\n      });\n    }\n  },\n};\n\nexport default controls;\n","// ==========================================================================\n// URL utils\n// ==========================================================================\n\nimport is from './is';\n\n/**\n * Parse a string to a URL object\n * @param {String} input - the URL to be parsed\n * @param {Boolean} safe - failsafe parsing\n */\nexport function parseUrl(input, safe = true) {\n  let url = input;\n\n  if (safe) {\n    const parser = document.createElement('a');\n    parser.href = url;\n    url = parser.href;\n  }\n\n  try {\n    return new URL(url);\n  } catch (e) {\n    return null;\n  }\n}\n\n// Convert object to URLSearchParams\nexport function buildUrlParams(input) {\n  const params = new URLSearchParams();\n\n  if (is.object(input)) {\n    Object.entries(input).forEach(([key, value]) => {\n      params.set(key, value);\n    });\n  }\n\n  return params;\n}\n","// ==========================================================================\n// WassPlayer Captions\n// ==========================================================================\n\n// eslint-disable-next-line import/no-cycle\nimport controls from './controls';\nimport support from './support';\nimport { dedupe } from './utils/arrays';\nimport browser from './utils/browser';\nimport {\n  createElement,\n  emptyElement,\n  getAttributesFromSelector,\n  insertAfter,\n  removeElement,\n  toggleClass,\n} from './utils/elements';\nimport { on, triggerEvent } from './utils/events';\nimport fetch from './utils/fetch';\nimport i18n from './utils/i18n';\nimport is from './utils/is';\nimport { getHTML } from './utils/strings';\nimport { parseUrl } from './utils/urls';\n\nconst captions = {\n  // Setup captions\n  setup() {\n    // Requires UI support\n    if (!this.supported.ui) {\n      return;\n    }\n\n    // Only Vimeo and HTML5 video supported at this point\n    if (!this.isVideo || this.isYouTube || (this.isHTML5 && !support.textTracks)) {\n      // Clear menu and hide\n      if (\n        is.array(this.config.controls) &&\n        this.config.controls.includes('settings') &&\n        this.config.settings.includes('captions')\n      ) {\n        controls.setCaptionsMenu.call(this);\n      }\n\n      return;\n    }\n\n    // Inject the container\n    if (!is.element(this.elements.captions)) {\n      this.elements.captions = createElement('div', getAttributesFromSelector(this.config.selectors.captions));\n\n      insertAfter(this.elements.captions, this.elements.wrapper);\n    }\n\n    // Fix IE captions if CORS is used\n    // Fetch captions and inject as blobs instead (data URIs not supported!)\n    if (browser.isIE && window.URL) {\n      const elements = this.media.querySelectorAll('track');\n\n      Array.from(elements).forEach(track => {\n        const src = track.getAttribute('src');\n        const url = parseUrl(src);\n\n        if (\n          url !== null &&\n          url.hostname !== window.location.href.hostname &&\n          ['http:', 'https:'].includes(url.protocol)\n        ) {\n          fetch(src, 'blob')\n            .then(blob => {\n              track.setAttribute('src', window.URL.createObjectURL(blob));\n            })\n            .catch(() => {\n              removeElement(track);\n            });\n        }\n      });\n    }\n\n    const browserLanguages = navigator.languages || [navigator.language || navigator.userLanguage || 'en'];\n    const languages = dedupe(browserLanguages.map(language => language.split('-')[0]));\n    let language = (this.storage.get('language') || this.config.captions.language || 'auto').toLowerCase();\n\n    // Use first browser language when language is 'auto'\n    if (language === 'auto') {\n      [language] = languages;\n    }\n\n    let active = this.storage.get('captions');\n    if (!is.boolean(active)) {\n      ({ active } = this.config.captions);\n    }\n\n    Object.assign(this.captions, {\n      toggled: false,\n      active,\n      language,\n      languages,\n    });\n\n    // Watch changes to textTracks and update captions menu\n    if (this.isHTML5) {\n      const trackEvents = this.config.captions.update ? 'addtrack removetrack' : 'removetrack';\n      on.call(this, this.media.textTracks, trackEvents, captions.update.bind(this));\n    }\n\n    // Update available languages in list next tick (the event must not be triggered before the listeners)\n    setTimeout(captions.update.bind(this), 0);\n  },\n\n  // Update available language options in settings based on tracks\n  update() {\n    const tracks = captions.getTracks.call(this, true);\n    // Get the wanted language\n    const { active, language, meta, currentTrackNode } = this.captions;\n    const languageExists = Boolean(tracks.find(track => track.language === language));\n\n    // Handle tracks (add event listener and \"pseudo\"-default)\n    if (this.isHTML5 && this.isVideo) {\n      tracks\n        .filter(track => !meta.get(track))\n        .forEach(track => {\n          this.debug.log('Track added', track);\n\n          // Attempt to store if the original dom element was \"default\"\n          meta.set(track, {\n            default: track.mode === 'showing',\n          });\n\n          // eslint-disable-next-line no-param-reassign\n          if (track.mode === 'showing') {\n            // eslint-disable-next-line no-param-reassign\n            track.mode = 'hidden';\n          }\n\n          // Add event listener for cue changes\n          on.call(this, track, 'cuechange', () => captions.updateCues.call(this));\n        });\n    }\n\n    // Update language first time it matches, or if the previous matching track was removed\n    if ((languageExists && this.language !== language) || !tracks.includes(currentTrackNode)) {\n      captions.setLanguage.call(this, language);\n      captions.toggle.call(this, active && languageExists);\n    }\n\n    // Enable or disable captions based on track length\n    toggleClass(this.elements.container, this.config.classNames.captions.enabled, !is.empty(tracks));\n\n    // Update available languages in list\n    if (\n      is.array(this.config.controls) &&\n      this.config.controls.includes('settings') &&\n      this.config.settings.includes('captions')\n    ) {\n      controls.setCaptionsMenu.call(this);\n    }\n  },\n\n  // Toggle captions display\n  // Used internally for the toggleCaptions method, with the passive option forced to false\n  toggle(input, passive = true) {\n    // If there's no full support\n    if (!this.supported.ui) {\n      return;\n    }\n\n    const { toggled } = this.captions; // Current state\n    const activeClass = this.config.classNames.captions.active;\n    // Get the next state\n    // If the method is called without parameter, toggle based on current value\n    const active = is.nullOrUndefined(input) ? !toggled : input;\n\n    // Update state and trigger event\n    if (active !== toggled) {\n      // When passive, don't override user preferences\n      if (!passive) {\n        this.captions.active = active;\n        this.storage.set({ captions: active });\n      }\n\n      // Force language if the call isn't passive and there is no matching language to toggle to\n      if (!this.language && active && !passive) {\n        const tracks = captions.getTracks.call(this);\n        const track = captions.findTrack.call(this, [this.captions.language, ...this.captions.languages], true);\n\n        // Override user preferences to avoid switching languages if a matching track is added\n        this.captions.language = track.language;\n\n        // Set caption, but don't store in localStorage as user preference\n        captions.set.call(this, tracks.indexOf(track));\n        return;\n      }\n\n      // Toggle button if it's enabled\n      if (this.elements.buttons.captions) {\n        this.elements.buttons.captions.pressed = active;\n      }\n\n      // Add class hook\n      toggleClass(this.elements.container, activeClass, active);\n\n      this.captions.toggled = active;\n\n      // Update settings menu\n      controls.updateSetting.call(this, 'captions');\n\n      // Trigger event (not used internally)\n      triggerEvent.call(this, this.media, active ? 'captionsenabled' : 'captionsdisabled');\n    }\n\n    // on the active track - forcing the browser to download it\n    setTimeout(() => {\n      if (active && this.captions.toggled) {\n        this.captions.currentTrackNode.mode = 'hidden';\n      }\n    });\n  },\n\n  // Set captions by track index\n  // Used internally for the currentTrack setter with the passive option forced to false\n  set(index, passive = true) {\n    const tracks = captions.getTracks.call(this);\n\n    // Disable captions if setting to -1\n    if (index === -1) {\n      captions.toggle.call(this, false, passive);\n      return;\n    }\n\n    if (!is.number(index)) {\n      this.debug.warn('Invalid caption argument', index);\n      return;\n    }\n\n    if (!(index in tracks)) {\n      this.debug.warn('Track not found', index);\n      return;\n    }\n\n    if (this.captions.currentTrack !== index) {\n      this.captions.currentTrack = index;\n      const track = tracks[index];\n      const { language } = track || {};\n\n      // Store reference to node for invalidation on remove\n      this.captions.currentTrackNode = track;\n\n      // Update settings menu\n      controls.updateSetting.call(this, 'captions');\n\n      // When passive, don't override user preferences\n      if (!passive) {\n        this.captions.language = language;\n        this.storage.set({ language });\n      }\n\n      // Handle Vimeo captions\n      if (this.isVimeo) {\n        this.embed.enableTextTrack(language);\n      }\n\n      // Trigger event\n      triggerEvent.call(this, this.media, 'languagechange');\n    }\n\n    // Show captions\n    captions.toggle.call(this, true, passive);\n\n    if (this.isHTML5 && this.isVideo) {\n      // If we change the active track while a cue is already displayed we need to update it\n      captions.updateCues.call(this);\n    }\n  },\n\n  // Set captions by language\n  // Used internally for the language setter with the passive option forced to false\n  setLanguage(input, passive = true) {\n    if (!is.string(input)) {\n      this.debug.warn('Invalid language argument', input);\n      return;\n    }\n    // Normalize\n    const language = input.toLowerCase();\n    this.captions.language = language;\n\n    // Set currentTrack\n    const tracks = captions.getTracks.call(this);\n    const track = captions.findTrack.call(this, [language]);\n    captions.set.call(this, tracks.indexOf(track), passive);\n  },\n\n  // Get current valid caption tracks\n  // If update is false it will also ignore tracks without metadata\n  // This is used to \"freeze\" the language options when captions.update is false\n  getTracks(update = false) {\n    // Handle media or textTracks missing or null\n    const tracks = Array.from((this.media || {}).textTracks || []);\n    // For HTML5, use cache instead of current tracks when it exists (if captions.update is false)\n    // Filter out removed tracks and tracks that aren't captions/subtitles (for example metadata)\n    return tracks\n      .filter(track => !this.isHTML5 || update || this.captions.meta.has(track))\n      .filter(track => ['captions', 'subtitles'].includes(track.kind));\n  },\n\n  // Match tracks based on languages and get the first\n  findTrack(languages, force = false) {\n    const tracks = captions.getTracks.call(this);\n    const sortIsDefault = track => Number((this.captions.meta.get(track) || {}).default);\n    const sorted = Array.from(tracks).sort((a, b) => sortIsDefault(b) - sortIsDefault(a));\n    let track;\n\n    languages.every(language => {\n      track = sorted.find(t => t.language === language);\n      return !track; // Break iteration if there is a match\n    });\n\n    // If no match is found but is required, get first\n    return track || (force ? sorted[0] : undefined);\n  },\n\n  // Get the current track\n  getCurrentTrack() {\n    return captions.getTracks.call(this)[this.currentTrack];\n  },\n\n  // Get UI label for track\n  getLabel(track) {\n    let currentTrack = track;\n\n    if (!is.track(currentTrack) && support.textTracks && this.captions.toggled) {\n      currentTrack = captions.getCurrentTrack.call(this);\n    }\n\n    if (is.track(currentTrack)) {\n      if (!is.empty(currentTrack.label)) {\n        return currentTrack.label;\n      }\n\n      if (!is.empty(currentTrack.language)) {\n        return track.language.toUpperCase();\n      }\n\n      return i18n.get('enabled', this.config);\n    }\n\n    return i18n.get('disabled', this.config);\n  },\n\n  // Update captions using current track's active cues\n  // Also optional array argument in case there isn't any track (ex: vimeo)\n  updateCues(input) {\n    // Requires UI\n    if (!this.supported.ui) {\n      return;\n    }\n\n    if (!is.element(this.elements.captions)) {\n      this.debug.warn('No captions element to render to');\n      return;\n    }\n\n    // Only accept array or empty input\n    if (!is.nullOrUndefined(input) && !Array.isArray(input)) {\n      this.debug.warn('updateCues: Invalid input', input);\n      return;\n    }\n\n    let cues = input;\n\n    // Get cues from track\n    if (!cues) {\n      const track = captions.getCurrentTrack.call(this);\n\n      cues = Array.from((track || {}).activeCues || [])\n        .map(cue => cue.getCueAsHTML())\n        .map(getHTML);\n    }\n\n    // Set new caption text\n    const content = cues.map(cueText => cueText.trim()).join('\\n');\n    const changed = content !== this.elements.captions.innerHTML;\n\n    if (changed) {\n      // Empty the container and create a new child element\n      emptyElement(this.elements.captions);\n      const caption = createElement('span', getAttributesFromSelector(this.config.selectors.caption));\n      caption.innerHTML = content;\n      this.elements.captions.appendChild(caption);\n\n      // Trigger event\n      triggerEvent.call(this, this.media, 'cuechange');\n    }\n  },\n};\n\nexport default captions;\n","// ==========================================================================\n// WassPlayer default config file\n// ==========================================================================\n\nconst defaults = {\n  // Disable\n  enabled: true,\n\n  // Custom media title\n  title: '',\n\n  // Logging to console\n  debug: false,\n\n  // Auto play (if supported)\n  autoplay: false,\n\n  // Only allow one media playing at once\n  autopause: true,\n\n  // Allow inline playback on iOS\n  playsinline: true,\n\n  // Default time to skip when rewind/fast forward\n  seekTime: 10,\n\n  // Default volume\n  volume: 1,\n  muted: false,\n\n  // Pass a custom duration\n  duration: null,\n\n  // Display the media duration on load in the current time position\n  // If you have opted to display both duration and currentTime, this is ignored\n  displayDuration: true,\n\n  // Invert the current time to be a countdown\n  invertTime: true,\n\n  // Clicking the currentTime inverts it's value to show time left rather than elapsed\n  toggleInvert: true,\n\n  // Force an aspect ratio\n  // The format must be `'w:h'` (e.g. `'16:9'`)\n  ratio: null,\n\n  // Click video container to play/pause\n  clickToPlay: true,\n\n  // Auto hide the controls\n  hideControls: true,\n\n  // Reset to start when playback ended\n  resetOnEnd: false,\n\n  // Disable the standard context menu\n  disableContextMenu: true,\n\n  // Sprite (for icons)\n  loadSprite: true,\n  iconPrefix: 'wassPlayer',\n  iconUrl: 'http://code4stack.com/wassplayer.svg',\n\n  // Quality default\n  quality: {\n    default: 576,\n    // The options to display in the UI, if available for the source media\n    options: [4320, 2880, 2160, 1440, 1080, 720, 576, 480, 360, 240],\n    forced: false,\n    onChange: null,\n  },\n\n  // Set loops\n  loop: {\n    active: false,\n    // start: null,\n    // end: null,\n  },\n\n  // Speed default and options to display\n  speed: {\n    selected: 1,\n    // The options to display in the UI, if available for the source media\n    options: [0.5, 0.75, 1, 1.25, 1.5, 1.75, 2, 4],\n  },\n\n  // Keyboard shortcut settings\n  keyboard: {\n    focused: true,\n    global: false,\n  },\n\n  // Display tooltips\n  tooltips: {\n    controls: false,\n    seek: true,\n  },\n\n  // Captions settings\n  captions: {\n    active: false,\n    language: 'auto',\n    // Listen to new tracks added after Plyr is initialized.\n    // This is needed for streaming captions, but may result in unselectable options\n    update: false,\n  },\n\n  // Fullscreen settings\n  fullscreen: {\n    enabled: true, // Allow fullscreen?\n    fallback: true, // Fallback using full viewport/window\n    iosNative: false, // Use the native fullscreen in iOS (disables custom controls)\n    // Selector for the fullscreen container so contextual / non-player content can remain visible in fullscreen mode\n    // Non-ancestors of the player element will be ignored\n    // container: null, // defaults to the player element\n  },\n\n  // Local storage\n  storage: {\n    enabled: true,\n    key: 'wassPlayer',\n  },\n\n  // Default controls\n  controls: [\n    'play-large',\n    // 'restart',\n    'rewind',\n    'play',\n    'fast-forward',\n    'progress',\n    'current-time',\n    // 'duration',\n    'mute',\n    'volume',\n    'captions',\n    'settings',\n    'pip',\n    'airplay',\n    // 'download',\n    'fullscreen',\n  ],\n  settings: ['captions', 'quality', 'speed'],\n\n  // Localisation\n  i18n: {\n    restart: 'Restart',\n    rewind: 'Rewind {seektime}s',\n    play: 'Play',\n    pause: 'Pause',\n    fastForward: 'Forward {seektime}s',\n    seek: 'Seek',\n    seekLabel: '{currentTime} of {duration}',\n    played: 'Played',\n    buffered: 'Buffered',\n    currentTime: 'Current time',\n    duration: 'Duration',\n    volume: 'Volume',\n    mute: 'Mute',\n    unmute: 'Unmute',\n    enableCaptions: 'Enable captions',\n    disableCaptions: 'Disable captions',\n    download: 'Download',\n    enterFullscreen: 'Enter fullscreen',\n    exitFullscreen: 'Exit fullscreen',\n    frameTitle: 'Player for {title}',\n    captions: 'Captions',\n    settings: 'Settings',\n    pip: 'PIP',\n    menuBack: 'Go back to previous menu',\n    speed: 'Speed',\n    normal: 'Normal',\n    quality: 'Quality',\n    loop: 'Loop',\n    start: 'Start',\n    end: 'End',\n    all: 'All',\n    reset: 'Reset',\n    disabled: 'Disabled',\n    enabled: 'Enabled',\n    advertisement: 'Ad',\n    qualityBadge: {\n      2160: '4K',\n      1440: 'HD',\n      1080: 'HD',\n      720: 'HD',\n      576: 'SD',\n      480: 'SD',\n    },\n  },\n\n  // Custom control listeners\n  listeners: {\n    seek: null,\n    play: null,\n    pause: null,\n    restart: null,\n    rewind: null,\n    fastForward: null,\n    mute: null,\n    volume: null,\n    captions: null,\n    download: null,\n    fullscreen: null,\n    pip: null,\n    airplay: null,\n    speed: null,\n    quality: null,\n    loop: null,\n    language: null,\n  },\n\n  // Events to watch and bubble\n  events: [\n    // Events to watch on HTML5 media elements and bubble\n    // https://developer.mozilla.org/en/docs/Web/Guide/Events/Media_events\n    'ended',\n    'progress',\n    'stalled',\n    'playing',\n    'waiting',\n    'canplay',\n    'canplaythrough',\n    'loadstart',\n    'loadeddata',\n    'loadedmetadata',\n    'timeupdate',\n    'volumechange',\n    'play',\n    'pause',\n    'error',\n    'seeking',\n    'seeked',\n    'emptied',\n    'ratechange',\n    'cuechange',\n\n    // Custom events\n    'download',\n    'enterfullscreen',\n    'exitfullscreen',\n    'captionsenabled',\n    'captionsdisabled',\n    'languagechange',\n    'controlshidden',\n    'controlsshown',\n    'ready',\n\n    // Quality\n    'qualitychange',\n  ],\n\n  // Selectors\n  // Change these to match your template if using custom HTML\n  selectors: {\n    editable: 'input, textarea, select, [contenteditable]',\n    container: '.wassPlayer',\n    controls: {\n      container: null,\n      wrapper: '.wassPlayer__controls',\n    },\n    labels: '[data-wassPlayer]',\n    buttons: {\n      play: '[data-wassPlayer=\"play\"]',\n      pause: '[data-wassPlayer=\"pause\"]',\n      restart: '[data-wassPlayer=\"restart\"]',\n      rewind: '[data-wassPlayer=\"rewind\"]',\n      fastForward: '[data-wassPlayer=\"fast-forward\"]',\n      mute: '[data-wassPlayer=\"mute\"]',\n      captions: '[data-wassPlayer=\"captions\"]',\n      download: '[data-wassPlayer=\"download\"]',\n      fullscreen: '[data-wassPlayer=\"fullscreen\"]',\n      pip: '[data-wassPlayer=\"pip\"]',\n      airplay: '[data-wassPlayer=\"airplay\"]',\n      settings: '[data-wassPlayer=\"settings\"]',\n      loop: '[data-wassPlayer=\"loop\"]',\n    },\n    inputs: {\n      seek: '[data-wassPlayer=\"seek\"]',\n      volume: '[data-wassPlayer=\"volume\"]',\n      speed: '[data-wassPlayer=\"speed\"]',\n      language: '[data-wassPlayer=\"language\"]',\n      quality: '[data-wassPlayer=\"quality\"]',\n    },\n    display: {\n      currentTime: '.wassPlayer__time--current',\n      duration: '.wassPlayer__time--duration',\n      buffer: '.wassPlayer__progress__buffer',\n      loop: '.wassPlayer__progress__loop', // Used later\n      volume: '.wassPlayer__volume--display',\n    },\n    progress: '.wassPlayer__progress',\n    captions: '.wassPlayer__captions',\n    caption: '.wassPlayer__caption',\n  },\n\n  // Class hooks added to the player in different states\n  classNames: {\n    type: 'wassPlayer--{0}',\n    provider: 'wassPlayer--{0}',\n    video: 'wassPlayer__video-wrapper',\n    embed: 'wassPlayer__video-embed',\n    videoFixedRatio: 'wassPlayer__video-wrapper--fixed-ratio',\n    embedContainer: 'wassPlayer__video-embed__container',\n    poster: 'wassPlayer__poster',\n    posterEnabled: 'wassPlayer__poster-enabled',\n    control: 'wassPlayer__control',\n    controlPressed: 'wassPlayer__control--pressed',\n    playing: 'wassPlayer--playing',\n    paused: 'wassPlayer--paused',\n    stopped: 'wassPlayer--stopped',\n    loading: 'wassPlayer--loading',\n    hover: 'wassPlayer--hover',\n    tooltip: 'wassPlayer__tooltip',\n    cues: 'wassPlayer__cues',\n    hidden: 'wassPlayer__sr-only',\n    hideControls: 'wassPlayer--hide-controls',\n    isIos: 'wassPlayer--is-ios',\n    isTouch: 'wassPlayer--is-touch',\n    uiSupported: 'wassPlayer--full-ui',\n    noTransition: 'wassPlayer--no-transition',\n    display: {\n      time: 'wassPlayer__time',\n    },\n    menu: {\n      value: 'wassPlayer__menu__value',\n      badge: 'wassPlayer__badge',\n      open: 'wassPlayer--menu-open',\n    },\n    captions: {\n      enabled: 'wassPlayer--captions-enabled',\n      active: 'wassPlayer--captions-active',\n    },\n    fullscreen: {\n      enabled: 'wassPlayer--fullscreen-enabled',\n      fallback: 'wassPlayer--fullscreen-fallback',\n    },\n    pip: {\n      supported: 'wassPlayer--pip-supported',\n      active: 'wassPlayer--pip-active',\n    },\n    airplay: {\n      supported: 'wassPlayer--airplay-supported',\n      active: 'wassPlayer--airplay-active',\n    },\n    tabFocus: 'wassPlayer__tab-focus',\n    previewThumbnails: {\n      // Tooltip thumbs\n      thumbContainer: 'wassPlayer__preview-thumb',\n      thumbContainerShown: 'wassPlayer__preview-thumb--is-shown',\n      imageContainer: 'wassPlayer__preview-thumb__image-container',\n      timeContainer: 'wassPlayer__preview-thumb__time-container',\n      // Scrubbing\n      scrubbingContainer: 'wassPlayer__preview-scrubbing',\n      scrubbingContainerShown: 'wassPlayer__preview-scrubbing--is-shown',\n    },\n  },\n\n  // Embed attributes\n  attributes: {\n    embed: {\n      provider: 'data-wassPlayer-provider',\n      id: 'data-wassPlayer-embed-id',\n    },\n  },\n\n  // Preview Thumbnails plugin\n  previewThumbnails: {\n    enabled: false,\n    src: '',\n  },\n};\n\nexport default defaults;\n","// ==========================================================================\n// WassPlayer states\n// ==========================================================================\n\nexport const pip = {\n  active: 'picture-in-picture',\n  inactive: 'inline',\n};\n\nexport default { pip };\n","// ==========================================================================\n// WassPlayer supported types and providers\n// ==========================================================================\n\nexport const providers = {\n  html5: 'html5',\n};\n\nexport const types = {\n  video: 'video',\n};\n\n/**\n * Get provider by URL\n * @param {String} url\n */\nexport function getProviderByUrl() {\n  return null;\n}\n\nexport default { providers, types };\n","// ==========================================================================\n// Console wrapper\n// ==========================================================================\n\nconst noop = () => {};\n\nexport default class Console {\n  constructor(enabled = false) {\n    this.enabled = window.console && enabled;\n\n    if (this.enabled) {\n      this.log('Debugging enabled');\n    }\n  }\n\n  get log() {\n    // eslint-disable-next-line no-console\n    return this.enabled ? Function.prototype.bind.call(console.log, console) : noop;\n  }\n\n  get warn() {\n    // eslint-disable-next-line no-console\n    return this.enabled ? Function.prototype.bind.call(console.warn, console) : noop;\n  }\n\n  get error() {\n    // eslint-disable-next-line no-console\n    return this.enabled ? Function.prototype.bind.call(console.error, console) : noop;\n  }\n}\n","// ==========================================================================\n// Fullscreen wrapper\n// https://developer.mozilla.org/en-US/docs/Web/API/Fullscreen_API#prefixing\n// https://webkit.org/blog/7929/designing-websites-for-iphone-x/\n// ==========================================================================\n\nimport browser from './utils/browser';\nimport { closest,getElements, hasClass, toggleClass } from './utils/elements';\nimport { on, triggerEvent } from './utils/events';\nimport is from './utils/is';\nimport { silencePromise } from './utils/promise';\n\nclass Fullscreen {\n  constructor(player) {\n    // Keep reference to parent\n    this.player = player;\n\n    // Get prefix\n    this.prefix = Fullscreen.prefix;\n    this.property = Fullscreen.property;\n\n    // Scroll position\n    this.scrollPosition = { x: 0, y: 0 };\n\n    // Force the use of 'full window/browser' rather than fullscreen\n    this.forceFallback = player.config.fullscreen.fallback === 'force';\n\n    // Get the fullscreen element\n    // Checks container is an ancestor, defaults to null\n    this.player.elements.fullscreen =\n      player.config.fullscreen.container && closest(this.player.elements.container, player.config.fullscreen.container);\n\n    // Register event listeners\n    // Handle event (incase user presses escape etc)\n    on.call(\n      this.player,\n      document,\n      this.prefix === 'ms' ? 'MSFullscreenChange' : `${this.prefix}fullscreenchange`,\n      () => {\n        this.onChange();\n      },\n    );\n\n    // Fullscreen toggle on double click\n    on.call(this.player, this.player.elements.container, 'dblclick', event => {\n      // Ignore double click in controls\n      if (is.element(this.player.elements.controls) && this.player.elements.controls.contains(event.target)) {\n        return;\n      }\n\n      this.toggle();\n    });\n\n    // Tap focus when in fullscreen\n    on.call(this, this.player.elements.container, 'keydown', event => this.trapFocus(event));\n\n    // Update the UI\n    this.update();\n  }\n\n  // Determine if native supported\n  static get native() {\n    return !!(\n      document.fullscreenEnabled ||\n      document.webkitFullscreenEnabled ||\n      document.mozFullScreenEnabled ||\n      document.msFullscreenEnabled\n    );\n  }\n\n  // If we're actually using native\n  get usingNative() {\n    return Fullscreen.native && !this.forceFallback;\n  }\n\n  // Get the prefix for handlers\n  static get prefix() {\n    // No prefix\n    if (is.function(document.exitFullscreen)) {\n      return '';\n    }\n\n    // Check for fullscreen support by vendor prefix\n    let value = '';\n    const prefixes = ['webkit', 'moz', 'ms'];\n\n    prefixes.some(pre => {\n      if (is.function(document[`${pre}ExitFullscreen`]) || is.function(document[`${pre}CancelFullScreen`])) {\n        value = pre;\n        return true;\n      }\n\n      return false;\n    });\n\n    return value;\n  }\n\n  static get property() {\n    return this.prefix === 'moz' ? 'FullScreen' : 'Fullscreen';\n  }\n\n  // Determine if fullscreen is enabled\n  get enabled() {\n    return (\n      (Fullscreen.native || this.player.config.fullscreen.fallback) &&\n      this.player.config.fullscreen.enabled &&\n      this.player.supported.ui &&\n      this.player.isVideo\n    );\n  }\n\n  // Get active state\n  get active() {\n    if (!this.enabled) {\n      return false;\n    }\n\n    // Fallback using classname\n    if (!Fullscreen.native || this.forceFallback) {\n      return hasClass(this.target, this.player.config.classNames.fullscreen.fallback);\n    }\n\n    const element = !this.prefix ? document.fullscreenElement : document[`${this.prefix}${this.property}Element`];\n\n    return element && element.shadowRoot ? element === this.target.getRootNode().host : element === this.target;\n  }\n\n  // Get target element\n  get target() {\n    return browser.isIos && this.player.config.fullscreen.iosNative ? this.player.media\n      : this.player.elements.fullscreen || this.player.elements.container;\n  }\n\n  onChange() {\n    if (!this.enabled) {\n      return;\n    }\n\n    // Update toggle button\n    const button = this.player.elements.buttons.fullscreen;\n    if (is.element(button)) {\n      button.pressed = this.active;\n    }\n\n    // Trigger an event\n    triggerEvent.call(this.player, this.target, this.active ? 'enterfullscreen' : 'exitfullscreen', true);\n  }\n\n  toggleFallback(toggle = false) {\n    // Store or restore scroll position\n    if (toggle) {\n      this.scrollPosition = {\n        x: window.scrollX || 0,\n        y: window.scrollY || 0,\n      };\n    } else {\n      window.scrollTo(this.scrollPosition.x, this.scrollPosition.y);\n    }\n\n    // Toggle scroll\n    document.body.style.overflow = toggle ? 'hidden' : '';\n\n    // Toggle class hook\n    toggleClass(this.target, this.player.config.classNames.fullscreen.fallback, toggle);\n\n    // Force full viewport on iPhone X+\n    if (browser.isIos) {\n      let viewport = document.head.querySelector('meta[name=\"viewport\"]');\n      const property = 'viewport-fit=cover';\n\n      // Inject the viewport meta if required\n      if (!viewport) {\n        viewport = document.createElement('meta');\n        viewport.setAttribute('name', 'viewport');\n      }\n\n      // Check if the property already exists\n      const hasProperty = is.string(viewport.content) && viewport.content.includes(property);\n\n      if (toggle) {\n        this.cleanupViewport = !hasProperty;\n\n        if (!hasProperty) {\n          viewport.content += `,${property}`;\n        }\n      } else if (this.cleanupViewport) {\n        viewport.content = viewport.content\n          .split(',')\n          .filter(part => part.trim() !== property)\n          .join(',');\n      }\n    }\n\n    // Toggle button and fire events\n    this.onChange();\n  }\n\n  // Trap focus inside container\n  trapFocus(event) {\n    // Bail if iOS, not active, not the tab key\n    if (browser.isIos || !this.active || event.key !== 'Tab' || event.keyCode !== 9) {\n      return;\n    }\n\n    // Get the current focused element\n    const focused = document.activeElement;\n    const focusable = getElements.call(this.player, 'a[href], button:not(:disabled), input:not(:disabled), [tabindex]');\n    const [first] = focusable;\n    const last = focusable[focusable.length - 1];\n\n    if (focused === last && !event.shiftKey) {\n      // Move focus to first element that can be tabbed if Shift isn't used\n      first.focus();\n      event.preventDefault();\n    } else if (focused === first && event.shiftKey) {\n      // Move focus to last element that can be tabbed if Shift is used\n      last.focus();\n      event.preventDefault();\n    }\n  }\n\n  // Update UI\n  update() {\n    if (this.enabled) {\n      let mode;\n\n      if (this.forceFallback) {\n        mode = 'Fallback (forced)';\n      } else if (Fullscreen.native) {\n        mode = 'Native';\n      } else {\n        mode = 'Fallback';\n      }\n\n      this.player.debug.log(`${mode} fullscreen enabled`);\n    } else {\n      this.player.debug.log('Fullscreen not supported and fallback disabled');\n    }\n\n    // Add styling hook to show button\n    toggleClass(this.player.elements.container, this.player.config.classNames.fullscreen.enabled, this.enabled);\n  }\n\n  // Make an element fullscreen\n  enter() {\n    if (!this.enabled) {\n      return;\n    }\n\n    // iOS native fullscreen doesn't need the request step\n    if (browser.isIos && this.player.config.fullscreen.iosNative) {\n      this.target.webkitEnterFullscreen();\n    } else if (!Fullscreen.native || this.forceFallback) {\n      this.toggleFallback(true);\n    } else if (!this.prefix) {\n      this.target.requestFullscreen({ navigationUI: 'hide' });\n    } else if (!is.empty(this.prefix)) {\n      this.target[`${this.prefix}Request${this.property}`]();\n    }\n  }\n\n  // Bail from fullscreen\n  exit() {\n    if (!this.enabled) {\n      return;\n    }\n\n    // iOS native fullscreen\n    if (browser.isIos && this.player.config.fullscreen.iosNative) {\n      this.target.webkitExitFullscreen();\n      silencePromise(this.player.play());\n    } else if (!Fullscreen.native || this.forceFallback) {\n      this.toggleFallback(false);\n    } else if (!this.prefix) {\n      (document.cancelFullScreen || document.exitFullscreen).call(document);\n    } else if (!is.empty(this.prefix)) {\n      const action = this.prefix === 'moz' ? 'Cancel' : 'Exit';\n      document[`${this.prefix}${action}${this.property}`]();\n    }\n  }\n\n  // Toggle state\n  toggle() {\n    if (!this.active) {\n      this.enter();\n    } else {\n      this.exit();\n    }\n  }\n}\n\nexport default Fullscreen;\n","// ==========================================================================\n// Load image avoiding xhr/fetch CORS issues\n// Server status can't be obtained this way unfortunately, so this uses \"naturalWidth\" to determine if the image has loaded\n// By default it checks if it is at least 1px, but you can add a second argument to change this\n// ==========================================================================\n\nexport default function loadImage(src, minWidth = 1) {\n  return new Promise((resolve, reject) => {\n    const image = new Image();\n\n    const handler = () => {\n      delete image.onload;\n      delete image.onerror;\n      (image.naturalWidth >= minWidth ? resolve : reject)(image);\n    };\n\n    Object.assign(image, { onload: handler, onerror: handler, src });\n  });\n}\n","// ==========================================================================\n// WassPlayer UI\n// ==========================================================================\n\nimport captions from './captions';\nimport controls from './controls';\nimport support from './support';\nimport browser from './utils/browser';\nimport { getElement, toggleClass } from './utils/elements';\nimport { ready, triggerEvent } from './utils/events';\nimport i18n from './utils/i18n';\nimport is from './utils/is';\nimport loadImage from './utils/load-image';\n\nconst ui = {\n  addStyleHook() {\n    toggleClass(this.elements.container, this.config.selectors.container.replace('.', ''), true);\n    toggleClass(this.elements.container, this.config.classNames.uiSupported, this.supported.ui);\n  },\n\n  // Toggle native HTML5 media controls\n  toggleNativeControls(toggle = false) {\n    if (toggle && this.isHTML5) {\n      this.media.setAttribute('controls', '');\n    } else {\n      this.media.removeAttribute('controls');\n    }\n  },\n\n  // Setup the UI\n  build() {\n    // Re-attach media element listeners\n    // TODO: Use event bubbling?\n    this.listeners.media();\n\n    // Don't setup interface if no support\n    if (!this.supported.ui) {\n      this.debug.warn(`Basic support only for ${this.provider} ${this.type}`);\n\n      // Restore native controls\n      ui.toggleNativeControls.call(this, true);\n\n      // Bail\n      return;\n    }\n\n    // Inject custom controls if not present\n    if (!is.element(this.elements.controls)) {\n      // Inject custom controls\n      controls.inject.call(this);\n\n      // Re-attach control listeners\n      this.listeners.controls();\n    }\n\n    // Remove native controls\n    ui.toggleNativeControls.call(this);\n\n    // Setup captions for HTML5\n    if (this.isHTML5) {\n      captions.setup.call(this);\n    }\n\n    // Reset volume\n    this.volume = null;\n\n    // Reset mute state\n    this.muted = null;\n\n    // Reset loop state\n    this.loop = null;\n\n    // Reset quality setting\n    this.quality = null;\n\n    // Reset speed\n    this.speed = null;\n\n    // Reset volume display\n    controls.updateVolume.call(this);\n\n    // Reset time display\n    controls.timeUpdate.call(this);\n\n    // Update the UI\n    ui.checkPlaying.call(this);\n\n    // Check for picture-in-picture support\n    toggleClass(\n      this.elements.container,\n      this.config.classNames.pip.supported,\n      support.pip && this.isHTML5 && this.isVideo,\n    );\n\n    // Check for airplay support\n    toggleClass(this.elements.container, this.config.classNames.airplay.supported, support.airplay && this.isHTML5);\n\n    // Add iOS class\n    toggleClass(this.elements.container, this.config.classNames.isIos, browser.isIos);\n\n    // Add touch class\n    toggleClass(this.elements.container, this.config.classNames.isTouch, this.touch);\n\n    // Ready for API calls\n    this.ready = true;\n\n    // Ready event at end of execution stack\n    setTimeout(() => {\n      triggerEvent.call(this, this.media, 'ready');\n    }, 0);\n\n    // Set the title\n    ui.setTitle.call(this);\n\n    // Assure the poster image is set, if the property was added before the element was created\n    if (this.poster) {\n      ui.setPoster.call(this, this.poster, false).catch(() => {});\n    }\n\n    // Manually set the duration if user has overridden it.\n    // The event listeners for it doesn't get called if preload is disabled (#701)\n    if (this.config.duration) {\n      controls.durationUpdate.call(this);\n    }\n  },\n\n  // Setup aria attribute for play and iframe title\n  setTitle() {\n    // Find the current text\n    let label = i18n.get('play', this.config);\n\n    // If there's a media title set, use that for the label\n    if (is.string(this.config.title) && !is.empty(this.config.title)) {\n      label += `, ${this.config.title}`;\n    }\n\n    // If there's a play button, set label\n    Array.from(this.elements.buttons.play || []).forEach(button => {\n      button.setAttribute('aria-label', label);\n    });\n\n    // Set iframe title\n    // https://github.com/sampotts/WassPlayer/issues/124\n    if (this.isEmbed) {\n      const iframe = getElement.call(this, 'iframe');\n\n      if (!is.element(iframe)) {\n        return;\n      }\n\n      // Default to media type\n      const title = !is.empty(this.config.title) ? this.config.title : 'video';\n      const format = i18n.get('frameTitle', this.config);\n\n      iframe.setAttribute('title', format.replace('{title}', title));\n    }\n  },\n\n  // Toggle poster\n  togglePoster(enable) {\n    toggleClass(this.elements.container, this.config.classNames.posterEnabled, enable);\n  },\n\n  // Set the poster image (async)\n  // Used internally for the poster setter, with the passive option forced to false\n  setPoster(poster, passive = true) {\n    // Don't override if call is passive\n    if (passive && this.poster) {\n      return Promise.reject(new Error('Poster already set'));\n    }\n\n    // Set property synchronously to respect the call order\n    this.media.setAttribute('data-poster', poster);\n\n    // Wait until ui is ready\n    return (\n      ready\n        .call(this)\n        // Load image\n        .then(() => loadImage(poster))\n        .catch(err => {\n          // Hide poster on error unless it's been set by another call\n          if (poster === this.poster) {\n            ui.togglePoster.call(this, false);\n          }\n          // Rethrow\n          throw err;\n        })\n        .then(() => {\n          // Prevent race conditions\n          if (poster !== this.poster) {\n            throw new Error('setPoster cancelled by later call to setPoster');\n          }\n        })\n        .then(() => {\n          Object.assign(this.elements.poster.style, {\n            backgroundImage: `url('${poster}')`,\n            // Reset backgroundSize as well (since it can be set to \"cover\" for padded thumbnails for youtube)\n            backgroundSize: '',\n          });\n\n          ui.togglePoster.call(this, true);\n\n          return poster;\n        })\n    );\n  },\n\n  // Check playing state\n  checkPlaying(event) {\n    // Class hooks\n    toggleClass(this.elements.container, this.config.classNames.playing, this.playing);\n    toggleClass(this.elements.container, this.config.classNames.paused, this.paused);\n    toggleClass(this.elements.container, this.config.classNames.stopped, this.stopped);\n\n    // Set state\n    Array.from(this.elements.buttons.play || []).forEach(target => {\n      Object.assign(target, { pressed: this.playing });\n      target.setAttribute('aria-label', i18n.get(this.playing ? 'pause' : 'play', this.config));\n    });\n\n    // Only update controls on non timeupdate events\n    if (is.event(event) && event.type === 'timeupdate') {\n      return;\n    }\n\n    // Toggle controls\n    ui.toggleControls.call(this);\n  },\n\n  // Check if media is loading\n  checkLoading(event) {\n    this.loading = ['stalled', 'waiting'].includes(event.type);\n\n    // Clear timer\n    clearTimeout(this.timers.loading);\n\n    // Timer to prevent flicker when seeking\n    this.timers.loading = setTimeout(\n      () => {\n        // Update progress bar loading class state\n        toggleClass(this.elements.container, this.config.classNames.loading, this.loading);\n\n        // Update controls visibility\n        ui.toggleControls.call(this);\n      },\n      this.loading ? 250 : 0,\n    );\n  },\n\n  // Toggle controls based on state and `force` argument\n  toggleControls(force) {\n    const { controls: controlsElement } = this.elements;\n\n    if (controlsElement && this.config.hideControls) {\n      // Don't hide controls if a touch-device user recently seeked. (Must be limited to touch devices, or it occasionally prevents desktop controls from hiding.)\n      const recentTouchSeek = this.touch && this.lastSeekTime + 2000 > Date.now();\n\n      // Show controls if force, loading, paused, button interaction, or recent seek, otherwise hide\n      this.toggleControls(\n        Boolean(\n          force || this.loading || this.paused || controlsElement.pressed || controlsElement.hover || recentTouchSeek,\n        ),\n      );\n    }\n  },\n\n  // Migrate any custom properties from the media to the parent\n  migrateStyles() {\n    // Loop through values (as they are the keys when the object is spread )\n    Object.values({ ...this.media.style })\n      // We're only fussed about WassPlayer specific properties\n      .filter(key => !is.empty(key) && key.startsWith('--wassPlayer'))\n      .forEach(key => {\n        // Set on the container\n        this.elements.container.style.setProperty(key, this.media.style.getPropertyValue(key));\n\n        // Clean up from media element\n        this.media.style.removeProperty(key);\n      });\n\n    // Remove attribute if empty\n    if (is.empty(this.media.style)) {\n      this.media.removeAttribute('style');\n    }\n  },\n};\n\nexport default ui;\n","// ==========================================================================\n// WassPlayer Event Listeners\n// ==========================================================================\n\nimport controls from './controls';\nimport ui from './ui';\nimport { repaint } from './utils/animation';\nimport browser from './utils/browser';\nimport { getElement, getElements, matches, toggleClass } from './utils/elements';\nimport { off, on, once, toggleListener, triggerEvent } from './utils/events';\nimport is from './utils/is';\nimport { silencePromise } from './utils/promise';\nimport { getAspectRatio, setAspectRatio } from './utils/style';\n\nclass Listeners {\n  constructor(player) {\n    this.player = player;\n    this.lastKey = null;\n    this.focusTimer = null;\n    this.lastKeyDown = null;\n\n    this.handleKey = this.handleKey.bind(this);\n    this.toggleMenu = this.toggleMenu.bind(this);\n    this.setTabFocus = this.setTabFocus.bind(this);\n    this.firstTouch = this.firstTouch.bind(this);\n  }\n\n  // Handle key presses\n  handleKey(event) {\n    const { player } = this;\n    const { elements } = player;\n    const code = event.keyCode ? event.keyCode : event.which;\n    const pressed = event.type === 'keydown';\n    const repeat = pressed && code === this.lastKey;\n\n    // Bail if a modifier key is set\n    if (event.altKey || event.ctrlKey || event.metaKey || event.shiftKey) {\n      return;\n    }\n\n    // If the event is bubbled from the media element\n    // Firefox doesn't get the keycode for whatever reason\n    if (!is.number(code)) {\n      return;\n    }\n\n    // Seek by the number keys\n    const seekByKey = () => {\n      // Divide the max duration into 10th's and times by the number value\n      player.currentTime = (player.duration / 10) * (code - 48);\n    };\n\n    // Handle the key on keydown\n    // Reset on keyup\n    if (pressed) {\n      // Check focused element\n      // and if the focused element is not editable (e.g. text input)\n      // and any that accept key input http://webaim.org/techniques/keyboard/\n      const focused = document.activeElement;\n      if (is.element(focused)) {\n        const { editable } = player.config.selectors;\n        const { seek } = elements.inputs;\n\n        if (focused !== seek && matches(focused, editable)) {\n          return;\n        }\n\n        if (event.which === 32 && matches(focused, 'button, [role^=\"menuitem\"]')) {\n          return;\n        }\n      }\n\n      // Which keycodes should we prevent default\n      const preventDefault = [32, 37, 38, 39, 40, 48, 49, 50, 51, 52, 53, 54, 56, 57, 67, 70, 73, 75, 76, 77, 79];\n\n      // If the code is found prevent default (e.g. prevent scrolling for arrows)\n      if (preventDefault.includes(code)) {\n        event.preventDefault();\n        event.stopPropagation();\n      }\n\n      switch (code) {\n        case 48:\n        case 49:\n        case 50:\n        case 51:\n        case 52:\n        case 53:\n        case 54:\n        case 55:\n        case 56:\n        case 57:\n          // 0-9\n          if (!repeat) {\n            seekByKey();\n          }\n          break;\n\n        case 32:\n        case 75:\n          // Space and K key\n          if (!repeat) {\n            silencePromise(player.togglePlay());\n          }\n          break;\n\n        case 38:\n          // Arrow up\n          player.increaseVolume(0.1);\n          break;\n\n        case 40:\n          // Arrow down\n          player.decreaseVolume(0.1);\n          break;\n\n        case 77:\n          // M key\n          if (!repeat) {\n            player.muted = !player.muted;\n          }\n          break;\n\n        case 39:\n          // Arrow forward\n          player.forward();\n          break;\n\n        case 37:\n          // Arrow back\n          player.rewind();\n          break;\n\n        case 70:\n          // F key\n          player.fullscreen.toggle();\n          break;\n\n        case 67:\n          // C key\n          if (!repeat) {\n            player.toggleCaptions();\n          }\n          break;\n\n        case 76:\n          // L key\n          player.loop = !player.loop;\n          break;\n\n        /* case 73:\n                    this.setLoop('start');\n                    break;\n\n                case 76:\n                    this.setLoop();\n                    break;\n\n                case 79:\n                    this.setLoop('end');\n                    break; */\n\n        default:\n          break;\n      }\n\n      // Escape is handle natively when in full screen\n      // So we only need to worry about non native\n      if (code === 27 && !player.fullscreen.usingNative && player.fullscreen.active) {\n        player.fullscreen.toggle();\n      }\n\n      // Store last code for next cycle\n      this.lastKey = code;\n    } else {\n      this.lastKey = null;\n    }\n  }\n\n  // Toggle menu\n  toggleMenu(event) {\n    controls.toggleMenu.call(this.player, event);\n  }\n\n  // Device is touch enabled\n  firstTouch() {\n    const { player } = this;\n    const { elements } = player;\n\n    player.touch = true;\n\n    // Add touch class\n    toggleClass(elements.container, player.config.classNames.isTouch, true);\n  }\n\n  setTabFocus(event) {\n    const { player } = this;\n    const { elements } = player;\n\n    clearTimeout(this.focusTimer);\n\n    // Ignore any key other than tab\n    if (event.type === 'keydown' && event.which !== 9) {\n      return;\n    }\n\n    // Store reference to event timeStamp\n    if (event.type === 'keydown') {\n      this.lastKeyDown = event.timeStamp;\n    }\n\n    // Remove current classes\n    const removeCurrent = () => {\n      const className = player.config.classNames.tabFocus;\n      const current = getElements.call(player, `.${className}`);\n      toggleClass(current, className, false);\n    };\n\n    // Determine if a key was pressed to trigger this event\n    const wasKeyDown = event.timeStamp - this.lastKeyDown <= 20;\n\n    // Ignore focus events if a key was pressed prior\n    if (event.type === 'focus' && !wasKeyDown) {\n      return;\n    }\n\n    // Remove all current\n    removeCurrent();\n\n    // Delay the adding of classname until the focus has changed\n    // This event fires before the focusin event\n    if (event.type !== 'focusout') {\n      this.focusTimer = setTimeout(() => {\n        const focused = document.activeElement;\n\n        // Ignore if current focus element isn't inside the player\n        if (!elements.container.contains(focused)) {\n          return;\n        }\n\n        toggleClass(document.activeElement, player.config.classNames.tabFocus, true);\n      }, 10);\n    }\n  }\n\n  // Global window & document listeners\n  global(toggle = true) {\n    const { player } = this;\n\n    // Keyboard shortcuts\n    if (player.config.keyboard.global) {\n      toggleListener.call(player, window, 'keydown keyup', this.handleKey, toggle, false);\n    }\n\n    // Click anywhere closes menu\n    toggleListener.call(player, document.body, 'click', this.toggleMenu, toggle);\n\n    // Detect touch by events\n    once.call(player, document.body, 'touchstart', this.firstTouch);\n\n    // Tab focus detection\n    toggleListener.call(player, document.body, 'keydown focus blur focusout', this.setTabFocus, toggle, false, true);\n  }\n\n  // Container listeners\n  container() {\n    const { player } = this;\n    const { config, elements, timers } = player;\n\n    // Keyboard shortcuts\n    if (!config.keyboard.global && config.keyboard.focused) {\n      on.call(player, elements.container, 'keydown keyup', this.handleKey, false);\n    }\n\n    // Toggle controls on mouse events and entering fullscreen\n    on.call(\n      player,\n      elements.container,\n      'mousemove mouseleave touchstart touchmove enterfullscreen exitfullscreen',\n      event => {\n        const { controls: controlsElement } = elements;\n\n        // Remove button states for fullscreen\n        if (controlsElement && event.type === 'enterfullscreen') {\n          controlsElement.pressed = false;\n          controlsElement.hover = false;\n        }\n\n        // Show, then hide after a timeout unless another control event occurs\n        const show = ['touchstart', 'touchmove', 'mousemove'].includes(event.type);\n        let delay = 0;\n\n        if (show) {\n          ui.toggleControls.call(player, true);\n          // Use longer timeout for touch devices\n          delay = player.touch ? 3000 : 2000;\n        }\n\n        // Clear timer\n        clearTimeout(timers.controls);\n\n        // Set new timer to prevent flicker when seeking\n        timers.controls = setTimeout(() => ui.toggleControls.call(player, false), delay);\n      },\n    );\n\n    // Set a gutter for Vimeo\n    const setGutter = (ratio, padding, toggle) => {\n      if (!player.isVimeo || player.config.vimeo.premium) {\n        return;\n      }\n\n      const target = player.elements.wrapper.firstChild;\n      const [, y] = ratio;\n      const [videoX, videoY] = getAspectRatio.call(player);\n\n      target.style.maxWidth = toggle ? `${(y / videoY) * videoX}px` : null;\n      target.style.margin = toggle ? '0 auto' : null;\n    };\n\n    // Resize on fullscreen change\n    const setPlayerSize = measure => {\n      // If we don't need to measure the viewport\n      if (!measure) {\n        return setAspectRatio.call(player);\n      }\n\n      const rect = elements.container.getBoundingClientRect();\n      const { width, height } = rect;\n\n      return setAspectRatio.call(player, `${width}:${height}`);\n    };\n\n    const resized = () => {\n      clearTimeout(timers.resized);\n      timers.resized = setTimeout(setPlayerSize, 50);\n    };\n\n    on.call(player, elements.container, 'enterfullscreen exitfullscreen', event => {\n      const { target, usingNative } = player.fullscreen;\n\n      // Ignore events not from target\n      if (target !== elements.container) {\n        return;\n      }\n\n      // If it's not an embed and no ratio specified\n      if (!player.isEmbed && is.empty(player.config.ratio)) {\n        return;\n      }\n\n      const isEnter = event.type === 'enterfullscreen';\n      // Set the player size when entering fullscreen to viewport size\n      const { padding, ratio } = setPlayerSize(isEnter);\n\n      // Set Vimeo gutter\n      setGutter(ratio, padding, isEnter);\n\n      // If not using native browser fullscreen API, we need to check for resizes of viewport\n      if (!usingNative) {\n        if (isEnter) {\n          on.call(player, window, 'resize', resized);\n        } else {\n          off.call(player, window, 'resize', resized);\n        }\n      }\n    });\n  }\n\n  // Listen for media events\n  media() {\n    const { player } = this;\n    const { elements } = player;\n\n    // Time change on media\n    on.call(player, player.media, 'timeupdate seeking seeked', event => controls.timeUpdate.call(player, event));\n\n    // Display duration\n    on.call(player, player.media, 'durationchange loadeddata loadedmetadata', event =>\n      controls.durationUpdate.call(player, event),\n    );\n\n    // Handle the media finishing\n    on.call(player, player.media, 'ended', () => {\n      // Show poster on end\n      if (player.isHTML5 && player.isVideo && player.config.resetOnEnd) {\n        // Restart\n        player.restart();\n\n        // Call pause otherwise IE11 will start playing the video again\n        player.pause();\n      }\n    });\n\n    // Check for buffer progress\n    on.call(player, player.media, 'progress playing seeking seeked', event =>\n      controls.updateProgress.call(player, event),\n    );\n\n    // Handle volume changes\n    on.call(player, player.media, 'volumechange', event => controls.updateVolume.call(player, event));\n\n    // Handle play/pause\n    on.call(player, player.media, 'playing play pause ended emptied timeupdate', event =>\n      ui.checkPlaying.call(player, event),\n    );\n\n    // Loading state\n    on.call(player, player.media, 'waiting canplay seeked playing', event => ui.checkLoading.call(player, event));\n\n    // Click video\n    if (player.supported.ui && player.config.clickToPlay && !player.isAudio) {\n      // Re-fetch the wrapper\n      const wrapper = getElement.call(player, `.${player.config.classNames.video}`);\n\n      // Bail if there's no wrapper (this should never happen)\n      if (!is.element(wrapper)) {\n        return;\n      }\n\n      // On click play, pause or restart\n      on.call(player, elements.container, 'click', event => {\n        const targets = [elements.container, wrapper];\n\n        // Ignore if click if not container or in video wrapper\n        if (!targets.includes(event.target) && !wrapper.contains(event.target)) {\n          return;\n        }\n\n        // Touch devices will just show controls (if hidden)\n        if (player.touch && player.config.hideControls) {\n          return;\n        }\n\n        if (player.ended) {\n          this.proxy(event, player.restart, 'restart');\n          this.proxy(\n            event,\n            () => {\n              silencePromise(player.play());\n            },\n            'play',\n          );\n        } else {\n          this.proxy(\n            event,\n            () => {\n              silencePromise(player.togglePlay());\n            },\n            'play',\n          );\n        }\n      });\n    }\n\n    // Disable right click\n    if (player.supported.ui && player.config.disableContextMenu) {\n      on.call(\n        player,\n        elements.wrapper,\n        'contextmenu',\n        event => {\n          event.preventDefault();\n        },\n        false,\n      );\n    }\n\n    // Volume change\n    on.call(player, player.media, 'volumechange', () => {\n      // Save to storage\n      player.storage.set({\n        volume: player.volume,\n        muted: player.muted,\n      });\n    });\n\n    // Speed change\n    on.call(player, player.media, 'ratechange', () => {\n      // Update UI\n      controls.updateSetting.call(player, 'speed');\n\n      // Save to storage\n      player.storage.set({ speed: player.speed });\n    });\n\n    // Quality change\n    on.call(player, player.media, 'qualitychange', event => {\n      // Update UI\n      controls.updateSetting.call(player, 'quality', null, event.detail.quality);\n    });\n\n    // Update download link when ready and if quality changes\n    on.call(player, player.media, 'ready qualitychange', () => {\n      controls.setDownloadUrl.call(player);\n    });\n\n    // Proxy events to container\n    // Bubble up key events for Edge\n    const proxyEvents = player.config.events.concat(['keyup', 'keydown']).join(' ');\n\n    on.call(player, player.media, proxyEvents, event => {\n      let { detail = {} } = event;\n\n      // Get error details from media\n      if (event.type === 'error') {\n        detail = player.media.error;\n      }\n\n      triggerEvent.call(player, elements.container, event.type, true, detail);\n    });\n  }\n\n  // Run default and custom handlers\n  proxy(event, defaultHandler, customHandlerKey) {\n    const { player } = this;\n    const customHandler = player.config.listeners[customHandlerKey];\n    const hasCustomHandler = is.function(customHandler);\n    let returned = true;\n\n    // Execute custom handler\n    if (hasCustomHandler) {\n      returned = customHandler.call(player, event);\n    }\n\n    // Only call default handler if not prevented in custom handler\n    if (returned !== false && is.function(defaultHandler)) {\n      defaultHandler.call(player, event);\n    }\n  }\n\n  // Trigger custom and default handlers\n  bind(element, type, defaultHandler, customHandlerKey, passive = true) {\n    const { player } = this;\n    const customHandler = player.config.listeners[customHandlerKey];\n    const hasCustomHandler = is.function(customHandler);\n\n    on.call(\n      player,\n      element,\n      type,\n      event => this.proxy(event, defaultHandler, customHandlerKey),\n      passive && !hasCustomHandler,\n    );\n  }\n\n  // Listen for control events\n  controls() {\n    const { player } = this;\n    const { elements } = player;\n    // IE doesn't support input event, so we fallback to change\n    const inputEvent = browser.isIE ? 'change' : 'input';\n\n    // Play/pause toggle\n    if (elements.buttons.play) {\n      Array.from(elements.buttons.play).forEach(button => {\n        this.bind(\n          button,\n          'click',\n          () => {\n            silencePromise(player.togglePlay());\n          },\n          'play',\n        );\n      });\n    }\n\n    // Pause\n    this.bind(elements.buttons.restart, 'click', player.restart, 'restart');\n\n    // Rewind\n    this.bind(elements.buttons.rewind, 'click', player.rewind, 'rewind');\n\n    // Rewind\n    this.bind(elements.buttons.fastForward, 'click', player.forward, 'fastForward');\n\n    // Mute toggle\n    this.bind(\n      elements.buttons.mute,\n      'click',\n      () => {\n        player.muted = !player.muted;\n      },\n      'mute',\n    );\n\n    // Captions toggle\n    this.bind(elements.buttons.captions, 'click', () => player.toggleCaptions());\n\n    // Download\n    this.bind(\n      elements.buttons.download,\n      'click',\n      () => {\n        triggerEvent.call(player, player.media, 'download');\n      },\n      'download',\n    );\n\n    // Fullscreen toggle\n    this.bind(\n      elements.buttons.fullscreen,\n      'click',\n      () => {\n        player.fullscreen.toggle();\n      },\n      'fullscreen',\n    );\n\n    // Picture-in-Picture\n    this.bind(\n      elements.buttons.pip,\n      'click',\n      () => {\n        player.pip = 'toggle';\n      },\n      'pip',\n    );\n\n    // Airplay\n    this.bind(elements.buttons.airplay, 'click', player.airplay, 'airplay');\n\n    // Settings menu - click toggle\n    this.bind(\n      elements.buttons.settings,\n      'click',\n      event => {\n        // Prevent the document click listener closing the menu\n        event.stopPropagation();\n        event.preventDefault();\n\n        controls.toggleMenu.call(player, event);\n      },\n      null,\n      false,\n    ); // Can't be passive as we're preventing default\n\n    // Settings menu - keyboard toggle\n    // We have to bind to keyup otherwise Firefox triggers a click when a keydown event handler shifts focus\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=1220143\n    this.bind(\n      elements.buttons.settings,\n      'keyup',\n      event => {\n        const code = event.which;\n\n        // We only care about space and return\n        if (![13, 32].includes(code)) {\n          return;\n        }\n\n        // Because return triggers a click anyway, all we need to do is set focus\n        if (code === 13) {\n          controls.focusFirstMenuItem.call(player, null, true);\n          return;\n        }\n\n        // Prevent scroll\n        event.preventDefault();\n\n        // Prevent playing video (Firefox)\n        event.stopPropagation();\n\n        // Toggle menu\n        controls.toggleMenu.call(player, event);\n      },\n      null,\n      false, // Can't be passive as we're preventing default\n    );\n\n    // Escape closes menu\n    this.bind(elements.settings.menu, 'keydown', event => {\n      if (event.which === 27) {\n        controls.toggleMenu.call(player, event);\n      }\n    });\n\n    // Set range input alternative \"value\", which matches the tooltip time (#954)\n    this.bind(elements.inputs.seek, 'mousedown mousemove', event => {\n      const rect = elements.progress.getBoundingClientRect();\n      const percent = (100 / rect.width) * (event.pageX - rect.left);\n      event.currentTarget.setAttribute('seek-value', percent);\n    });\n\n    // Pause while seeking\n    this.bind(elements.inputs.seek, 'mousedown mouseup keydown keyup touchstart touchend', event => {\n      const seek = event.currentTarget;\n      const code = event.keyCode ? event.keyCode : event.which;\n      const attribute = 'play-on-seeked';\n\n      if (is.keyboardEvent(event) && code !== 39 && code !== 37) {\n        return;\n      }\n\n      // Record seek time so we can prevent hiding controls for a few seconds after seek\n      player.lastSeekTime = Date.now();\n\n      // Was playing before?\n      const play = seek.hasAttribute(attribute);\n      // Done seeking\n      const done = ['mouseup', 'touchend', 'keyup'].includes(event.type);\n\n      // If we're done seeking and it was playing, resume playback\n      if (play && done) {\n        seek.removeAttribute(attribute);\n        silencePromise(player.play());\n      } else if (!done && player.playing) {\n        seek.setAttribute(attribute, '');\n        player.pause();\n      }\n    });\n\n    // Fix range inputs on iOS\n    // Super weird iOS bug where after you interact with an <input type=\"range\">,\n    // it takes over further interactions on the page. This is a hack\n    if (browser.isIos) {\n      const inputs = getElements.call(player, 'input[type=\"range\"]');\n      Array.from(inputs).forEach(input => this.bind(input, inputEvent, event => repaint(event.target)));\n    }\n\n    // Seek\n    this.bind(\n      elements.inputs.seek,\n      inputEvent,\n      event => {\n        const seek = event.currentTarget;\n        // If it exists, use seek-value instead of \"value\" for consistency with tooltip time (#954)\n        let seekTo = seek.getAttribute('seek-value');\n\n        if (is.empty(seekTo)) {\n          seekTo = seek.value;\n        }\n\n        seek.removeAttribute('seek-value');\n\n        player.currentTime = (seekTo / seek.max) * player.duration;\n      },\n      'seek',\n    );\n\n    // Seek tooltip\n    this.bind(elements.progress, 'mouseenter mouseleave mousemove', event =>\n      controls.updateSeekTooltip.call(player, event),\n    );\n\n    // Preview thumbnails plugin\n    this.bind(elements.progress, 'mousemove touchmove', event => {\n      const { previewThumbnails } = player;\n\n      if (previewThumbnails && previewThumbnails.loaded) {\n        previewThumbnails.startMove(event);\n      }\n    });\n\n    // Hide thumbnail preview - on mouse click, mouse leave, and video play/seek. All four are required, e.g., for buffering\n    this.bind(elements.progress, 'mouseleave touchend click', () => {\n      const { previewThumbnails } = player;\n\n      if (previewThumbnails && previewThumbnails.loaded) {\n        previewThumbnails.endMove(false, true);\n      }\n    });\n\n    // Show scrubbing preview\n    this.bind(elements.progress, 'mousedown touchstart', event => {\n      const { previewThumbnails } = player;\n\n      if (previewThumbnails && previewThumbnails.loaded) {\n        previewThumbnails.startScrubbing(event);\n      }\n    });\n\n    this.bind(elements.progress, 'mouseup touchend', event => {\n      const { previewThumbnails } = player;\n\n      if (previewThumbnails && previewThumbnails.loaded) {\n        previewThumbnails.endScrubbing(event);\n      }\n    });\n\n    // Polyfill for lower fill in <input type=\"range\"> for webkit\n    if (browser.isWebkit) {\n      Array.from(getElements.call(player, 'input[type=\"range\"]')).forEach(element => {\n        this.bind(element, 'input', event => controls.updateRangeFill.call(player, event.target));\n      });\n    }\n\n    // Current time invert\n    // Only if one time element is used for both currentTime and duration\n    if (player.config.toggleInvert && !is.element(elements.display.duration)) {\n      this.bind(elements.display.currentTime, 'click', () => {\n        // Do nothing if we're at the start\n        if (player.currentTime === 0) {\n          return;\n        }\n\n        player.config.invertTime = !player.config.invertTime;\n\n        controls.timeUpdate.call(player);\n      });\n    }\n\n    // Volume\n    this.bind(\n      elements.inputs.volume,\n      inputEvent,\n      event => {\n        player.volume = event.target.value;\n      },\n      'volume',\n    );\n\n    // Update controls.hover state (used for ui.toggleControls to avoid hiding when interacting)\n    this.bind(elements.controls, 'mouseenter mouseleave', event => {\n      elements.controls.hover = !player.touch && event.type === 'mouseenter';\n    });\n\n    // Also update controls.hover state for any non-player children of fullscreen element (as above)\n    if (elements.fullscreen) {\n      Array.from(elements.fullscreen.children)\n        .filter(c => !c.contains(elements.container))\n        .forEach(child => {\n          this.bind(child, 'mouseenter mouseleave', event => {\n            elements.controls.hover = !player.touch && event.type === 'mouseenter';\n          });\n        });\n    }\n\n    // Update controls.pressed state (used for ui.toggleControls to avoid hiding when interacting)\n    this.bind(elements.controls, 'mousedown mouseup touchstart touchend touchcancel', event => {\n      elements.controls.pressed = ['mousedown', 'touchstart'].includes(event.type);\n    });\n\n    // Show controls when they receive focus (e.g., when using keyboard tab key)\n    this.bind(elements.controls, 'focusin', () => {\n      const { config, timers } = player;\n\n      // Skip transition to prevent focus from scrolling the parent element\n      toggleClass(elements.controls, config.classNames.noTransition, true);\n\n      // Toggle\n      ui.toggleControls.call(player, true);\n\n      // Restore transition\n      setTimeout(() => {\n        toggleClass(elements.controls, config.classNames.noTransition, false);\n      }, 0);\n\n      // Delay a little more for mouse users\n      const delay = this.touch ? 3000 : 4000;\n\n      // Clear timer\n      clearTimeout(timers.controls);\n\n      // Hide again after delay\n      timers.controls = setTimeout(() => ui.toggleControls.call(player, false), delay);\n    });\n\n    // Mouse wheel for volume\n    this.bind(\n      elements.inputs.volume,\n      'wheel',\n      event => {\n        // Detect \"natural\" scroll - suppored on OS X Safari only\n        // Other browsers on OS X will be inverted until support improves\n        const inverted = event.webkitDirectionInvertedFromDevice;\n        // Get delta from event. Invert if `inverted` is true\n        const [x, y] = [event.deltaX, -event.deltaY].map(value => (inverted ? -value : value));\n        // Using the biggest delta, normalize to 1 or -1 (or 0 if no delta)\n        const direction = Math.sign(Math.abs(x) > Math.abs(y) ? x : y);\n\n        // Change the volume by 2%\n        player.increaseVolume(direction / 50);\n\n        // Don't break page scrolling at max and min\n        const { volume } = player.media;\n        if ((direction === 1 && volume < 1) || (direction === -1 && volume > 0)) {\n          event.preventDefault();\n        }\n      },\n      'volume',\n      false,\n    );\n  }\n}\n\nexport default Listeners;\n","// ==========================================================================\n// WassPlayer Media\n// ==========================================================================\n\nimport html5 from './html5';\nimport { createElement, toggleClass, wrap } from './utils/elements';\n\nconst media = {\n  // Setup media\n  setup() {\n    // If there's no media, bail\n    if (!this.media) {\n      this.debug.warn('No media element found!');\n      return;\n    }\n\n    // Add type class\n    toggleClass(this.elements.container, this.config.classNames.type.replace('{0}', this.type), true);\n\n    // Add provider class\n    toggleClass(this.elements.container, this.config.classNames.provider.replace('{0}', this.provider), true);\n\n    // Add video class for embeds\n    // This will require changes if audio embeds are added\n    if (this.isEmbed) {\n      toggleClass(this.elements.container, this.config.classNames.type.replace('{0}', 'video'), true);\n    }\n\n    // Inject the player wrapper\n    if (this.isVideo) {\n      // Create the wrapper div\n      this.elements.wrapper = createElement('div', {\n        class: this.config.classNames.video,\n      });\n\n      // Wrap the video in a container\n      wrap(this.media, this.elements.wrapper);\n\n      // Poster image container\n      this.elements.poster = createElement('div', {\n        class: this.config.classNames.poster,\n      });\n\n      this.elements.wrapper.appendChild(this.elements.poster);\n    }\n\n    if (this.isHTML5) {\n      html5.setup.call(this);\n    }\n  },\n};\n\nexport default media;\n","import { createElement } from '../utils/elements';\nimport { once } from '../utils/events';\nimport fetch from '../utils/fetch';\nimport is from '../utils/is';\nimport { formatTime } from '../utils/time';\n\n// Arg: vttDataString example: \"WEBVTT\\n\\n1\\n00:00:05.000 --> 00:00:10.000\\n1080p-00001.jpg\"\nconst parseVtt = vttDataString => {\n  const processedList = [];\n  const frames = vttDataString.split(/\\r\\n\\r\\n|\\n\\n|\\r\\r/);\n\n  frames.forEach(frame => {\n    const result = {};\n    const lines = frame.split(/\\r\\n|\\n|\\r/);\n\n    lines.forEach(line => {\n      if (!is.number(result.startTime)) {\n        // The line with start and end times on it is the first line of interest\n        const matchTimes = line.match(\n          /([0-9]{2})?:?([0-9]{2}):([0-9]{2}).([0-9]{2,3})( ?--> ?)([0-9]{2})?:?([0-9]{2}):([0-9]{2}).([0-9]{2,3})/,\n        ); // Note that this currently ignores caption formatting directives that are optionally on the end of this line - fine for non-captions VTT\n\n        if (matchTimes) {\n          result.startTime =\n            Number(matchTimes[1] || 0) * 60 * 60 +\n            Number(matchTimes[2]) * 60 +\n            Number(matchTimes[3]) +\n            Number(`0.${matchTimes[4]}`);\n          result.endTime =\n            Number(matchTimes[6] || 0) * 60 * 60 +\n            Number(matchTimes[7]) * 60 +\n            Number(matchTimes[8]) +\n            Number(`0.${matchTimes[9]}`);\n        }\n      } else if (!is.empty(line.trim()) && is.empty(result.text)) {\n        // If we already have the startTime, then we're definitely up to the text line(s)\n        const lineSplit = line.trim().split('#xywh=');\n        [result.text] = lineSplit;\n\n        // If there's content in lineSplit[1], then we have sprites. If not, then it's just one frame per image\n        if (lineSplit[1]) {\n          [result.x, result.y, result.w, result.h] = lineSplit[1].split(',');\n        }\n      }\n    });\n\n    if (result.text) {\n      processedList.push(result);\n    }\n  });\n\n  return processedList;\n};\n\nconst fitRatio = (ratio, outer) => {\n  const targetRatio = outer.width / outer.height;\n  const result = {};\n  if (ratio > targetRatio) {\n    result.width = outer.width;\n    result.height = (1 / ratio) * outer.width;\n  } else {\n    result.height = outer.height;\n    result.width = ratio * outer.height;\n  }\n\n  return result;\n};\n\nclass PreviewThumbnails {\n  /**\n   * PreviewThumbnails constructor.\n   * @param {wassPlayer} player\n   * @return {PreviewThumbnails}\n   */\n  constructor(player) {\n    this.player = player;\n    this.thumbnails = [];\n    this.loaded = false;\n    this.lastMouseMoveTime = Date.now();\n    this.mouseDown = false;\n    this.loadedImages = [];\n\n    this.elements = {\n      thumb: {},\n      scrubbing: {},\n    };\n\n    this.load();\n  }\n\n  get enabled() {\n    return this.player.isHTML5 && this.player.isVideo && this.player.config.previewThumbnails.enabled;\n  }\n\n  load() {\n    // Toggle the regular seek tooltip\n    if (this.player.elements.display.seekTooltip) {\n      this.player.elements.display.seekTooltip.hidden = this.enabled;\n    }\n\n    if (!this.enabled) {\n      return;\n    }\n\n    this.getThumbnails().then(() => {\n      if (!this.enabled) {\n        return;\n      }\n\n      // Render DOM elements\n      this.render();\n\n      // Check to see if thumb container size was specified manually in CSS\n      this.determineContainerAutoSizing();\n\n      this.loaded = true;\n    });\n  }\n\n  // Download VTT files and parse them\n  getThumbnails() {\n    return new Promise(resolve => {\n      const { src } = this.player.config.previewThumbnails;\n\n      if (is.empty(src)) {\n        throw new Error('Missing previewThumbnails.src config attribute');\n      }\n\n      // Resolve promise\n      const sortAndResolve = () => {\n        // Sort smallest to biggest (e.g., [120p, 480p, 1080p])\n        this.thumbnails.sort((x, y) => x.height - y.height);\n\n        this.player.debug.log('Preview thumbnails', this.thumbnails);\n\n        resolve();\n      };\n\n      // Via callback()\n      if (is.function(src)) {\n        src(thumbnails => {\n          this.thumbnails = thumbnails;\n          sortAndResolve();\n        });\n      }\n      // VTT urls\n      else {\n        // If string, convert into single-element list\n        const urls = is.string(src) ? [src] : src;\n        // Loop through each src URL. Download and process the VTT file, storing the resulting data in this.thumbnails\n        const promises = urls.map(u => this.getThumbnail(u));\n        // Resolve\n        Promise.all(promises).then(sortAndResolve);\n      }\n    });\n  }\n\n  // Process individual VTT file\n  getThumbnail(url) {\n    return new Promise(resolve => {\n      fetch(url).then(response => {\n        const thumbnail = {\n          frames: parseVtt(response),\n          height: null,\n          urlPrefix: '',\n        };\n\n        if (\n          !thumbnail.frames[0].text.startsWith('/') &&\n          !thumbnail.frames[0].text.startsWith('http://') &&\n          !thumbnail.frames[0].text.startsWith('https://')\n        ) {\n          thumbnail.urlPrefix = url.substring(0, url.lastIndexOf('/') + 1);\n        }\n\n        // Download the first frame, so that we can determine/set the height of this thumbnailsDef\n        const tempImage = new Image();\n\n        tempImage.onload = () => {\n          thumbnail.height = tempImage.naturalHeight;\n          thumbnail.width = tempImage.naturalWidth;\n\n          this.thumbnails.push(thumbnail);\n\n          resolve();\n        };\n\n        tempImage.src = thumbnail.urlPrefix + thumbnail.frames[0].text;\n      });\n    });\n  }\n\n  startMove(event) {\n    if (!this.loaded) {\n      return;\n    }\n\n    if (!is.event(event) || !['touchmove', 'mousemove'].includes(event.type)) {\n      return;\n    }\n\n    // Wait until media has a duration\n    if (!this.player.media.duration) {\n      return;\n    }\n\n    if (event.type === 'touchmove') {\n      // Calculate seek hover position as approx video seconds\n      this.seekTime = this.player.media.duration * (this.player.elements.inputs.seek.value / 100);\n    } else {\n      // Calculate seek hover position as approx video seconds\n      const clientRect = this.player.elements.progress.getBoundingClientRect();\n      const percentage = (100 / clientRect.width) * (event.pageX - clientRect.left);\n      this.seekTime = this.player.media.duration * (percentage / 100);\n\n      if (this.seekTime < 0) {\n        // The mousemove fires for 10+px out to the left\n        this.seekTime = 0;\n      }\n\n      if (this.seekTime > this.player.media.duration - 1) {\n        // Took 1 second off the duration for safety, because different players can disagree on the real duration of a video\n        this.seekTime = this.player.media.duration - 1;\n      }\n\n      this.mousePosX = event.pageX;\n\n      // Set time text inside image container\n      this.elements.thumb.time.innerText = formatTime(this.seekTime);\n    }\n\n    // Download and show image\n    this.showImageAtCurrentTime();\n  }\n\n  endMove() {\n    this.toggleThumbContainer(false, true);\n  }\n\n  startScrubbing(event) {\n    // Only act on left mouse button (0), or touch device (event.button does not exist or is false)\n    if (is.nullOrUndefined(event.button) || event.button === false || event.button === 0) {\n      this.mouseDown = true;\n\n      // Wait until media has a duration\n      if (this.player.media.duration) {\n        this.toggleScrubbingContainer(true);\n        this.toggleThumbContainer(false, true);\n\n        // Download and show image\n        this.showImageAtCurrentTime();\n      }\n    }\n  }\n\n  endScrubbing() {\n    this.mouseDown = false;\n\n    // Hide scrubbing preview. But wait until the video has successfully seeked before hiding the scrubbing preview\n    if (Math.ceil(this.lastTime) === Math.ceil(this.player.media.currentTime)) {\n      // The video was already seeked/loaded at the chosen time - hide immediately\n      this.toggleScrubbingContainer(false);\n    } else {\n      // The video hasn't seeked yet. Wait for that\n      once.call(this.player, this.player.media, 'timeupdate', () => {\n        // Re-check mousedown - we might have already started scrubbing again\n        if (!this.mouseDown) {\n          this.toggleScrubbingContainer(false);\n        }\n      });\n    }\n  }\n\n  /**\n   * Setup hooks for wassPlayer and window events\n   */\n  listeners() {\n    this.player.on('play', () => {\n      this.toggleThumbContainer(false, true);\n    });\n\n    this.player.on('seeked', () => {\n      this.toggleThumbContainer(false);\n    });\n\n    this.player.on('timeupdate', () => {\n      this.lastTime = this.player.media.currentTime;\n    });\n  }\n\n  /**\n   * Create HTML elements for image containers\n   */\n  render() {\n    // Create HTML element: wassPlayer__preview-thumbnail-container\n    this.elements.thumb.container = createElement('div', {\n      class: this.player.config.classNames.previewThumbnails.thumbContainer,\n    });\n\n    // Wrapper for the image for styling\n    this.elements.thumb.imageContainer = createElement('div', {\n      class: this.player.config.classNames.previewThumbnails.imageContainer,\n    });\n    this.elements.thumb.container.appendChild(this.elements.thumb.imageContainer);\n\n    // Create HTML element, parent+span: time text (e.g., 01:32:00)\n    const timeContainer = createElement('div', {\n      class: this.player.config.classNames.previewThumbnails.timeContainer,\n    });\n\n    this.elements.thumb.time = createElement('span', {}, '00:00');\n    timeContainer.appendChild(this.elements.thumb.time);\n\n    this.elements.thumb.container.appendChild(timeContainer);\n\n    // Inject the whole thumb\n    if (is.element(this.player.elements.progress)) {\n      this.player.elements.progress.appendChild(this.elements.thumb.container);\n    }\n\n    // Create HTML element: wassPlayer__preview-scrubbing-container\n    this.elements.scrubbing.container = createElement('div', {\n      class: this.player.config.classNames.previewThumbnails.scrubbingContainer,\n    });\n\n    this.player.elements.wrapper.appendChild(this.elements.scrubbing.container);\n  }\n\n  destroy() {\n    if (this.elements.thumb.container) {\n      this.elements.thumb.container.remove();\n    }\n    if (this.elements.scrubbing.container) {\n      this.elements.scrubbing.container.remove();\n    }\n  }\n\n  showImageAtCurrentTime() {\n    if (this.mouseDown) {\n      this.setScrubbingContainerSize();\n    } else {\n      this.setThumbContainerSizeAndPos();\n    }\n\n    // Find the desired thumbnail index\n    const thumbNum = this.thumbnails[0].frames.findIndex(\n      frame => this.seekTime >= frame.startTime && this.seekTime <= frame.endTime,\n    );\n    const hasThumb = thumbNum >= 0;\n    let qualityIndex = 0;\n\n    // Show the thumb container if we're not scrubbing\n    if (!this.mouseDown) {\n      this.toggleThumbContainer(hasThumb);\n    }\n\n    // No matching thumb found\n    if (!hasThumb) {\n      return;\n    }\n\n    // Check to see if we've already downloaded higher quality versions of this image\n    this.thumbnails.forEach((thumbnail, index) => {\n      if (this.loadedImages.includes(thumbnail.frames[thumbNum].text)) {\n        qualityIndex = index;\n      }\n    });\n\n    // Only proceed if either thumbnum or thumbfilename has changed\n    if (thumbNum !== this.showingThumb) {\n      this.showingThumb = thumbNum;\n      this.loadImage(qualityIndex);\n    }\n  }\n\n  // Show the image that's currently specified in this.showingThumb\n  loadImage(qualityIndex = 0) {\n    const thumbNum = this.showingThumb;\n    const thumbnail = this.thumbnails[qualityIndex];\n    const { urlPrefix } = thumbnail;\n    const frame = thumbnail.frames[thumbNum];\n    const thumbFilename = thumbnail.frames[thumbNum].text;\n    const thumbUrl = urlPrefix + thumbFilename;\n\n    if (!this.currentImageElement || this.currentImageElement.dataset.filename !== thumbFilename) {\n      if (this.loadingImage && this.usingSprites) {\n        this.loadingImage.onload = null;\n      }\n\n      const previewImage = new Image();\n      previewImage.src = thumbUrl;\n      previewImage.dataset.index = thumbNum;\n      previewImage.dataset.filename = thumbFilename;\n      this.showingThumbFilename = thumbFilename;\n\n      this.player.debug.log(`Loading image: ${thumbUrl}`);\n\n      // For some reason, passing the named function directly causes it to execute immediately. So I've wrapped it in an anonymous function...\n      previewImage.onload = () => this.showImage(previewImage, frame, qualityIndex, thumbNum, thumbFilename, true);\n      this.loadingImage = previewImage;\n      this.removeOldImages(previewImage);\n    } else {\n      // Update the existing image\n      this.showImage(this.currentImageElement, frame, qualityIndex, thumbNum, thumbFilename, false);\n      this.currentImageElement.dataset.index = thumbNum;\n      this.removeOldImages(this.currentImageElement);\n    }\n  }\n\n  showImage(previewImage, frame, qualityIndex, thumbNum, thumbFilename, newImage = true) {\n    this.player.debug.log(\n      `Showing thumb: ${thumbFilename}. num: ${thumbNum}. qual: ${qualityIndex}. newimg: ${newImage}`,\n    );\n    this.setImageSizeAndOffset(previewImage, frame);\n\n    if (newImage) {\n      this.currentImageContainer.appendChild(previewImage);\n      this.currentImageElement = previewImage;\n\n      if (!this.loadedImages.includes(thumbFilename)) {\n        this.loadedImages.push(thumbFilename);\n      }\n    }\n\n    this.preloadNearby(thumbNum, true)\n      .then(this.preloadNearby(thumbNum, false))\n      .then(this.getHigherQuality(qualityIndex, previewImage, frame, thumbFilename));\n  }\n\n  // Remove all preview images that aren't the designated current image\n  removeOldImages(currentImage) {\n    // Get a list of all images, convert it from a DOM list to an array\n    Array.from(this.currentImageContainer.children).forEach(image => {\n      if (image.tagName.toLowerCase() !== 'img') {\n        return;\n      }\n\n      const removeDelay = this.usingSprites ? 500 : 1000;\n\n      if (image.dataset.index !== currentImage.dataset.index && !image.dataset.deleting) {\n        // eslint-disable-next-line no-param-reassign\n        image.dataset.deleting = true;\n\n        // This has to be set before the timeout - to prevent issues switching between hover and scrub\n        const { currentImageContainer } = this;\n\n        setTimeout(() => {\n          currentImageContainer.removeChild(image);\n          this.player.debug.log(`Removing thumb: ${image.dataset.filename}`);\n        }, removeDelay);\n      }\n    });\n  }\n\n  // Preload images before and after the current one. Only if the user is still hovering/seeking the same frame\n  // This will only preload the lowest quality\n  preloadNearby(thumbNum, forward = true) {\n    return new Promise(resolve => {\n      setTimeout(() => {\n        const oldThumbFilename = this.thumbnails[0].frames[thumbNum].text;\n\n        if (this.showingThumbFilename === oldThumbFilename) {\n          // Find the nearest thumbs with different filenames. Sometimes it'll be the next index, but in the case of sprites, it might be 100+ away\n          let thumbnailsClone;\n          if (forward) {\n            thumbnailsClone = this.thumbnails[0].frames.slice(thumbNum);\n          } else {\n            thumbnailsClone = this.thumbnails[0].frames.slice(0, thumbNum).reverse();\n          }\n\n          let foundOne = false;\n\n          thumbnailsClone.forEach(frame => {\n            const newThumbFilename = frame.text;\n\n            if (newThumbFilename !== oldThumbFilename) {\n              // Found one with a different filename. Make sure it hasn't already been loaded on this page visit\n              if (!this.loadedImages.includes(newThumbFilename)) {\n                foundOne = true;\n                this.player.debug.log(`Preloading thumb filename: ${newThumbFilename}`);\n\n                const { urlPrefix } = this.thumbnails[0];\n                const thumbURL = urlPrefix + newThumbFilename;\n                const previewImage = new Image();\n                previewImage.src = thumbURL;\n                previewImage.onload = () => {\n                  this.player.debug.log(`Preloaded thumb filename: ${newThumbFilename}`);\n                  if (!this.loadedImages.includes(newThumbFilename)) this.loadedImages.push(newThumbFilename);\n\n                  // We don't resolve until the thumb is loaded\n                  resolve();\n                };\n              }\n            }\n          });\n\n          // If there are none to preload then we want to resolve immediately\n          if (!foundOne) {\n            resolve();\n          }\n        }\n      }, 300);\n    });\n  }\n\n  // If user has been hovering current image for half a second, look for a higher quality one\n  getHigherQuality(currentQualityIndex, previewImage, frame, thumbFilename) {\n    if (currentQualityIndex < this.thumbnails.length - 1) {\n      // Only use the higher quality version if it's going to look any better - if the current thumb is of a lower pixel density than the thumbnail container\n      let previewImageHeight = previewImage.naturalHeight;\n\n      if (this.usingSprites) {\n        previewImageHeight = frame.h;\n      }\n\n      if (previewImageHeight < this.thumbContainerHeight) {\n        // Recurse back to the loadImage function - show a higher quality one, but only if the viewer is on this frame for a while\n        setTimeout(() => {\n          // Make sure the mouse hasn't already moved on and started hovering at another image\n          if (this.showingThumbFilename === thumbFilename) {\n            this.player.debug.log(`Showing higher quality thumb for: ${thumbFilename}`);\n            this.loadImage(currentQualityIndex + 1);\n          }\n        }, 300);\n      }\n    }\n  }\n\n  get currentImageContainer() {\n    if (this.mouseDown) {\n      return this.elements.scrubbing.container;\n    }\n\n    return this.elements.thumb.imageContainer;\n  }\n\n  get usingSprites() {\n    return Object.keys(this.thumbnails[0].frames[0]).includes('w');\n  }\n\n  get thumbAspectRatio() {\n    if (this.usingSprites) {\n      return this.thumbnails[0].frames[0].w / this.thumbnails[0].frames[0].h;\n    }\n\n    return this.thumbnails[0].width / this.thumbnails[0].height;\n  }\n\n  get thumbContainerHeight() {\n    if (this.mouseDown) {\n      const { height } = fitRatio(this.thumbAspectRatio, {\n        width: this.player.media.clientWidth,\n        height: this.player.media.clientHeight,\n      });\n      return height;\n    }\n\n    // If css is used this needs to return the css height for sprites to work (see setImageSizeAndOffset)\n    if (this.sizeSpecifiedInCSS) {\n      return this.elements.thumb.imageContainer.clientHeight;\n    }\n\n    return Math.floor(this.player.media.clientWidth / this.thumbAspectRatio / 4);\n  }\n\n  get currentImageElement() {\n    if (this.mouseDown) {\n      return this.currentScrubbingImageElement;\n    }\n\n    return this.currentThumbnailImageElement;\n  }\n\n  set currentImageElement(element) {\n    if (this.mouseDown) {\n      this.currentScrubbingImageElement = element;\n    } else {\n      this.currentThumbnailImageElement = element;\n    }\n  }\n\n  toggleThumbContainer(toggle = false, clearShowing = false) {\n    const className = this.player.config.classNames.previewThumbnails.thumbContainerShown;\n    this.elements.thumb.container.classList.toggle(className, toggle);\n\n    if (!toggle && clearShowing) {\n      this.showingThumb = null;\n      this.showingThumbFilename = null;\n    }\n  }\n\n  toggleScrubbingContainer(toggle = false) {\n    const className = this.player.config.classNames.previewThumbnails.scrubbingContainerShown;\n    this.elements.scrubbing.container.classList.toggle(className, toggle);\n\n    if (!toggle) {\n      this.showingThumb = null;\n      this.showingThumbFilename = null;\n    }\n  }\n\n  determineContainerAutoSizing() {\n    if (this.elements.thumb.imageContainer.clientHeight > 20 || this.elements.thumb.imageContainer.clientWidth > 20) {\n      // This will prevent auto sizing in this.setThumbContainerSizeAndPos()\n      this.sizeSpecifiedInCSS = true;\n    }\n  }\n\n  // Set the size to be about a quarter of the size of video. Unless option dynamicSize === false, in which case it needs to be set in CSS\n  setThumbContainerSizeAndPos() {\n    if (!this.sizeSpecifiedInCSS) {\n      const thumbWidth = Math.floor(this.thumbContainerHeight * this.thumbAspectRatio);\n      this.elements.thumb.imageContainer.style.height = `${this.thumbContainerHeight}px`;\n      this.elements.thumb.imageContainer.style.width = `${thumbWidth}px`;\n    } else if (\n      this.elements.thumb.imageContainer.clientHeight > 20 &&\n      this.elements.thumb.imageContainer.clientWidth < 20\n    ) {\n      const thumbWidth = Math.floor(this.elements.thumb.imageContainer.clientHeight * this.thumbAspectRatio);\n      this.elements.thumb.imageContainer.style.width = `${thumbWidth}px`;\n    } else if (\n      this.elements.thumb.imageContainer.clientHeight < 20 &&\n      this.elements.thumb.imageContainer.clientWidth > 20\n    ) {\n      const thumbHeight = Math.floor(this.elements.thumb.imageContainer.clientWidth / this.thumbAspectRatio);\n      this.elements.thumb.imageContainer.style.height = `${thumbHeight}px`;\n    }\n\n    this.setThumbContainerPos();\n  }\n\n  setThumbContainerPos() {\n    const seekbarRect = this.player.elements.progress.getBoundingClientRect();\n    const wassPlayerRect = this.player.elements.container.getBoundingClientRect();\n    const { container } = this.elements.thumb;\n    // Find the lowest and highest desired left-position, so we don't slide out the side of the video container\n    const minVal = wassPlayerRect.left - seekbarRect.left + 10;\n    const maxVal = wassPlayerRect.right - seekbarRect.left - container.clientWidth - 10;\n    // Set preview container position to: mousepos, minus seekbar.left, minus half of previewContainer.clientWidth\n    let previewPos = this.mousePosX - seekbarRect.left - container.clientWidth / 2;\n\n    if (previewPos < minVal) {\n      previewPos = minVal;\n    }\n\n    if (previewPos > maxVal) {\n      previewPos = maxVal;\n    }\n\n    container.style.left = `${previewPos}px`;\n  }\n\n  // Can't use 100% width, in case the video is a different aspect ratio to the video container\n  setScrubbingContainerSize() {\n    const { width, height } = fitRatio(this.thumbAspectRatio, {\n      width: this.player.media.clientWidth,\n      height: this.player.media.clientHeight,\n    });\n    this.elements.scrubbing.container.style.width = `${width}px`;\n    this.elements.scrubbing.container.style.height = `${height}px`;\n  }\n\n  // Sprites need to be offset to the correct location\n  setImageSizeAndOffset(previewImage, frame) {\n    if (!this.usingSprites) {\n      return;\n    }\n\n    // Find difference between height and preview container height\n    const multiplier = this.thumbContainerHeight / frame.h;\n\n    // eslint-disable-next-line no-param-reassign\n    previewImage.style.height = `${previewImage.naturalHeight * multiplier}px`;\n    // eslint-disable-next-line no-param-reassign\n    previewImage.style.width = `${previewImage.naturalWidth * multiplier}px`;\n    // eslint-disable-next-line no-param-reassign\n    previewImage.style.left = `-${frame.x * multiplier}px`;\n    // eslint-disable-next-line no-param-reassign\n    previewImage.style.top = `-${frame.y * multiplier}px`;\n  }\n}\n\nexport default PreviewThumbnails;\n","// ==========================================================================\n// WassPlayer source update\n// ==========================================================================\n\nimport { providers } from './config/types';\nimport html5 from './html5';\nimport media from './media';\nimport PreviewThumbnails from './plugins/preview-thumbnails';\nimport support from './support';\nimport ui from './ui';\nimport { createElement, insertElement, removeElement } from './utils/elements';\nimport is from './utils/is';\nimport { getDeep } from './utils/objects';\n\nconst source = {\n  // Add elements to HTML5 media (source, tracks, etc)\n  insertElements(type, attributes) {\n    if (is.string(attributes)) {\n      insertElement(type, this.media, {\n        src: attributes,\n      });\n    } else if (is.array(attributes)) {\n      attributes.forEach(attribute => {\n        insertElement(type, this.media, attribute);\n      });\n    }\n  },\n\n  // Update source\n  // Sources are not checked for support so be careful\n  change(input) {\n    if (!getDeep(input, 'sources.length')) {\n      this.debug.warn('Invalid source format');\n      return;\n    }\n\n    // Cancel current network requests\n    html5.cancelRequests.call(this);\n\n    // Destroy instance and re-setup\n    this.destroy.call(\n      this,\n      () => {\n        // Reset quality options\n        this.options.quality = [];\n\n        // Remove elements\n        removeElement(this.media);\n        this.media = null;\n\n        // Reset class name\n        if (is.element(this.elements.container)) {\n          this.elements.container.removeAttribute('class');\n        }\n\n        // Set the type and provider\n        const { sources, type } = input;\n        const [{ provider = providers.html5, src }] = sources;\n        const tagName = provider === 'html5' ? type : 'div';\n        const attributes = provider === 'html5' ? {} : { src };\n\n        Object.assign(this, {\n          provider,\n          type,\n          // Check for support\n          supported: support.check(type, provider, this.config.playsinline),\n          // Create new element\n          media: createElement(tagName, attributes),\n        });\n\n        // Inject the new element\n        this.elements.container.appendChild(this.media);\n\n        // Autoplay the new source?\n        if (is.boolean(input.autoplay)) {\n          this.config.autoplay = input.autoplay;\n        }\n\n        // Set attributes for audio and video\n        if (this.isHTML5) {\n          if (this.config.crossorigin) {\n            this.media.setAttribute('crossorigin', '');\n          }\n          if (this.config.autoplay) {\n            this.media.setAttribute('autoplay', '');\n          }\n          if (!is.empty(input.poster)) {\n            this.poster = input.poster;\n          }\n          if (this.config.loop.active) {\n            this.media.setAttribute('loop', '');\n          }\n          if (this.config.muted) {\n            this.media.setAttribute('muted', '');\n          }\n          if (this.config.playsinline) {\n            this.media.setAttribute('playsinline', '');\n          }\n        }\n\n        // Restore class hook\n        ui.addStyleHook.call(this);\n\n        // Set new sources for html5\n        if (this.isHTML5) {\n          source.insertElements.call(this, 'source', sources);\n        }\n\n        // Set video title\n        this.config.title = input.title;\n\n        // Set up from scratch\n        media.setup.call(this);\n\n        // HTML5 stuff\n        if (this.isHTML5) {\n          // Setup captions\n          if (Object.keys(input).includes('tracks')) {\n            source.insertElements.call(this, 'track', input.tracks);\n          }\n        }\n\n        // If HTML5 or embed but not fully supported, setupInterface and call ready now\n        if (this.isHTML5 || (this.isEmbed && !this.supported.ui)) {\n          // Setup interface\n          ui.build.call(this);\n        }\n\n        // Load HTML5 sources\n        if (this.isHTML5) {\n          this.media.load();\n        }\n\n        // Update previewThumbnails config & reload plugin\n        if (!is.empty(input.previewThumbnails)) {\n          Object.assign(this.config.previewThumbnails, input.previewThumbnails);\n\n          // Cleanup previewThumbnails plugin if it was loaded\n          if (this.previewThumbnails && this.previewThumbnails.loaded) {\n            this.previewThumbnails.destroy();\n            this.previewThumbnails = null;\n          }\n\n          // Create new instance if it is still enabled\n          if (this.config.previewThumbnails.enabled) {\n            this.previewThumbnails = new PreviewThumbnails(this);\n          }\n        }\n\n        // Update the fullscreen support\n        this.fullscreen.update();\n      },\n      true,\n    );\n  },\n};\n\nexport default source;\n","// ==========================================================================\n// WassPlayer\n// WassPlayer.js v3.6.2\n// https://github.com/sampotts/WassPlayer\n// License: The MIT License (MIT)\n// ==========================================================================\n\nimport captions from './captions';\nimport defaults from './config/defaults';\nimport { pip } from './config/states';\nimport { getProviderByUrl, providers, types } from './config/types';\nimport Console from './console';\nimport controls from './controls';\nimport Fullscreen from './fullscreen';\nimport Listeners from './listeners';\nimport media from './media';\nimport PreviewThumbnails from './plugins/preview-thumbnails';\nimport source from './source';\nimport Storage from './storage';\nimport support from './support';\nimport ui from './ui';\nimport { closest } from './utils/arrays';\nimport { createElement, hasClass, removeElement, replaceElement, toggleClass, wrap } from './utils/elements';\nimport { off, on, once, triggerEvent, unbindListeners } from './utils/events';\nimport is from './utils/is';\nimport loadSprite from './utils/load-sprite';\nimport { clamp } from './utils/numbers';\nimport { cloneDeep, extend } from './utils/objects';\nimport { silencePromise } from './utils/promise';\nimport { getAspectRatio, reduceAspectRatio, setAspectRatio, validateRatio } from './utils/style';\nimport { parseUrl } from './utils/urls';\n\n// WassPlayer instance\nclass WassPlayer {\n  constructor(target, options) {\n    this.timers = {};\n\n    // State\n    this.ready = false;\n    this.loading = false;\n    this.failed = false;\n\n    // Touch device\n    this.touch = support.touch;\n\n    // Set the media element\n    this.media = target;\n\n    // String selector passed\n    if (is.string(this.media)) {\n      this.media = document.querySelectorAll(this.media);\n    }\n\n    // jQuery, NodeList or Array passed, use first element\n    if ((window.jQuery && this.media instanceof jQuery) || is.nodeList(this.media) || is.array(this.media)) {\n      // eslint-disable-next-line\n      this.media = this.media[0];\n    }\n\n    // Set config\n    this.config = extend(\n      {},\n      defaults,\n      WassPlayer.defaults,\n      options || {},\n      (() => {\n        try {\n          return JSON.parse(this.media.getAttribute('data-wassPlayer-config'));\n        } catch (e) {\n          return {};\n        }\n      })(),\n    );\n\n    // Elements cache\n    this.elements = {\n      container: null,\n      fullscreen: null,\n      captions: null,\n      buttons: {},\n      display: {},\n      progress: {},\n      inputs: {},\n      settings: {\n        popup: null,\n        menu: null,\n        panels: {},\n        buttons: {},\n      },\n    };\n\n    // Captions\n    this.captions = {\n      active: null,\n      currentTrack: -1,\n      meta: new WeakMap(),\n    };\n\n    // Fullscreen\n    this.fullscreen = {\n      active: false,\n    };\n\n    // Options\n    this.options = {\n      speed: [],\n      quality: [],\n    };\n\n    // Debugging\n    // TODO: move to globals\n    this.debug = new Console(this.config.debug);\n\n    // Log config options and support\n    this.debug.log('Config', this.config);\n    this.debug.log('Support', support);\n\n    // We need an element to setup\n    if (is.nullOrUndefined(this.media) || !is.element(this.media)) {\n      this.debug.error('Setup failed: no suitable element passed');\n      return;\n    }\n\n    // Bail if the element is initialized\n    if (this.media.wassPlayer) {\n      this.debug.warn('Target already setup');\n      return;\n    }\n\n    // Bail if not enabled\n    if (!this.config.enabled) {\n      this.debug.error('Setup failed: disabled by config');\n      return;\n    }\n\n    // Bail if disabled or no basic support\n    // You may want to disable certain UAs etc\n    if (!support.check().api) {\n      this.debug.error('Setup failed: no support');\n      return;\n    }\n\n    // Cache original element state for .destroy()\n    const clone = this.media.cloneNode(true);\n    clone.autoplay = false;\n    this.elements.original = clone;\n\n    // Set media type based on tag or data attribute\n    // Supported: video\n    const type = this.media.tagName.toLowerCase();\n    // Embed properties\n    let iframe = null;\n    let url = null;\n\n    // Different setup based on type\n    switch (type) {\n      case 'div':\n        // Find the frame\n        iframe = this.media.querySelector('iframe');\n\n        // <iframe> type\n        if (is.element(iframe)) {\n          // Detect provider\n          url = parseUrl(iframe.getAttribute('src'));\n          this.provider = getProviderByUrl(url.toString());\n\n          // Rework elements\n          this.elements.container = this.media;\n          this.media = iframe;\n\n          // Reset classname\n          this.elements.container.className = '';\n\n          // Get attributes from URL and set config\n          if (url.search.length) {\n            const truthy = ['1', 'true'];\n\n            if (truthy.includes(url.searchParams.get('autoplay'))) {\n              this.config.autoplay = true;\n            }\n            if (truthy.includes(url.searchParams.get('loop'))) {\n              this.config.loop.active = true;\n            }\n\n            this.config.playsinline = true;\n          }\n        } else {\n          // <div> with attributes\n          this.provider = this.media.getAttribute(this.config.attributes.embed.provider);\n\n          // Remove attribute\n          this.media.removeAttribute(this.config.attributes.embed.provider);\n        }\n\n        // Unsupported or missing provider\n        if (is.empty(this.provider) || !Object.keys(providers).includes(this.provider)) {\n          this.debug.error('Setup failed: Invalid provider');\n          return;\n        }\n\n        // Audio will come later for external providers\n        this.type = types.video;\n\n        break;\n\n      case 'video':\n      case 'audio':\n        this.type = type;\n        this.provider = providers.html5;\n\n        // Get config from attributes\n        if (this.media.hasAttribute('crossorigin')) {\n          this.config.crossorigin = true;\n        }\n        if (this.media.hasAttribute('autoplay')) {\n          this.config.autoplay = true;\n        }\n        if (this.media.hasAttribute('playsinline') || this.media.hasAttribute('webkit-playsinline')) {\n          this.config.playsinline = true;\n        }\n        if (this.media.hasAttribute('muted')) {\n          this.config.muted = true;\n        }\n        if (this.media.hasAttribute('loop')) {\n          this.config.loop.active = true;\n        }\n\n        break;\n\n      default:\n        this.debug.error('Setup failed: unsupported type');\n        return;\n    }\n\n    // Check for support again but with type\n    this.supported = support.check(this.type, this.provider, this.config.playsinline);\n\n    // If no support for even API, bail\n    if (!this.supported.api) {\n      this.debug.error('Setup failed: no support');\n      return;\n    }\n\n    this.eventListeners = [];\n\n    // Create listeners\n    this.listeners = new Listeners(this);\n\n    // Setup local storage for user settings\n    this.storage = new Storage(this);\n\n    // Store reference\n    this.media.wassPlayer = this;\n\n    // Wrap media\n    if (!is.element(this.elements.container)) {\n      this.elements.container = createElement('div', { tabindex: 0 });\n      wrap(this.media, this.elements.container);\n    }\n\n    // Migrate custom properties from media to container (so they work )\n    ui.migrateStyles.call(this);\n\n    // Add style hook\n    ui.addStyleHook.call(this);\n\n    // Setup media\n    media.setup.call(this);\n\n    // Listen for events if debugging\n    if (this.config.debug) {\n      on.call(this, this.elements.container, this.config.events.join(' '), event => {\n        this.debug.log(`event: ${event.type}`);\n      });\n    }\n\n    // Setup fullscreen\n    this.fullscreen = new Fullscreen(this);\n\n    // Setup interface\n    // If embed but not fully supported, build interface now to avoid flash of controls\n    if (this.isHTML5 || (this.isEmbed && !this.supported.ui)) {\n      ui.build.call(this);\n    }\n\n    // Container listeners\n    this.listeners.container();\n\n    // Global listeners\n    this.listeners.global();\n\n    // Autoplay if required\n    if (this.isHTML5 && this.config.autoplay) {\n      setTimeout(() => silencePromise(this.play()), 10);\n    }\n\n    // Seek time will be recorded (in listeners.js) so we can prevent hiding controls for a few seconds after seek\n    this.lastSeekTime = 0;\n\n    // Setup preview thumbnails if enabled\n    if (this.config.previewThumbnails.enabled) {\n      this.previewThumbnails = new PreviewThumbnails(this);\n    }\n  }\n\n  // ---------------------------------------\n  // API\n  // ---------------------------------------\n\n  /**\n   * Types and provider helpers\n   */\n  get isHTML5() {\n    return this.provider === providers.html5;\n  }\n\n  get isVideo() {\n    return this.type === types.video;\n  }\n\n  /**\n   * Play the media, or play the advertisement (if they are not blocked)\n   */\n  play() {\n    if (!is.function(this.media.play)) {\n      return null;\n    }\n\n    // Return the promise (for HTML5)\n    return this.media.play();\n  }\n\n  /**\n   * Pause the media\n   */\n  pause() {\n    if (!this.playing || !is.function(this.media.pause)) {\n      return null;\n    }\n\n    return this.media.pause();\n  }\n\n  /**\n   * Get playing state\n   */\n  get playing() {\n    return Boolean(this.ready && !this.paused && !this.ended);\n  }\n\n  /**\n   * Get paused state\n   */\n  get paused() {\n    return Boolean(this.media.paused);\n  }\n\n  /**\n   * Get stopped state\n   */\n  get stopped() {\n    return Boolean(this.paused && this.currentTime === 0);\n  }\n\n  /**\n   * Get ended state\n   */\n  get ended() {\n    return Boolean(this.media.ended);\n  }\n\n  /**\n   * Toggle playback based on current status\n   * @param {Boolean} input\n   */\n  togglePlay(input) {\n    // Toggle based on current state if nothing passed\n    const toggle = is.boolean(input) ? input : !this.playing;\n\n    if (toggle) {\n      return this.play();\n    }\n\n    return this.pause();\n  }\n\n  /**\n   * Stop playback\n   */\n  stop() {\n    if (this.isHTML5) {\n      this.pause();\n      this.restart();\n    } else if (is.function(this.media.stop)) {\n      this.media.stop();\n    }\n  }\n\n  /**\n   * Restart playback\n   */\n  restart() {\n    this.currentTime = 0;\n  }\n\n  /**\n   * Rewind\n   * @param {Number} seekTime - how far to rewind in seconds. Defaults to the config.seekTime\n   */\n  rewind(seekTime) {\n    this.currentTime -= is.number(seekTime) ? seekTime : this.config.seekTime;\n  }\n\n  /**\n   * Fast forward\n   * @param {Number} seekTime - how far to fast forward in seconds. Defaults to the config.seekTime\n   */\n  forward(seekTime) {\n    this.currentTime += is.number(seekTime) ? seekTime : this.config.seekTime;\n  }\n\n  /**\n   * Seek to a time\n   * @param {Number} input - where to seek to in seconds. Defaults to 0 (the start)\n   */\n  set currentTime(input) {\n    // Bail if media duration isn't available yet\n    if (!this.duration) {\n      return;\n    }\n\n    // Validate input\n    const inputIsValid = is.number(input) && input > 0;\n\n    // Set\n    this.media.currentTime = inputIsValid ? Math.min(input, this.duration) : 0;\n\n    // Logging\n    this.debug.log(`Seeking to ${this.currentTime} seconds`);\n  }\n\n  /**\n   * Get current time\n   */\n  get currentTime() {\n    return Number(this.media.currentTime);\n  }\n\n  /**\n   * Get buffered\n   */\n  get buffered() {\n    const { buffered } = this.media;\n\n    if (is.number(buffered)) {\n      return buffered;\n    }\n\n    // HTML5\n    // (i.e. seek to another section buffers only that section)\n    if (buffered && buffered.length && this.duration > 0) {\n      return buffered.end(0) / this.duration;\n    }\n\n    return 0;\n  }\n\n  /**\n   * Get seeking status\n   */\n  get seeking() {\n    return Boolean(this.media.seeking);\n  }\n\n  /**\n   * Get the duration of the current media\n   */\n  get duration() {\n    // Faux duration set via config\n    const fauxDuration = parseFloat(this.config.duration);\n    // Media duration can be NaN or Infinity before the media has loaded\n    const realDuration = (this.media || {}).duration;\n    const duration = !is.number(realDuration) || realDuration === Infinity ? 0 : realDuration;\n\n    // If config duration is funky, use regular duration\n    return fauxDuration || duration;\n  }\n\n  /**\n   * Set the player volume\n   * @param {Number} value - must be between 0 and 1. Defaults to the value from local storage and config.volume if not set in storage\n   */\n  set volume(value) {\n    let volume = value;\n    const max = 1;\n    const min = 0;\n\n    if (is.string(volume)) {\n      volume = Number(volume);\n    }\n\n    // Load volume from storage if no value specified\n    if (!is.number(volume)) {\n      volume = this.storage.get('volume');\n    }\n\n    // Use config if all else fails\n    if (!is.number(volume)) {\n      ({ volume } = this.config);\n    }\n\n    // Maximum is volumeMax\n    if (volume > max) {\n      volume = max;\n    }\n    // Minimum is volumeMin\n    if (volume < min) {\n      volume = min;\n    }\n\n    // Update config\n    this.config.volume = volume;\n\n    // Set the player volume\n    this.media.volume = volume;\n\n    // If muted, and we're increasing volume manually, reset muted state\n    if (!is.empty(value) && this.muted && volume > 0) {\n      this.muted = false;\n    }\n  }\n\n  /**\n   * Get the current player volume\n   */\n  get volume() {\n    return Number(this.media.volume);\n  }\n\n  /**\n   * Increase volume\n   * @param {Boolean} step - How much to decrease by (between 0 and 1)\n   */\n  increaseVolume(step) {\n    const volume = this.media.muted ? 0 : this.volume;\n    this.volume = volume + (is.number(step) ? step : 0);\n  }\n\n  /**\n   * Decrease volume\n   * @param {Boolean} step - How much to decrease by (between 0 and 1)\n   */\n  decreaseVolume(step) {\n    this.increaseVolume(-step);\n  }\n\n  /**\n   * Set muted state\n   * @param {Boolean} mute\n   */\n  set muted(mute) {\n    let toggle = mute;\n\n    // Load muted state from storage\n    if (!is.boolean(toggle)) {\n      toggle = this.storage.get('muted');\n    }\n\n    // Use config if all else fails\n    if (!is.boolean(toggle)) {\n      toggle = this.config.muted;\n    }\n\n    // Update config\n    this.config.muted = toggle;\n\n    // Set mute on the player\n    this.media.muted = toggle;\n  }\n\n  /**\n   * Get current muted state\n   */\n  get muted() {\n    return Boolean(this.media.muted);\n  }\n\n  /**\n   * Check if the media has audio\n   */\n  get hasAudio() {\n    // Assume yes for all non HTML5 (as we can't tell...)\n    if (!this.isHTML5) {\n      return true;\n    }\n\n    if (this.isAudio) {\n      return true;\n    }\n\n    // Get audio tracks\n    return (\n      Boolean(this.media.mozHasAudio) ||\n      Boolean(this.media.webkitAudioDecodedByteCount) ||\n      Boolean(this.media.audioTracks && this.media.audioTracks.length)\n    );\n  }\n\n  /**\n   * Set playback speed\n   * @param {Number} speed - the speed of playback (0.5-2.0)\n   */\n  set speed(input) {\n    let speed = null;\n\n    if (is.number(input)) {\n      speed = input;\n    }\n\n    if (!is.number(speed)) {\n      speed = this.storage.get('speed');\n    }\n\n    if (!is.number(speed)) {\n      speed = this.config.speed.selected;\n    }\n\n    // Clamp to min/max\n    const { minimumSpeed: min, maximumSpeed: max } = this;\n    speed = clamp(speed, min, max);\n\n    // Update config\n    this.config.speed.selected = speed;\n\n    // Set media speed\n    setTimeout(() => {\n      this.media.playbackRate = speed;\n    }, 0);\n  }\n\n  /**\n   * Get current playback speed\n   */\n  get speed() {\n    return Number(this.media.playbackRate);\n  }\n\n  /**\n   * Get the minimum allowed speed\n   */\n  // eslint-disable-next-line class-methods-use-this\n  get minimumSpeed() {\n    return 0.0625;\n  }\n\n  /**\n   * Get the maximum allowed speed\n   */\n  // eslint-disable-next-line class-methods-use-this\n  get maximumSpeed() {\n    return 16;\n  }\n\n  /**\n   * Set playback quality\n   * Currently HTML5 only\n   * @param {Number} input - Quality level\n   */\n  set quality(input) {\n    const config = this.config.quality;\n    const options = this.options.quality;\n\n    if (!options.length) {\n      return;\n    }\n\n    let quality = [\n      !is.empty(input) && Number(input),\n      this.storage.get('quality'),\n      config.selected,\n      config.default,\n    ].find(is.number);\n\n    let updateStorage = true;\n\n    if (!options.includes(quality)) {\n      const value = closest(options, quality);\n      this.debug.warn(`Unsupported quality option: ${quality}, using ${value} instead`);\n      quality = value;\n\n      // Don't update storage if quality is not supported\n      updateStorage = false;\n    }\n\n    // Update config\n    config.selected = quality;\n\n    // Set quality\n    this.media.quality = quality;\n\n    // Save to storage\n    if (updateStorage) {\n      this.storage.set({ quality });\n    }\n  }\n\n  /**\n   * Get current quality level\n   */\n  get quality() {\n    return this.media.quality;\n  }\n\n  /**\n   * Toggle loop\n   * @param {Boolean} input - Whether to loop or not\n   */\n  set loop(input) {\n    const toggle = is.boolean(input) ? input : this.config.loop.active;\n    this.config.loop.active = toggle;\n    this.media.loop = toggle;\n\n    // Set default to be a true toggle\n    /* const type = ['start', 'end', 'all', 'none', 'toggle'].includes(input) ? input : 'toggle';\n\n        switch (type) {\n            case 'start':\n                if (this.config.loop.end && this.config.loop.end <= this.currentTime) {\n                    this.config.loop.end = null;\n                }\n                this.config.loop.start = this.currentTime;\n                // this.config.loop.indicator.start = this.elements.display.played.value;\n                break;\n\n            case 'end':\n                if (this.config.loop.start >= this.currentTime) {\n                    return this;\n                }\n                this.config.loop.end = this.currentTime;\n                // this.config.loop.indicator.end = this.elements.display.played.value;\n                break;\n\n            case 'all':\n                this.config.loop.start = 0;\n                this.config.loop.end = this.duration - 2;\n                this.config.loop.indicator.start = 0;\n                this.config.loop.indicator.end = 100;\n                break;\n\n            case 'toggle':\n                if (this.config.loop.active) {\n                    this.config.loop.start = 0;\n                    this.config.loop.end = null;\n                } else {\n                    this.config.loop.start = 0;\n                    this.config.loop.end = this.duration - 2;\n                }\n                break;\n\n            default:\n                this.config.loop.start = 0;\n                this.config.loop.end = null;\n                break;\n        } */\n  }\n\n  /**\n   * Get current loop state\n   */\n  get loop() {\n    return Boolean(this.media.loop);\n  }\n\n  /**\n   * Set new media source\n   * @param {Object} input - The new source object (see docs)\n   */\n  set source(input) {\n    source.change.call(this, input);\n  }\n\n  /**\n   * Get current source\n   */\n  get source() {\n    return this.media.currentSrc;\n  }\n\n  /**\n   * Get a download URL (either source or custom)\n   */\n  get download() {\n    const { download } = this.config.urls;\n\n    return is.url(download) ? download : this.source;\n  }\n\n  /**\n   * Set the download URL\n   */\n  set download(input) {\n    if (!is.url(input)) {\n      return;\n    }\n\n    this.config.urls.download = input;\n\n    controls.setDownloadUrl.call(this);\n  }\n\n  /**\n   * Set the poster image for a video\n   * @param {String} input - the URL for the new poster image\n   */\n  set poster(input) {\n    if (!this.isVideo) {\n      this.debug.warn('Poster can only be set for video');\n      return;\n    }\n\n    ui.setPoster.call(this, input, false).catch(() => {});\n  }\n\n  /**\n   * Get the current poster image\n   */\n  get poster() {\n    if (!this.isVideo) {\n      return null;\n    }\n\n    return this.media.getAttribute('poster') || this.media.getAttribute('data-poster');\n  }\n\n  /**\n   * Get the current aspect ratio in use\n   */\n  get ratio() {\n    if (!this.isVideo) {\n      return null;\n    }\n\n    const ratio = reduceAspectRatio(getAspectRatio.call(this));\n\n    return is.array(ratio) ? ratio.join(':') : ratio;\n  }\n\n  /**\n   * Set video aspect ratio\n   */\n  set ratio(input) {\n    if (!this.isVideo) {\n      this.debug.warn('Aspect ratio can only be set for video');\n      return;\n    }\n\n    if (!is.string(input) || !validateRatio(input)) {\n      this.debug.error(`Invalid aspect ratio specified (${input})`);\n      return;\n    }\n\n    this.config.ratio = input;\n\n    setAspectRatio.call(this);\n  }\n\n  /**\n   * Set the autoplay state\n   * @param {Boolean} input - Whether to autoplay or not\n   */\n  set autoplay(input) {\n    const toggle = is.boolean(input) ? input : this.config.autoplay;\n    this.config.autoplay = toggle;\n  }\n\n  /**\n   * Get the current autoplay state\n   */\n  get autoplay() {\n    return Boolean(this.config.autoplay);\n  }\n\n  /**\n   * Toggle captions\n   * @param {Boolean} input - Whether to enable captions\n   */\n  toggleCaptions(input) {\n    captions.toggle.call(this, input, false);\n  }\n\n  /**\n   * Set the caption track by index\n   * @param {Number} - Caption index\n   */\n  set currentTrack(input) {\n    captions.set.call(this, input, false);\n  }\n\n  /**\n   * Get the current caption track index (-1 if disabled)\n   */\n  get currentTrack() {\n    const { toggled, currentTrack } = this.captions;\n    return toggled ? currentTrack : -1;\n  }\n\n  /**\n   * Set the wanted language for captions\n   * Since tracks can be added later it won't update the actual caption track until there is a matching track\n   * @param {String} - Two character ISO language code (e.g. EN, FR, PT, etc)\n   */\n  set language(input) {\n    captions.setLanguage.call(this, input, false);\n  }\n\n  /**\n   * Get the current track's language\n   */\n  get language() {\n    return (captions.getCurrentTrack.call(this) || {}).language;\n  }\n\n  /**\n   * Toggle picture-in-picture playback on WebKit/MacOS\n   */\n  set pip(input) {\n    // Bail if no support\n    if (!support.pip) {\n      return;\n    }\n\n    // Toggle based on current state if not passed\n    const toggle = is.boolean(input) ? input : !this.pip;\n\n    // Toggle based on current state\n    // Safari\n    if (is.function(this.media.webkitSetPresentationMode)) {\n      this.media.webkitSetPresentationMode(toggle ? pip.active : pip.inactive);\n    }\n\n    // Chrome\n    if (is.function(this.media.requestPictureInPicture)) {\n      if (!this.pip && toggle) {\n        this.media.requestPictureInPicture();\n      } else if (this.pip && !toggle) {\n        document.exitPictureInPicture();\n      }\n    }\n  }\n\n  /**\n   * Get the current picture-in-picture state\n   */\n  get pip() {\n    if (!support.pip) {\n      return null;\n    }\n\n    // Safari\n    if (!is.empty(this.media.webkitPresentationMode)) {\n      return this.media.webkitPresentationMode === pip.active;\n    }\n\n    // Chrome\n    return this.media === document.pictureInPictureElement;\n  }\n\n  /**\n   * Trigger the airplay dialog\n   */\n  airplay() {\n    // Show dialog if supported\n    if (support.airplay) {\n      this.media.webkitShowPlaybackTargetPicker();\n    }\n  }\n\n  /**\n   * Toggle the player controls\n   * @param {Boolean} [toggle] - Whether to show the controls\n   */\n  toggleControls(toggle) {\n    // Don't toggle if missing UI support or if it's audio\n    if (this.supported.ui && !this.isAudio) {\n      // Get state before change\n      const isHidden = hasClass(this.elements.container, this.config.classNames.hideControls);\n      // Negate the argument if not undefined since adding the class to hides the controls\n      const force = typeof toggle === 'undefined' ? undefined : !toggle;\n      // Apply and get updated state\n      const hiding = toggleClass(this.elements.container, this.config.classNames.hideControls, force);\n\n      // Close menu\n      if (hiding && is.array(this.config.controls) && this.config.controls.includes('settings') && !is.empty(this.config.settings)) {\n        controls.toggleMenu.call(this, false);\n      }\n\n      // Trigger event on change\n      if (hiding !== isHidden) {\n        const eventName = hiding ? 'controlshidden' : 'controlsshown';\n        triggerEvent.call(this, this.media, eventName);\n      }\n\n      return !hiding;\n    }\n\n    return false;\n  }\n\n  /**\n   * Add event listeners\n   * @param {String} event - Event type\n   * @param {Function} callback - Callback for when event occurs\n   */\n  on(event, callback) {\n    on.call(this, this.elements.container, event, callback);\n  }\n\n  /**\n   * Add event listeners once\n   * @param {String} event - Event type\n   * @param {Function} callback - Callback for when event occurs\n   */\n  once(event, callback) {\n    once.call(this, this.elements.container, event, callback);\n  }\n\n  /**\n   * Remove event listeners\n   * @param {String} event - Event type\n   * @param {Function} callback - Callback for when event occurs\n   */\n  off(event, callback) {\n    off(this.elements.container, event, callback);\n  }\n\n  /**\n   * Destroy an instance\n   * Event listeners are removed when elements are removed\n   * http://stackoverflow.com/questions/12528049/if-a-dom-element-is-removed-are-its-listeners-also-removed-from-memory\n   * @param {Function} callback - Callback for when destroy is complete\n   * @param {Boolean} soft - Whether it's a soft destroy (for source changes etc)\n   */\n  destroy(callback, soft = false) {\n    if (!this.ready) {\n      return;\n    }\n\n    const done = () => {\n      // Reset overflow (incase destroyed while in fullscreen)\n      document.body.style.overflow = '';\n\n      // GC for embed\n      this.embed = null;\n\n      // If it's a soft destroy, make minimal changes\n      if (soft) {\n        if (Object.keys(this.elements).length) {\n          // Remove elements\n          removeElement(this.elements.buttons.play);\n          removeElement(this.elements.captions);\n          removeElement(this.elements.controls);\n          removeElement(this.elements.wrapper);\n\n          // Clear for GC\n          this.elements.buttons.play = null;\n          this.elements.captions = null;\n          this.elements.controls = null;\n          this.elements.wrapper = null;\n        }\n\n        // Callback\n        if (is.function(callback)) {\n          callback();\n        }\n      } else {\n        // Unbind listeners\n        unbindListeners.call(this);\n\n        // Replace the container with the original element provided\n        replaceElement(this.elements.original, this.elements.container);\n\n        // Event\n        triggerEvent.call(this, this.elements.original, 'destroyed', true);\n\n        // Callback\n        if (is.function(callback)) {\n          callback.call(this.elements.original);\n        }\n\n        // Reset state\n        this.ready = false;\n\n        // Clear for garbage collection\n        setTimeout(() => {\n          this.elements = null;\n          this.media = null;\n        }, 200);\n      }\n    };\n\n    // Stop playback\n    this.stop();\n\n    // Clear timeouts\n    clearTimeout(this.timers.loading);\n    clearTimeout(this.timers.controls);\n    clearTimeout(this.timers.resized);\n\n    // Provider specific stuff\n    if (this.isHTML5) {\n      // Restore native video controls\n      ui.toggleNativeControls.call(this, true);\n\n      // Clean up\n      done();\n    }\n  }\n\n  /**\n   * Check for support for a mime type (HTML5 only)\n   * @param {String} type - Mime type\n   */\n  supports(type) {\n    return support.mime.call(this, type);\n  }\n\n  /**\n   * Check for support\n   * @param {String} type - Player type (video)\n   * @param {String} provider - Provider (html5)\n   * @param {Boolean} inline - Where player has `playsinline` sttribute\n   */\n  static supported(type, provider, inline) {\n    return support.check(type, provider, inline);\n  }\n\n  /**\n   * Load an SVG sprite into the page\n   * @param {String} url - URL for the SVG sprite\n   * @param {String} [id] - Unique ID\n   */\n  static loadSprite(url, id) {\n    return loadSprite(url, id);\n  }\n\n  /**\n   * Setup multiple instances\n   * @param {*} selector\n   * @param {Object} options\n   */\n  static setup(selector, options = {}) {\n    let targets = null;\n\n    if (is.string(selector)) {\n      targets = Array.from(document.querySelectorAll(selector));\n    } else if (is.nodeList(selector)) {\n      targets = Array.from(selector);\n    } else if (is.array(selector)) {\n      targets = selector.filter(is.element);\n    }\n\n    if (is.empty(targets)) {\n      return null;\n    }\n\n    return targets.map(t => new WassPlayer(t, options));\n  }\n}\n\nWassPlayer.defaults = cloneDeep(defaults);\n\nexport default WassPlayer;\n","/**\n * Returns a number whose value is limited to the given range.\n *\n * Example: limit the output of this computation to between 0 and 255\n * (x * 255).clamp(0, 255)\n *\n * @param {Number} input\n * @param {Number} min The lower boundary of the output range\n * @param {Number} max The upper boundary of the output range\n * @returns A number in the range [min, max]\n * @type Number\n */\nexport function clamp(input = 0, min = 0, max = 255) {\n  return Math.min(Math.max(input, min), max);\n}\n\nexport default { clamp };\n"]}