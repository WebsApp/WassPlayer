{"version":3,"sources":["wassPlayer.mjs","node_modules/rangetouch/dist/rangetouch.mjs","src/js/utils/is.js","src/js/utils/animation.js","src/js/utils/browser.js","src/js/utils/objects.js","src/js/utils/elements.js","src/js/support.js","src/js/utils/events.js","src/js/utils/promise.js","src/js/utils/style.js","src/js/html5.js","src/js/utils/arrays.js","src/js/utils/strings.js","src/js/utils/i18n.js","src/js/storage.js","src/js/utils/fetch.js","src/js/utils/load-sprite.js","src/js/utils/time.js","src/js/controls.js","src/js/utils/urls.js","src/js/captions.js","src/js/config/defaults.js","src/js/config/states.js","src/js/config/types.js","src/js/console.js","src/js/fullscreen.js","src/js/utils/load-image.js","src/js/ui.js","src/js/listeners.js","src/js/media.js","src/js/plugins/preview-thumbnails.js","src/js/source.js","src/js/utils/numbers.js","src/js/wassPlayer.js"],"names":["_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","Constructor","protoProps","staticProps","prototype","_defineProperty","obj","value","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","push","apply","_objectSpread2","arguments","source","forEach","getOwnPropertyDescriptors","defineProperties","_slicedToArray","arr","_arrayWithHoles","_iterableToArrayLimit","_unsupportedIterableToArray","_nonIterableRest","_toConsumableArray","_arrayWithoutHoles","_iterableToArray","_nonIterableSpread","Array","isArray","_arrayLikeToArray","iter","Symbol","iterator","from","_arr","_n","_d","_e","undefined","_s","_i","next","done","err","o","minLen","n","toString","call","slice","constructor","name","test","len","arr2","TypeError","_classCallCheck","e","t","r","defaults","addCSS","thumbWidth","watch","matches","document","querySelectorAll","includes","this","trigger","Event","bubbles","dispatchEvent","getConstructor","instanceOf","isNullOrUndefined","isObject","isNumber","Number","isNaN","isString","String","isBoolean","Boolean","isFunction","Function","isNodeList","NodeList","isElement","Element","isEvent","isEmpty","is","nullOrUndefined","number","string","boolean","function","array","nodeList","element","event","empty","getDecimalPlaces","concat","match","Math","max","round","parseFloat","toFixed","RangeTouch","querySelector","rangeTouch","config","init","enabled","style","userSelect","webKitUserSelect","touchAction","listeners","set","changedTouches","getAttribute","s","u","c","getBoundingClientRect","a","width","clientX","left","disabled","preventDefault","get","type","MutationObserver","addedNodes","observe","body","childList","subtree","map","documentElement","input","isWeakMap","WeakMap","isTextNode","Text","isKeyboardEvent","KeyboardEvent","isCue","window","TextTrackCue","VTTCue","isTrack","TextTrack","kind","isPromise","Promise","then","isUrl","URL","startsWith","hostname","is$1","weakMap","textNode","keyboardEvent","cue","track","promise","url","transitionEndEvent","createElement","events","WebkitTransition","MozTransition","OTransition","transition","find","repaint","delay","setTimeout","hidden","offsetHeight","browser","isIE","documentMode","isEdge","navigator","userAgent","isWebkit","isIPhone","platform","isIos","cloneDeep","JSON","parse","stringify","getDeep","path","split","reduce","extend","_len","sources","_key","shift","assign","wrap","elements","wrapper","targets","reverse","index","child","cloneNode","parent","parentNode","sibling","nextSibling","appendChild","insertBefore","setAttributes","attributes","entries","_ref","_ref3","_ref4","setAttribute","text","innerText","insertAfter","insertElement","removeElement","removeChild","emptyElement","childNodes","lastChild","replaceElement","newChild","oldChild","replaceChild","getAttributesFromSelector","sel","existingAttributes","existing","selector","trim","className","replace","parts","charAt","class","id","toggleHidden","hide","toggleClass","force","method","classList","contains","hasClass","webkitMatchesSelector","mozMatchesSelector","msMatchesSelector","closest","el","parentElement","nodeType","getElements","container","getElement","setFocus","tabFocus","focus","preventScroll","classNames","defaultCodecs","audio/ogg","audio/wav","video/webm","video/mp4","video/ogg","support","audio","video","check","provider","playsinline","canPlayInline","api","ui","rangeInput","pip","webkitSetPresentationMode","pictureInPictureEnabled","disablePictureInPicture","airplay","WebKitPlaybackTargetAvailabilityEvent","mime","mediaType","isHTML5","media","canPlayType","textTracks","range","touch","transitions","reducedMotion","matchMedia","supportsPassiveListeners","supported","options","addEventListener","removeEventListener","toggleListener","callback","_this","toggle","passive","capture","eventListeners","on","off","once","_this2","onceCallback","args","triggerEvent","detail","CustomEvent","plyr","unbindListeners","item","ready","_this3","resolve","silencePromise","validateRatio","every","reduceAspectRatio","ratio","_ratio","height","divider","getDivider","w","h","getAspectRatio","embed","_this$media","videoWidth","videoHeight","setAspectRatio","isVideo","_ref2","padding","paddingBottom","isVimeo","vimeo","premium","offsetWidth","parseInt","getComputedStyle","offset","transform","videoFixedRatio","html5","getSources","getQualityOptions","quality","forced","setup","player","speed","onChange","_player$media","currentTime","paused","preload","readyState","playbackRate","src","play","load","cancelRequests","blankVideo","debug","log","dedupe","indexOf","prev","curr","abs","getPercentage","current","replaceAll","RegExp","toTitleCase","toUpperCase","substr","toLowerCase","toPascalCase","toCamelCase","getHTML","innerHTML","resources","youtube","i18n","{seektime}","seekTime","{title}","title","k","v","Storage","storage","store","localStorage","getItem","json","setItem","removeItem","fetch","responseType","reject","request","XMLHttpRequest","responseText","response","Error","status","open","send","loadSprite","prefix","hasId","exists","getElementById","update","data","insertAdjacentElement","useStorage","cached","content","result","catch","getHours","trunc","getMinutes","getSeconds","formatTime","time","displayHours","inverted","format","hours","mins","secs","controls","getIconUrl","cors","iconUrl","location","host","svg4everybody","findElements","selectors","buttons","pause","restart","rewind","fastForward","mute","settings","captions","fullscreen","progress","inputs","seek","volume","display","buffer","duration","seekTooltip","tooltip","error","warn","toggleNativeControls","createIcon","namespace","iconPath","iconPrefix","icon","createElementNS","aria-hidden","focusable","use","setAttributeNS","createLabel","attr","join","createBadge","badge","menu","createButton","buttonType","label","labelPressed","iconPressed","some","control","button","createRange","min","step","autocomplete","role","aria-label","aria-valuemin","aria-valuemax","aria-valuenow","updateRangeFill","createProgress","suffixKey","played","suffix","createTime","attrs","bindMenuItemShortcuts","menuItem","which","stopPropagation","isRadioButton","showMenuPanel","nextElementSibling","firstElementChild","previousElementSibling","lastElementChild","focusFirstMenuItem","createMenuItem","list","_ref$badge","_ref$checked","checked","aria-checked","flex","children","node","bind","currentTrack","forceHours","updateTimeDisplay","updateVolume","setRange","muted","pressed","updateProgress","_this4","val","getElementsByTagName","nodeValue","setProgress","buffered","percent","setProperty","updateSeekTooltip","_this5","tooltips","visible","show","clientRect","pageX","timeUpdate","invert","invertTime","seeking","durationUpdate","pow","hasDuration","displayDuration","toggleMenuButton","setting","updateSetting","pane","panels","default","getLabel","setQualityMenu","_this6","checkMenu","getBadge","sort","b","sorting","setCaptionsMenu","_this7","tracks","getTracks","toggled","language","unshift","setSpeedMenu","_this8","minimumSpeed","maximumSpeed","values","popup","p","firstItem","toggleMenu","composedPath","isMenuItem","getMenuSize","tab","clone","position","opacity","removeAttribute","scrollWidth","scrollHeight","_this9","size","restore","propertyName","setDownloadUrl","download","create","_this10","defaultAttributes","progressContainer","aria-haspopup","aria-controls","aria-expanded","inner","home","backButton","href","urls","isEmbed","inject","_this11","floor","random","seektime","addProperty","controlPressed","_this$config","labels","parseUrl","safe","parser","isYouTube","protocol","blob","createObjectURL","languages","userLanguage","active","trackEvents","_this$captions","meta","currentTrackNode","languageExists","mode","updateCues","setLanguage","activeClass","findTrack","enableTextTrack","has","sortIsDefault","sorted","getCurrentTrack","cues","activeCues","getCueAsHTML","cueText","caption","autoplay","autopause","toggleInvert","clickToPlay","hideControls","resetOnEnd","disableContextMenu","loop","selected","keyboard","focused","global","fallback","iosNative","seekLabel","unmute","enableCaptions","disableCaptions","enterFullscreen","exitFullscreen","frameTitle","menuBack","normal","start","end","all","reset","advertisement","qualityBadge","2160","1440","1080","720","576","480","editable","embedContainer","poster","posterEnabled","playing","stopped","loading","hover","isTouch","uiSupported","noTransition","previewThumbnails","thumbContainer","thumbContainerShown","imageContainer","timeContainer","scrubbingContainer","scrubbingContainerShown","inactive","providers","types","getProviderByUrl","noop","Console","console","Fullscreen","property","scrollPosition","x","y","forceFallback","trapFocus","scrollX","scrollY","scrollTo","overflow","viewport","head","hasProperty","cleanupViewport","part","keyCode","activeElement","first","last","shiftKey","native","webkitEnterFullscreen","toggleFallback","requestFullscreen","navigationUI","webkitExitFullscreen","action","cancelFullScreen","exit","enter","fullscreenElement","shadowRoot","getRootNode","fullscreenEnabled","webkitFullscreenEnabled","mozFullScreenEnabled","msFullscreenEnabled","pre","loadImage","minWidth","image","Image","handler","onload","onerror","naturalWidth","addStyleHook","build","checkPlaying","setTitle","setPoster","iframe","togglePoster","enable","backgroundImage","backgroundSize","toggleControls","checkLoading","clearTimeout","timers","controlsElement","recentTouchSeek","lastSeekTime","Date","now","migrateStyles","getPropertyValue","removeProperty","Listeners","lastKey","focusTimer","lastKeyDown","handleKey","setTabFocus","firstTouch","code","repeat","altKey","ctrlKey","metaKey","togglePlay","increaseVolume","decreaseVolume","forward","toggleCaptions","usingNative","timeStamp","wasKeyDown","setPlayerSize","measure","rect","resized","_player$fullscreen","isEnter","_setPlayerSize","firstChild","_getAspectRatio$call2","videoX","videoY","maxWidth","margin","setGutter","isAudio","ended","proxy","proxyEvents","_event$detail","defaultHandler","customHandlerKey","customHandler","returned","hasCustomHandler","inputEvent","currentTarget","attribute","hasAttribute","seekTo","loaded","startMove","endMove","startScrubbing","endScrubbing","webkitDirectionInvertedFromDevice","_map2","deltaX","deltaY","direction","sign","parseVtt","vttDataString","processedList","frame","line","startTime","lineSplit","_lineSplit","_lineSplit$1$split2","matchTimes","endTime","fitRatio","outer","PreviewThumbnails","thumbnails","lastMouseMoveTime","mouseDown","loadedImages","thumb","scrubbing","getThumbnails","render","determineContainerAutoSizing","sortAndResolve","promises","getThumbnail","thumbnail","frames","urlPrefix","substring","lastIndexOf","tempImage","naturalHeight","percentage","mousePosX","showImageAtCurrentTime","toggleThumbContainer","toggleScrubbingContainer","ceil","lastTime","remove","setScrubbingContainerSize","setThumbContainerSizeAndPos","thumbNum","findIndex","hasThumb","qualityIndex","showingThumb","thumbFilename","thumbUrl","currentImageElement","dataset","filename","showImage","removeOldImages","loadingImage","usingSprites","previewImage","showingThumbFilename","newImage","setImageSizeAndOffset","currentImageContainer","preloadNearby","getHigherQuality","currentImage","tagName","removeDelay","deleting","oldThumbFilename","thumbnailsClone","foundOne","newThumbFilename","thumbURL","currentQualityIndex","previewImageHeight","thumbContainerHeight","clearShowing","clientHeight","clientWidth","sizeSpecifiedInCSS","thumbAspectRatio","thumbHeight","setThumbContainerPos","seekbarRect","wassPlayerRect","minVal","maxVal","right","previewPos","_fitRatio","multiplier","top","currentScrubbingImageElement","currentThumbnailImageElement","insertElements","change","destroy","_sources$","_sources$$provider","crossorigin","clamp","WassPlayer","failed","jQuery","wassPlayer","original","search","truthy","searchParams","tabindex","stop","webkitShowPlaybackTargetPicker","isHidden","hiding","eventName","soft","inputIsValid","fauxDuration","realDuration","Infinity","mozHasAudio","webkitAudioDecodedByteCount","audioTracks","updateStorage","currentSrc","requestPictureInPicture","exitPictureInPicture","webkitPresentationMode","pictureInPictureElement","inline"],"mappings":"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","file":"wassPlayer.min.mjs","sourcesContent":["typeof navigator === \"object\" && function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _classCallCheck$1(e, t) {\n  if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n}\n\nfunction _defineProperties$1(e, t) {\n  for (var n = 0; n < t.length; n++) {\n    var r = t[n];\n    r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(e, r.key, r);\n  }\n}\n\nfunction _createClass$1(e, t, n) {\n  return t && _defineProperties$1(e.prototype, t), n && _defineProperties$1(e, n), e;\n}\n\nfunction _defineProperty$1(e, t, n) {\n  return t in e ? Object.defineProperty(e, t, {\n    value: n,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[t] = n, e;\n}\n\nfunction ownKeys$1(e, t) {\n  var n = Object.keys(e);\n\n  if (Object.getOwnPropertySymbols) {\n    var r = Object.getOwnPropertySymbols(e);\n    t && (r = r.filter(function (t) {\n      return Object.getOwnPropertyDescriptor(e, t).enumerable;\n    })), n.push.apply(n, r);\n  }\n\n  return n;\n}\n\nfunction _objectSpread2$1(e) {\n  for (var t = 1; t < arguments.length; t++) {\n    var n = null != arguments[t] ? arguments[t] : {};\n    t % 2 ? ownKeys$1(Object(n), !0).forEach(function (t) {\n      _defineProperty$1(e, t, n[t]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : ownKeys$1(Object(n)).forEach(function (t) {\n      Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t));\n    });\n  }\n\n  return e;\n}\n\nvar defaults = {\n  addCSS: !0,\n  thumbWidth: 15,\n  watch: !0\n};\n\nfunction matches(e, t) {\n  return function () {\n    return Array.from(document.querySelectorAll(t)).includes(this);\n  }.call(e, t);\n}\n\nfunction trigger(e, t) {\n  if (e && t) {\n    var n = new Event(t, {\n      bubbles: !0\n    });\n    e.dispatchEvent(n);\n  }\n}\n\nvar getConstructor = function getConstructor(e) {\n  return null != e ? e.constructor : null;\n},\n    instanceOf = function instanceOf(e, t) {\n  return !!(e && t && e instanceof t);\n},\n    isNullOrUndefined = function isNullOrUndefined(e) {\n  return null == e;\n},\n    isObject = function isObject(e) {\n  return getConstructor(e) === Object;\n},\n    isNumber = function isNumber(e) {\n  return getConstructor(e) === Number && !Number.isNaN(e);\n},\n    isString = function isString(e) {\n  return getConstructor(e) === String;\n},\n    isBoolean = function isBoolean(e) {\n  return getConstructor(e) === Boolean;\n},\n    isFunction = function isFunction(e) {\n  return getConstructor(e) === Function;\n},\n    isArray = function isArray(e) {\n  return Array.isArray(e);\n},\n    isNodeList = function isNodeList(e) {\n  return instanceOf(e, NodeList);\n},\n    isElement = function isElement(e) {\n  return instanceOf(e, Element);\n},\n    isEvent = function isEvent(e) {\n  return instanceOf(e, Event);\n},\n    isEmpty = function isEmpty(e) {\n  return isNullOrUndefined(e) || (isString(e) || isArray(e) || isNodeList(e)) && !e.length || isObject(e) && !Object.keys(e).length;\n},\n    is = {\n  nullOrUndefined: isNullOrUndefined,\n  object: isObject,\n  number: isNumber,\n  string: isString,\n  boolean: isBoolean,\n  function: isFunction,\n  array: isArray,\n  nodeList: isNodeList,\n  element: isElement,\n  event: isEvent,\n  empty: isEmpty\n};\n\nfunction getDecimalPlaces(e) {\n  var t = \"\".concat(e).match(/(?:\\.(\\d+))?(?:[eE]([+-]?\\d+))?$/);\n  return t ? Math.max(0, (t[1] ? t[1].length : 0) - (t[2] ? +t[2] : 0)) : 0;\n}\n\nfunction round(e, t) {\n  if (1 > t) {\n    var n = getDecimalPlaces(t);\n    return parseFloat(e.toFixed(n));\n  }\n\n  return Math.round(e / t) * t;\n}\n\nvar RangeTouch = function () {\n  function e(t, n) {\n    _classCallCheck$1(this, e), is.element(t) ? this.element = t : is.string(t) && (this.element = document.querySelector(t)), is.element(this.element) && is.empty(this.element.rangeTouch) && (this.config = _objectSpread2$1({}, defaults, {}, n), this.init());\n  }\n\n  return _createClass$1(e, [{\n    key: \"init\",\n    value: function value() {\n      e.enabled && (this.config.addCSS && (this.element.style.userSelect = \"none\", this.element.style.webKitUserSelect = \"none\", this.element.style.touchAction = \"manipulation\"), this.listeners(!0), this.element.rangeTouch = this);\n    }\n  }, {\n    key: \"destroy\",\n    value: function value() {\n      e.enabled && (this.config.addCSS && (this.element.style.userSelect = \"\", this.element.style.webKitUserSelect = \"\", this.element.style.touchAction = \"\"), this.listeners(!1), this.element.rangeTouch = null);\n    }\n  }, {\n    key: \"listeners\",\n    value: function value(e) {\n      var t = this,\n          n = e ? \"addEventListener\" : \"removeEventListener\";\n      [\"touchstart\", \"touchmove\", \"touchend\"].forEach(function (e) {\n        t.element[n](e, function (e) {\n          return t.set(e);\n        }, !1);\n      });\n    }\n  }, {\n    key: \"get\",\n    value: function value(t) {\n      if (!e.enabled || !is.event(t)) return null;\n      var n,\n          r = t.target,\n          i = t.changedTouches[0],\n          o = parseFloat(r.getAttribute(\"min\")) || 0,\n          s = parseFloat(r.getAttribute(\"max\")) || 100,\n          u = parseFloat(r.getAttribute(\"step\")) || 1,\n          c = r.getBoundingClientRect(),\n          a = 100 / c.width * (this.config.thumbWidth / 2) / 100;\n      return 0 > (n = 100 / c.width * (i.clientX - c.left)) ? n = 0 : 100 < n && (n = 100), 50 > n ? n -= (100 - 2 * n) * a : 50 < n && (n += 2 * (n - 50) * a), o + round(n / 100 * (s - o), u);\n    }\n  }, {\n    key: \"set\",\n    value: function value(t) {\n      e.enabled && is.event(t) && !t.target.disabled && (t.preventDefault(), t.target.value = this.get(t), trigger(t.target, \"touchend\" === t.type ? \"change\" : \"input\"));\n    }\n  }], [{\n    key: \"setup\",\n    value: function value(t) {\n      var n = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : {},\n          r = null;\n      if (is.empty(t) || is.string(t) ? r = Array.from(document.querySelectorAll(is.string(t) ? t : 'input[type=\"range\"]')) : is.element(t) ? r = [t] : is.nodeList(t) ? r = Array.from(t) : is.array(t) && (r = t.filter(is.element)), is.empty(r)) return null;\n\n      var i = _objectSpread2$1({}, defaults, {}, n);\n\n      if (is.string(t) && i.watch) {\n        var o = new MutationObserver(function (n) {\n          Array.from(n).forEach(function (n) {\n            Array.from(n.addedNodes).forEach(function (n) {\n              is.element(n) && matches(n, t) && new e(n, i);\n            });\n          });\n        });\n        o.observe(document.body, {\n          childList: !0,\n          subtree: !0\n        });\n      }\n\n      return r.map(function (t) {\n        return new e(t, n);\n      });\n    }\n  }, {\n    key: \"enabled\",\n    get: function get() {\n      return \"ontouchstart\" in document.documentElement;\n    }\n  }]), e;\n}();\n\n// ==========================================================================\n// Type checking utils\n// ==========================================================================\nvar getConstructor$1 = function getConstructor(input) {\n  return input !== null && typeof input !== 'undefined' ? input.constructor : null;\n};\n\nvar instanceOf$1 = function instanceOf(input, constructor) {\n  return Boolean(input && constructor && input instanceof constructor);\n};\n\nvar isNullOrUndefined$1 = function isNullOrUndefined(input) {\n  return input === null || typeof input === 'undefined';\n};\n\nvar isObject$1 = function isObject(input) {\n  return getConstructor$1(input) === Object;\n};\n\nvar isNumber$1 = function isNumber(input) {\n  return getConstructor$1(input) === Number && !Number.isNaN(input);\n};\n\nvar isString$1 = function isString(input) {\n  return getConstructor$1(input) === String;\n};\n\nvar isBoolean$1 = function isBoolean(input) {\n  return getConstructor$1(input) === Boolean;\n};\n\nvar isFunction$1 = function isFunction(input) {\n  return getConstructor$1(input) === Function;\n};\n\nvar isArray$1 = function isArray(input) {\n  return Array.isArray(input);\n};\n\nvar isWeakMap = function isWeakMap(input) {\n  return instanceOf$1(input, WeakMap);\n};\n\nvar isNodeList$1 = function isNodeList(input) {\n  return instanceOf$1(input, NodeList);\n};\n\nvar isElement$1 = function isElement(input) {\n  return instanceOf$1(input, Element);\n};\n\nvar isTextNode = function isTextNode(input) {\n  return getConstructor$1(input) === Text;\n};\n\nvar isEvent$1 = function isEvent(input) {\n  return instanceOf$1(input, Event);\n};\n\nvar isKeyboardEvent = function isKeyboardEvent(input) {\n  return instanceOf$1(input, KeyboardEvent);\n};\n\nvar isCue = function isCue(input) {\n  return instanceOf$1(input, window.TextTrackCue) || instanceOf$1(input, window.VTTCue);\n};\n\nvar isTrack = function isTrack(input) {\n  return instanceOf$1(input, TextTrack) || !isNullOrUndefined$1(input) && isString$1(input.kind);\n};\n\nvar isPromise = function isPromise(input) {\n  return instanceOf$1(input, Promise) && isFunction$1(input.then);\n};\n\nvar isEmpty$1 = function isEmpty(input) {\n  return isNullOrUndefined$1(input) || (isString$1(input) || isArray$1(input) || isNodeList$1(input)) && !input.length || isObject$1(input) && !Object.keys(input).length;\n};\n\nvar isUrl = function isUrl(input) {\n  // Accept a URL object\n  if (instanceOf$1(input, window.URL)) {\n    return true;\n  } // Must be string from here\n\n\n  if (!isString$1(input)) {\n    return false;\n  } // Add the protocol if required\n\n\n  var string = input;\n\n  if (!input.startsWith('http://') || !input.startsWith('https://')) {\n    string = \"http://\".concat(input);\n  }\n\n  try {\n    return !isEmpty$1(new URL(string).hostname);\n  } catch (e) {\n    return false;\n  }\n};\n\nvar is$1 = {\n  nullOrUndefined: isNullOrUndefined$1,\n  object: isObject$1,\n  number: isNumber$1,\n  string: isString$1,\n  boolean: isBoolean$1,\n  function: isFunction$1,\n  array: isArray$1,\n  weakMap: isWeakMap,\n  nodeList: isNodeList$1,\n  element: isElement$1,\n  textNode: isTextNode,\n  event: isEvent$1,\n  keyboardEvent: isKeyboardEvent,\n  cue: isCue,\n  track: isTrack,\n  promise: isPromise,\n  url: isUrl,\n  empty: isEmpty$1\n};\n\n// ==========================================================================\nvar transitionEndEvent = function () {\n  var element = document.createElement('span');\n  var events = {\n    WebkitTransition: 'webkitTransitionEnd',\n    MozTransition: 'transitionend',\n    OTransition: 'oTransitionEnd otransitionend',\n    transition: 'transitionend'\n  };\n  var type = Object.keys(events).find(function (event) {\n    return element.style[event] !== undefined;\n  });\n  return is$1.string(type) ? events[type] : false;\n}(); // Force repaint of element\n\nfunction repaint(element, delay) {\n  setTimeout(function () {\n    try {\n      // eslint-disable-next-line no-param-reassign\n      element.hidden = true; // eslint-disable-next-line no-unused-expressions\n\n      element.offsetHeight; // eslint-disable-next-line no-param-reassign\n\n      element.hidden = false;\n    } catch (e) {// Do nothing\n    }\n  }, delay);\n}\n\n// ==========================================================================\n// Browser sniffing\n// Unfortunately, due to mixed support, UA sniffing is required\n// ==========================================================================\nvar browser = {\n  isIE:\n  /* @cc_on!@ */\n   !!document.documentMode,\n  isEdge: window.navigator.userAgent.includes('Edge'),\n  isWebkit: 'WebkitAppearance' in document.documentElement.style && !/Edge/.test(navigator.userAgent),\n  isIPhone: /(iPhone|iPod)/gi.test(navigator.platform),\n  isIos: /(iPad|iPhone|iPod)/gi.test(navigator.platform)\n};\n\nfunction cloneDeep(object) {\n  return JSON.parse(JSON.stringify(object));\n} // Get a nested value in an object\n\nfunction getDeep(object, path) {\n  return path.split('.').reduce(function (obj, key) {\n    return obj && obj[key];\n  }, object);\n} // Deep extend destination object with N more objects\n\nfunction extend() {\n  var target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  for (var _len = arguments.length, sources = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    sources[_key - 1] = arguments[_key];\n  }\n\n  if (!sources.length) {\n    return target;\n  }\n\n  var source = sources.shift();\n\n  if (!is$1.object(source)) {\n    return target;\n  }\n\n  Object.keys(source).forEach(function (key) {\n    if (is$1.object(source[key])) {\n      if (!Object.keys(target).includes(key)) {\n        Object.assign(target, _defineProperty({}, key, {}));\n      }\n\n      extend(target[key], source[key]);\n    } else {\n      Object.assign(target, _defineProperty({}, key, source[key]));\n    }\n  });\n  return extend.apply(void 0, [target].concat(sources));\n}\n\nfunction wrap(elements, wrapper) {\n  // Convert `elements` to an array, if necessary.\n  var targets = elements.length ? elements : [elements]; // Loops backwards to prevent having to clone the wrapper on the\n  // first element (see `child` below).\n\n  Array.from(targets).reverse().forEach(function (element, index) {\n    var child = index > 0 ? wrapper.cloneNode(true) : wrapper; // Cache the current parent and sibling.\n\n    var parent = element.parentNode;\n    var sibling = element.nextSibling; // Wrap the element (is automatically removed from its current\n    // parent).\n\n    child.appendChild(element); // If the element had a sibling, insert the wrapper before\n    // the sibling to maintain the HTML structure; otherwise, just\n    // append it to the parent.\n\n    if (sibling) {\n      parent.insertBefore(child, sibling);\n    } else {\n      parent.appendChild(child);\n    }\n  });\n} // Set attributes\n\nfunction setAttributes(element, attributes) {\n  if (!is$1.element(element) || is$1.empty(attributes)) {\n    return;\n  } // Assume null and undefined attributes should be left out,\n  // Setting them would otherwise convert them to \"null\" and \"undefined\"\n\n\n  Object.entries(attributes).filter(function (_ref) {\n    var _ref2 = _slicedToArray(_ref, 2),\n        value = _ref2[1];\n\n    return !is$1.nullOrUndefined(value);\n  }).forEach(function (_ref3) {\n    var _ref4 = _slicedToArray(_ref3, 2),\n        key = _ref4[0],\n        value = _ref4[1];\n\n    return element.setAttribute(key, value);\n  });\n} // Create a DocumentFragment\n\nfunction createElement(type, attributes, text) {\n  // Create a new <element>\n  var element = document.createElement(type); // Set all passed attributes\n\n  if (is$1.object(attributes)) {\n    setAttributes(element, attributes);\n  } // Add text node\n\n\n  if (is$1.string(text)) {\n    element.innerText = text;\n  } // Return built element\n\n\n  return element;\n} // Inaert an element after another\n\nfunction insertAfter(element, target) {\n  if (!is$1.element(element) || !is$1.element(target)) {\n    return;\n  }\n\n  target.parentNode.insertBefore(element, target.nextSibling);\n} // Insert a DocumentFragment\n\nfunction insertElement(type, parent, attributes, text) {\n  if (!is$1.element(parent)) {\n    return;\n  }\n\n  parent.appendChild(createElement(type, attributes, text));\n} // Remove element(s)\n\nfunction removeElement(element) {\n  if (is$1.nodeList(element) || is$1.array(element)) {\n    Array.from(element).forEach(removeElement);\n    return;\n  }\n\n  if (!is$1.element(element) || !is$1.element(element.parentNode)) {\n    return;\n  }\n\n  element.parentNode.removeChild(element);\n} // Remove all child elements\n\nfunction emptyElement(element) {\n  if (!is$1.element(element)) {\n    return;\n  }\n\n  var length = element.childNodes.length;\n\n  while (length > 0) {\n    element.removeChild(element.lastChild);\n    length -= 1;\n  }\n} // Replace element\n\nfunction replaceElement(newChild, oldChild) {\n  if (!is$1.element(oldChild) || !is$1.element(oldChild.parentNode) || !is$1.element(newChild)) {\n    return null;\n  }\n\n  oldChild.parentNode.replaceChild(newChild, oldChild);\n  return newChild;\n} // Get an attribute object from a string selector\n\nfunction getAttributesFromSelector(sel, existingAttributes) {\n  // For example:\n  // '.test' to { class: 'test' }\n  // '#test' to { id: 'test' }\n  // '[data-test=\"test\"]' to { 'data-test': 'test' }\n  if (!is$1.string(sel) || is$1.empty(sel)) {\n    return {};\n  }\n\n  var attributes = {};\n  var existing = extend({}, existingAttributes);\n  sel.split(',').forEach(function (s) {\n    // Remove whitespace\n    var selector = s.trim();\n    var className = selector.replace('.', '');\n    var stripped = selector.replace(/[[\\]]/g, ''); // Get the parts and value\n\n    var parts = stripped.split('=');\n\n    var _parts = _slicedToArray(parts, 1),\n        key = _parts[0];\n\n    var value = parts.length > 1 ? parts[1].replace(/[\"']/g, '') : ''; // Get the first character\n\n    var start = selector.charAt(0);\n\n    switch (start) {\n      case '.':\n        // Add to existing classname\n        if (is$1.string(existing.class)) {\n          attributes.class = \"\".concat(existing.class, \" \").concat(className);\n        } else {\n          attributes.class = className;\n        }\n\n        break;\n\n      case '#':\n        // ID selector\n        attributes.id = selector.replace('#', '');\n        break;\n\n      case '[':\n        // Attribute selector\n        attributes[key] = value;\n        break;\n    }\n  });\n  return extend(existing, attributes);\n} // Toggle hidden\n\nfunction toggleHidden(element, hidden) {\n  if (!is$1.element(element)) {\n    return;\n  }\n\n  var hide = hidden;\n\n  if (!is$1.boolean(hide)) {\n    hide = !element.hidden;\n  } // eslint-disable-next-line no-param-reassign\n\n\n  element.hidden = hide;\n} // Mirror Element.classList.toggle, with IE compatibility for \"force\" argument\n\nfunction toggleClass(element, className, force) {\n  if (is$1.nodeList(element)) {\n    return Array.from(element).map(function (e) {\n      return toggleClass(e, className, force);\n    });\n  }\n\n  if (is$1.element(element)) {\n    var method = 'toggle';\n\n    if (typeof force !== 'undefined') {\n      method = force ? 'add' : 'remove';\n    }\n\n    element.classList[method](className);\n    return element.classList.contains(className);\n  }\n\n  return false;\n} // Has class name\n\nfunction hasClass(element, className) {\n  return is$1.element(element) && element.classList.contains(className);\n} // Element matches selector\n\nfunction matches$1(element, selector) {\n  var _Element = Element,\n      prototype = _Element.prototype;\n\n  function match() {\n    return Array.from(document.querySelectorAll(selector)).includes(this);\n  }\n\n  var method = prototype.matches || prototype.webkitMatchesSelector || prototype.mozMatchesSelector || prototype.msMatchesSelector || match;\n  return method.call(element, selector);\n} // Closest ancestor element matching selector (also tests element itself)\n\nfunction closest(element, selector) {\n  var _Element2 = Element,\n      prototype = _Element2.prototype; // https://developer.mozilla.org/en-US/docs/Web/API/Element/closest#Polyfill\n\n  function closestElement() {\n    var el = this;\n\n    do {\n      if (matches$1.matches(el, selector)) return el;\n      el = el.parentElement || el.parentNode;\n    } while (el !== null && el.nodeType === 1);\n\n    return null;\n  }\n\n  var method = prototype.closest || closestElement;\n  return method.call(element, selector);\n} // Find all elements\n\nfunction getElements(selector) {\n  return this.elements.container.querySelectorAll(selector);\n} // Find a single element\n\nfunction getElement(selector) {\n  return this.elements.container.querySelector(selector);\n} // Set focus and tab focus class\n\nfunction setFocus() {\n  var element = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n  var tabFocus = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n  if (!is$1.element(element)) {\n    return;\n  } // Set regular focus\n\n\n  element.focus({\n    preventScroll: true\n  }); // If we want to mimic keyboard focus via tab\n\n  if (tabFocus) {\n    toggleClass(element, this.config.classNames.tabFocus);\n  }\n}\n\nvar defaultCodecs = {\n  'audio/ogg': 'vorbis',\n  'audio/wav': '1',\n  'video/webm': 'vp8, vorbis',\n  'video/mp4': 'avc1.42E01E, mp4a.40.2',\n  'video/ogg': 'theora'\n}; // Check for feature support\n\nvar support = {\n  // Basic support\n  audio: 'canPlayType' in document.createElement('audio'),\n  video: 'canPlayType' in document.createElement('video'),\n  // Check for support\n  // Basic functionality vs full UI\n  check: function check(type, provider, playsinline) {\n    var canPlayInline = browser.isIPhone && playsinline && support.playsinline;\n    var api = support[type] || provider !== 'html5';\n    var ui = api && support.rangeInput && (type !== 'video' || !browser.isIPhone || canPlayInline);\n    return {\n      api: api,\n      ui: ui\n    };\n  },\n  // Picture-in-picture support\n  // Safari & Chrome only currently\n  pip: function () {\n    if (browser.isIPhone) {\n      return false;\n    } // Safari\n    // https://developer.apple.com/documentation/webkitjs/adding_picture_in_picture_to_your_safari_media_controls\n\n\n    if (is$1.function(createElement('video').webkitSetPresentationMode)) {\n      return true;\n    } // Chrome\n    // https://developers.google.com/web/updates/2018/10/watch-video-using-picture-in-picture\n\n\n    if (document.pictureInPictureEnabled && !createElement('video').disablePictureInPicture) {\n      return true;\n    }\n\n    return false;\n  }(),\n  // Airplay support\n  // Safari only currently\n  airplay: is$1.function(window.WebKitPlaybackTargetAvailabilityEvent),\n  // Inline playback support\n  // https://webkit.org/blog/6784/new-video-policies-for-ios/\n  playsinline: 'playsInline' in document.createElement('video'),\n  // Check for mime type support against a player instance\n  // Credits: http://diveintohtml5.info/everything.html\n  // Related: http://www.leanbackplayer.com/test/h5mt.html\n  mime: function mime(input) {\n    if (is$1.empty(input)) {\n      return false;\n    }\n\n    var _input$split = input.split('/'),\n        _input$split2 = _slicedToArray(_input$split, 1),\n        mediaType = _input$split2[0];\n\n    var type = input; // Verify we're using HTML5 and there's no media type mismatch\n\n    if (!this.isHTML5 || mediaType !== this.type) {\n      return false;\n    } // Add codec if required\n\n\n    if (Object.keys(defaultCodecs).includes(type)) {\n      type += \"; codecs=\\\"\".concat(defaultCodecs[input], \"\\\"\");\n    }\n\n    try {\n      return Boolean(type && this.media.canPlayType(type).replace(/no/, ''));\n    } catch (e) {\n      return false;\n    }\n  },\n  // Check for textTracks support\n  textTracks: 'textTracks' in document.createElement('video'),\n  // <input type=\"range\"> Sliders\n  rangeInput: function () {\n    var range = document.createElement('input');\n    range.type = 'range';\n    return range.type === 'range';\n  }(),\n  // Touch\n  // NOTE: Remember a device can be mouse + touch enabled so we check on first touch event\n  touch: 'ontouchstart' in document.documentElement,\n  // Detect transitions support\n  transitions: transitionEndEvent !== false,\n  // Reduced motion iOS & MacOS setting\n  // https://webkit.org/blog/7551/responsive-design-for-motion/\n  reducedMotion: 'matchMedia' in window && window.matchMedia('(prefers-reduced-motion)').matches\n};\n\n// https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md\n// https://www.youtube.com/watch?v=NPM6172J22g\n\nvar supportsPassiveListeners = function () {\n  // Test via a getter in the options object to see if the passive property is accessed\n  var supported = false;\n\n  try {\n    var options = Object.defineProperty({}, 'passive', {\n      get: function get() {\n        supported = true;\n        return null;\n      }\n    });\n    window.addEventListener('test', null, options);\n    window.removeEventListener('test', null, options);\n  } catch (e) {// Do nothing\n  }\n\n  return supported;\n}(); // Toggle event listener\n\n\nfunction toggleListener(element, event, callback) {\n  var _this = this;\n\n  var toggle = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  var passive = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n  var capture = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n\n  // Bail if no element, event, or callback\n  if (!element || !('addEventListener' in element) || is$1.empty(event) || !is$1.function(callback)) {\n    return;\n  } // Allow multiple events\n\n\n  var events = event.split(' '); // Build options\n  // Default to just the capture boolean for browsers with no passive listener support\n\n  var options = capture; // If passive events listeners are supported\n\n  if (supportsPassiveListeners) {\n    options = {\n      // Whether the listener can be passive (i.e. default never prevented)\n      passive: passive,\n      // Whether the listener is a capturing listener or not\n      capture: capture\n    };\n  } // If a single node is passed, bind the event listener\n\n\n  events.forEach(function (type) {\n    if (_this && _this.eventListeners && toggle) {\n      // Cache event listener\n      _this.eventListeners.push({\n        element: element,\n        type: type,\n        callback: callback,\n        options: options\n      });\n    }\n\n    element[toggle ? 'addEventListener' : 'removeEventListener'](type, callback, options);\n  });\n} // Bind event handler\n\nfunction on(element) {\n  var events = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n  var callback = arguments.length > 2 ? arguments[2] : undefined;\n  var passive = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n  var capture = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n  toggleListener.call(this, element, events, callback, true, passive, capture);\n} // Unbind event handler\n\nfunction off(element) {\n  var events = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n  var callback = arguments.length > 2 ? arguments[2] : undefined;\n  var passive = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n  var capture = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n  toggleListener.call(this, element, events, callback, false, passive, capture);\n} // Bind once-only event handler\n\nfunction once(element) {\n  var _this2 = this;\n\n  var events = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n  var callback = arguments.length > 2 ? arguments[2] : undefined;\n  var passive = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n  var capture = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n\n  var onceCallback = function onceCallback() {\n    off(element, events, onceCallback, passive, capture);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    callback.apply(_this2, args);\n  };\n\n  toggleListener.call(this, element, events, onceCallback, true, passive, capture);\n} // Trigger event\n\nfunction triggerEvent(element) {\n  var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n  var bubbles = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var detail = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n  // Bail if no element\n  if (!is$1.element(element) || is$1.empty(type)) {\n    return;\n  } // Create and dispatch the event\n\n\n  var event = new CustomEvent(type, {\n    bubbles: bubbles,\n    detail: _objectSpread2(_objectSpread2({}, detail), {}, {\n      plyr: this\n    })\n  }); // Dispatch the event\n\n  element.dispatchEvent(event);\n} // Unbind all cached event listeners\n\nfunction unbindListeners() {\n  if (this && this.eventListeners) {\n    this.eventListeners.forEach(function (item) {\n      var element = item.element,\n          type = item.type,\n          callback = item.callback,\n          options = item.options;\n      element.removeEventListener(type, callback, options);\n    });\n    this.eventListeners = [];\n  }\n} // Run method when / if player is ready\n\nfunction ready() {\n  var _this3 = this;\n\n  return new Promise(function (resolve) {\n    return _this3.ready ? setTimeout(resolve, 0) : on.call(_this3, _this3.elements.container, 'ready', resolve);\n  }).then(function () {});\n}\n\n/**\n * Silence a Promise-like object.\n * This is useful for avoiding non-harmful, but potentially confusing \"uncaught\n * play promise\" rejection error messages.\n * @param  {Object} value An object that may or may not be `Promise`-like.\n */\n\nfunction silencePromise(value) {\n  if (is$1.promise(value)) {\n    value.then(null, function () {});\n  }\n}\n\nfunction validateRatio(input) {\n  if (!is$1.array(input) && (!is$1.string(input) || !input.includes(':'))) {\n    return false;\n  }\n\n  var ratio = is$1.array(input) ? input : input.split(':');\n  return ratio.map(Number).every(is$1.number);\n}\nfunction reduceAspectRatio(ratio) {\n  if (!is$1.array(ratio) || !ratio.every(is$1.number)) {\n    return null;\n  }\n\n  var _ratio = _slicedToArray(ratio, 2),\n      width = _ratio[0],\n      height = _ratio[1];\n\n  var getDivider = function getDivider(w, h) {\n    return h === 0 ? w : getDivider(h, w % h);\n  };\n\n  var divider = getDivider(width, height);\n  return [width / divider, height / divider];\n}\nfunction getAspectRatio(input) {\n  var parse = function parse(ratio) {\n    return validateRatio(ratio) ? ratio.split(':').map(Number) : null;\n  }; // Try provided ratio\n\n\n  var ratio = parse(input); // Get from config\n\n  if (ratio === null) {\n    ratio = parse(this.config.ratio);\n  } // Get from embed\n\n\n  if (ratio === null && !is$1.empty(this.embed) && is$1.array(this.embed.ratio)) {\n    ratio = this.embed.ratio;\n  } // Get from HTML5 video\n\n\n  if (ratio === null && this.isHTML5) {\n    var _this$media = this.media,\n        videoWidth = _this$media.videoWidth,\n        videoHeight = _this$media.videoHeight;\n    ratio = reduceAspectRatio([videoWidth, videoHeight]);\n  }\n\n  return ratio;\n} // Set aspect ratio for responsive container\n\nfunction setAspectRatio(input) {\n  if (!this.isVideo) {\n    return {};\n  }\n\n  var wrapper = this.elements.wrapper;\n  var ratio = getAspectRatio.call(this, input);\n\n  var _ref = is$1.array(ratio) ? ratio : [0, 0],\n      _ref2 = _slicedToArray(_ref, 2),\n      w = _ref2[0],\n      h = _ref2[1];\n\n  var padding = 100 / w * h;\n  wrapper.style.paddingBottom = \"\".concat(padding, \"%\"); // For Vimeo we have an extra <div> to hide the standard controls and UI\n\n  if (this.isVimeo && !this.config.vimeo.premium && this.supported.ui) {\n    var height = 100 / this.media.offsetWidth * parseInt(window.getComputedStyle(this.media).paddingBottom, 10);\n    var offset = (height - padding) / (height / 50);\n    this.media.style.transform = \"translateY(-\".concat(offset, \"%)\");\n  } else if (this.isHTML5) {\n    wrapper.classList.toggle(this.config.classNames.videoFixedRatio, ratio !== null);\n  }\n\n  return {\n    padding: padding,\n    ratio: ratio\n  };\n}\n\n// ==========================================================================\nvar html5 = {\n  getSources: function getSources() {\n    var _this = this;\n\n    if (!this.isHTML5) {\n      return [];\n    }\n\n    var sources = Array.from(this.media.querySelectorAll('source')); // Filter out unsupported sources (if type is specified)\n\n    return sources.filter(function (source) {\n      var type = source.getAttribute('type');\n\n      if (is$1.empty(type)) {\n        return true;\n      }\n\n      return support.mime.call(_this, type);\n    });\n  },\n  // Get quality levels\n  getQualityOptions: function getQualityOptions() {\n    // Whether we're forcing all options (e.g. for streaming)\n    if (this.config.quality.forced) {\n      return this.config.quality.options;\n    } // Get sizes from <source> elements\n\n\n    return html5.getSources.call(this).map(function (source) {\n      return Number(source.getAttribute('size'));\n    }).filter(Boolean);\n  },\n  setup: function setup() {\n    if (!this.isHTML5) {\n      return;\n    }\n\n    var player = this; // Set speed options from config\n\n    player.options.speed = player.config.speed.options; // Set aspect ratio if fixed\n\n    if (!is$1.empty(this.config.ratio)) {\n      setAspectRatio.call(player);\n    } // Quality\n\n\n    Object.defineProperty(player.media, 'quality', {\n      get: function get() {\n        // Get sources\n        var sources = html5.getSources.call(player);\n        var source = sources.find(function (s) {\n          return s.getAttribute('src') === player.source;\n        }); // Return size, if match is found\n\n        return source && Number(source.getAttribute('size'));\n      },\n      set: function set(input) {\n        if (player.quality === input) {\n          return;\n        } // If we're using an an external handler...\n\n\n        if (player.config.quality.forced && is$1.function(player.config.quality.onChange)) {\n          player.config.quality.onChange(input);\n        } else {\n          // Get sources\n          var sources = html5.getSources.call(player); // Get first match for requested size\n\n          var source = sources.find(function (s) {\n            return Number(s.getAttribute('size')) === input;\n          }); // No matching source found\n\n          if (!source) {\n            return;\n          } // Get current state\n\n\n          var _player$media = player.media,\n              currentTime = _player$media.currentTime,\n              paused = _player$media.paused,\n              preload = _player$media.preload,\n              readyState = _player$media.readyState,\n              playbackRate = _player$media.playbackRate; // Set new source\n\n          player.media.src = source.getAttribute('src'); // Prevent loading if preload=\"none\" and the current source isn't loaded (#1044)\n\n          if (preload !== 'none' || readyState) {\n            // Restore time\n            player.once('loadedmetadata', function () {\n              player.speed = playbackRate;\n              player.currentTime = currentTime; // Resume playing\n\n              if (!paused) {\n                silencePromise(player.play());\n              }\n            }); // Load new source\n\n            player.media.load();\n          }\n        } // Trigger change event\n\n\n        triggerEvent.call(player, player.media, 'qualitychange', false, {\n          quality: input\n        });\n      }\n    });\n  },\n  // Cancel current network requests\n  // See https://github.com/sampotts/WassPlayer/issues/174\n  cancelRequests: function cancelRequests() {\n    if (!this.isHTML5) {\n      return;\n    } // Remove child sources\n\n\n    removeElement(html5.getSources.call(this)); // Set blank video src attribute\n    // This is to prevent a MEDIA_ERR_SRC_NOT_SUPPORTED error\n    // Info: http://stackoverflow.com/questions/32231579/how-to-properly-dispose-of-an-html5-video-and-close-socket-or-connection\n\n    this.media.setAttribute('src', this.config.blankVideo); // Load the new empty source\n    // This will cancel existing requests\n    // See https://github.com/sampotts/WassPlayer/issues/174\n\n    this.media.load(); // Debugging\n\n    this.debug.log('Cancelled network requests');\n  }\n};\n\n// ==========================================================================\n\nfunction dedupe(array) {\n  if (!is$1.array(array)) {\n    return array;\n  }\n\n  return array.filter(function (item, index) {\n    return array.indexOf(item) === index;\n  });\n} // Get the closest value in an array\n\nfunction closest$1(array, value) {\n  if (!is$1.array(array) || !array.length) {\n    return null;\n  }\n\n  return array.reduce(function (prev, curr) {\n    return Math.abs(curr - value) < Math.abs(prev - value) ? curr : prev;\n  });\n}\n\n// ==========================================================================\n\nfunction getPercentage(current, max) {\n  if (current === 0 || max === 0 || Number.isNaN(current) || Number.isNaN(max)) {\n    return 0;\n  }\n\n  return (current / max * 100).toFixed(2);\n} // Replace all occurances of a string in a string\n\nvar replaceAll = function replaceAll() {\n  var input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  var find = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n  var replace = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n  return input.replace(new RegExp(find.toString().replace(/([.*+?^=!:${}()|[\\]/\\\\])/g, '\\\\$1'), 'g'), replace.toString());\n}; // Convert to title case\n\nvar toTitleCase = function toTitleCase() {\n  var input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  return input.toString().replace(/\\w\\S*/g, function (text) {\n    return text.charAt(0).toUpperCase() + text.substr(1).toLowerCase();\n  });\n}; // Convert string to pascalCase\n\nfunction toPascalCase() {\n  var input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  var string = input.toString(); // Convert kebab case\n\n  string = replaceAll(string, '-', ' '); // Convert snake case\n\n  string = replaceAll(string, '_', ' '); // Convert to title case\n\n  string = toTitleCase(string); // Convert to pascal case\n\n  return replaceAll(string, ' ', '');\n} // Convert string to pascalCase\n\nfunction toCamelCase() {\n  var input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  var string = input.toString(); // Convert to pascal case\n\n  string = toPascalCase(string); // Convert first character to lowercase\n\n  return string.charAt(0).toLowerCase() + string.slice(1);\n} // Remove HTML from a string\n\nfunction getHTML(element) {\n  var wrapper = document.createElement('div');\n  wrapper.appendChild(element);\n  return wrapper.innerHTML;\n}\n\nvar resources = {\n  pip: 'PIP',\n  airplay: 'AirPlay',\n  html5: 'HTML5',\n  vimeo: 'Vimeo',\n  youtube: 'YouTube'\n};\nvar i18n = {\n  get: function get() {\n    var key = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n    var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (is$1.empty(key) || is$1.empty(config)) {\n      return '';\n    }\n\n    var string = getDeep(config.i18n, key);\n\n    if (is$1.empty(string)) {\n      if (Object.keys(resources).includes(key)) {\n        return resources[key];\n      }\n\n      return '';\n    }\n\n    var replace = {\n      '{seektime}': config.seekTime,\n      '{title}': config.title\n    };\n    Object.entries(replace).forEach(function (_ref) {\n      var _ref2 = _slicedToArray(_ref, 2),\n          k = _ref2[0],\n          v = _ref2[1];\n\n      string = replaceAll(string, k, v);\n    });\n    return string;\n  }\n};\n\nvar Storage = /*#__PURE__*/function () {\n  function Storage(player) {\n    _classCallCheck(this, Storage);\n\n    this.enabled = player.config.storage.enabled;\n    this.key = player.config.storage.key;\n  } // Check for actual support (see if we can use it)\n\n\n  _createClass(Storage, [{\n    key: \"get\",\n    value: function get(key) {\n      if (!Storage.supported || !this.enabled) {\n        return null;\n      }\n\n      var store = window.localStorage.getItem(this.key);\n\n      if (is$1.empty(store)) {\n        return null;\n      }\n\n      var json = JSON.parse(store);\n      return is$1.string(key) && key.length ? json[key] : json;\n    }\n  }, {\n    key: \"set\",\n    value: function set(object) {\n      // Bail if we don't have localStorage support or it's disabled\n      if (!Storage.supported || !this.enabled) {\n        return;\n      } // Can only store objectst\n\n\n      if (!is$1.object(object)) {\n        return;\n      } // Get current storage\n\n\n      var storage = this.get(); // Default to empty object\n\n      if (is$1.empty(storage)) {\n        storage = {};\n      } // Update the working copy of the values\n\n\n      extend(storage, object); // Update storage\n\n      window.localStorage.setItem(this.key, JSON.stringify(storage));\n    }\n  }], [{\n    key: \"supported\",\n    get: function get() {\n      try {\n        if (!('localStorage' in window)) {\n          return false;\n        }\n\n        var test = '___test'; // Try to use it (it might be disabled, e.g. user is in private mode)\n        // see: https://github.com/sampotts/WassPlayer/issues/131\n\n        window.localStorage.setItem(test, test);\n        window.localStorage.removeItem(test);\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }\n  }]);\n\n  return Storage;\n}();\n\n// ==========================================================================\n// Fetch wrapper\n// Using XHR to avoid issues with older browsers\n// ==========================================================================\nfunction fetch(url) {\n  var responseType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'text';\n  return new Promise(function (resolve, reject) {\n    try {\n      var request = new XMLHttpRequest(); // Check for CORS support\n\n      if (!('withCredentials' in request)) {\n        return;\n      }\n\n      request.addEventListener('load', function () {\n        if (responseType === 'text') {\n          try {\n            resolve(JSON.parse(request.responseText));\n          } catch (e) {\n            resolve(request.responseText);\n          }\n        } else {\n          resolve(request.response);\n        }\n      });\n      request.addEventListener('error', function () {\n        throw new Error(request.status);\n      });\n      request.open('GET', url, true); // Set the required response type\n\n      request.responseType = responseType;\n      request.send();\n    } catch (e) {\n      reject(e);\n    }\n  });\n}\n\n// ==========================================================================\n\nfunction loadSprite(url, id) {\n  if (!is$1.string(url)) {\n    return;\n  }\n\n  var prefix = 'cache';\n  var hasId = is$1.string(id);\n  var isCached = false;\n\n  var exists = function exists() {\n    return document.getElementById(id) !== null;\n  };\n\n  var update = function update(container, data) {\n    // eslint-disable-next-line no-param-reassign\n    container.innerHTML = data; // Check again incase of race condition\n\n    if (hasId && exists()) {\n      return;\n    } // Inject the SVG to the body\n\n\n    document.body.insertAdjacentElement('afterbegin', container);\n  }; // Only load once if ID set\n\n\n  if (!hasId || !exists()) {\n    var useStorage = Storage.supported; // Create container\n\n    var container = document.createElement('div');\n    container.setAttribute('hidden', '');\n\n    if (hasId) {\n      container.setAttribute('id', id);\n    } // Check in cache\n\n\n    if (useStorage) {\n      var cached = window.localStorage.getItem(\"\".concat(prefix, \"-\").concat(id));\n      isCached = cached !== null;\n\n      if (isCached) {\n        var data = JSON.parse(cached);\n        update(container, data.content);\n      }\n    } // Get the sprite\n\n\n    fetch(url).then(function (result) {\n      if (is$1.empty(result)) {\n        return;\n      }\n\n      if (useStorage) {\n        window.localStorage.setItem(\"\".concat(prefix, \"-\").concat(id), JSON.stringify({\n          content: result\n        }));\n      }\n\n      update(container, result);\n    }).catch(function () {});\n  }\n}\n\n// ==========================================================================\n\nvar getHours = function getHours(value) {\n  return Math.trunc(value / 60 / 60 % 60, 10);\n};\nvar getMinutes = function getMinutes(value) {\n  return Math.trunc(value / 60 % 60, 10);\n};\nvar getSeconds = function getSeconds(value) {\n  return Math.trunc(value % 60, 10);\n}; // Format time to UI friendly string\n\nfunction formatTime() {\n  var time = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n  var displayHours = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var inverted = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n  // Bail if the value isn't a number\n  if (!is$1.number(time)) {\n    return formatTime(undefined, displayHours, inverted);\n  } // Format time component to add leading zero\n\n\n  var format = function format(value) {\n    return \"0\".concat(value).slice(-2);\n  }; // Breakdown to hours, mins, secs\n\n\n  var hours = getHours(time);\n  var mins = getMinutes(time);\n  var secs = getSeconds(time); // Do we need to display hours?\n\n  if (displayHours || hours > 0) {\n    hours = \"\".concat(hours, \":\");\n  } else {\n    hours = '';\n  } // Render\n\n\n  return \"\".concat(inverted && time > 0 ? '-' : '').concat(hours).concat(format(mins), \":\").concat(format(secs));\n}\n\nvar controls = {\n  // Get icon URL\n  getIconUrl: function getIconUrl() {\n    var url = new URL(this.config.iconUrl, window.location);\n    var cors = url.host !== window.location.host || browser.isIE && !window.svg4everybody;\n    return {\n      url: this.config.iconUrl,\n      cors: cors\n    };\n  },\n  // Find the UI controls\n  findElements: function findElements() {\n    try {\n      this.elements.controls = getElement.call(this, this.config.selectors.controls.wrapper); // Buttons\n\n      this.elements.buttons = {\n        play: getElements.call(this, this.config.selectors.buttons.play),\n        pause: getElement.call(this, this.config.selectors.buttons.pause),\n        restart: getElement.call(this, this.config.selectors.buttons.restart),\n        rewind: getElement.call(this, this.config.selectors.buttons.rewind),\n        fastForward: getElement.call(this, this.config.selectors.buttons.fastForward),\n        mute: getElement.call(this, this.config.selectors.buttons.mute),\n        pip: getElement.call(this, this.config.selectors.buttons.pip),\n        airplay: getElement.call(this, this.config.selectors.buttons.airplay),\n        settings: getElement.call(this, this.config.selectors.buttons.settings),\n        captions: getElement.call(this, this.config.selectors.buttons.captions),\n        fullscreen: getElement.call(this, this.config.selectors.buttons.fullscreen)\n      }; // Progress\n\n      this.elements.progress = getElement.call(this, this.config.selectors.progress); // Inputs\n\n      this.elements.inputs = {\n        seek: getElement.call(this, this.config.selectors.inputs.seek),\n        volume: getElement.call(this, this.config.selectors.inputs.volume)\n      }; // Display\n\n      this.elements.display = {\n        buffer: getElement.call(this, this.config.selectors.display.buffer),\n        currentTime: getElement.call(this, this.config.selectors.display.currentTime),\n        duration: getElement.call(this, this.config.selectors.display.duration)\n      }; // Seek tooltip\n\n      if (is$1.element(this.elements.progress)) {\n        this.elements.display.seekTooltip = this.elements.progress.querySelector(\".\".concat(this.config.classNames.tooltip));\n      }\n\n      return true;\n    } catch (error) {\n      // Log it\n      this.debug.warn('It looks like there is a problem with your custom controls HTML', error); // Restore native video controls\n\n      this.toggleNativeControls(true);\n      return false;\n    }\n  },\n  // Create <svg> icon\n  createIcon: function createIcon(type, attributes) {\n    var namespace = 'http://www.w3.org/2000/svg';\n    var iconUrl = controls.getIconUrl.call(this);\n    var iconPath = \"\".concat(!iconUrl.cors ? iconUrl.url : '', \"#\").concat(this.config.iconPrefix); // Create <svg>\n\n    var icon = document.createElementNS(namespace, 'svg');\n    setAttributes(icon, extend(attributes, {\n      'aria-hidden': 'true',\n      focusable: 'false'\n    })); // Create the <use> to reference sprite\n\n    var use = document.createElementNS(namespace, 'use');\n    var path = \"\".concat(iconPath, \"-\").concat(type); // Set `href` attributes\n    // https://github.com/sampotts/WassPlayer/issues/460\n    // https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/xlink:href\n\n    if ('href' in use) {\n      use.setAttributeNS('http://www.w3.org/1999/xlink', 'href', path);\n    } // Always set the older attribute even though it's \"deprecated\" (it'll be around for ages)\n\n\n    use.setAttributeNS('http://www.w3.org/1999/xlink', 'xlink:href', path); // Add <use> to <svg>\n\n    icon.appendChild(use);\n    return icon;\n  },\n  // Create hidden text label\n  createLabel: function createLabel(key) {\n    var attr = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var text = i18n.get(key, this.config);\n\n    var attributes = _objectSpread2(_objectSpread2({}, attr), {}, {\n      class: [attr.class, this.config.classNames.hidden].filter(Boolean).join(' ')\n    });\n\n    return createElement('span', attributes, text);\n  },\n  // Create a badge\n  createBadge: function createBadge(text) {\n    if (is$1.empty(text)) {\n      return null;\n    }\n\n    var badge = createElement('span', {\n      class: this.config.classNames.menu.value\n    });\n    badge.appendChild(createElement('span', {\n      class: this.config.classNames.menu.badge\n    }, text));\n    return badge;\n  },\n  // Create a <button>\n  createButton: function createButton(buttonType, attr) {\n    var _this = this;\n\n    var attributes = extend({}, attr);\n    var type = toCamelCase(buttonType);\n    var props = {\n      element: 'button',\n      toggle: false,\n      label: null,\n      icon: null,\n      labelPressed: null,\n      iconPressed: null\n    };\n    ['element', 'icon', 'label'].forEach(function (key) {\n      if (Object.keys(attributes).includes(key)) {\n        props[key] = attributes[key];\n        delete attributes[key];\n      }\n    }); // Default to 'button' type to prevent form submission\n\n    if (props.element === 'button' && !Object.keys(attributes).includes('type')) {\n      attributes.type = 'button';\n    } // Set class name\n\n\n    if (Object.keys(attributes).includes('class')) {\n      if (!attributes.class.split(' ').some(function (c) {\n        return c === _this.config.classNames.control;\n      })) {\n        extend(attributes, {\n          class: \"\".concat(attributes.class, \" \").concat(this.config.classNames.control)\n        });\n      }\n    } else {\n      attributes.class = this.config.classNames.control;\n    } // Large play button\n\n\n    switch (buttonType) {\n      case 'play':\n        props.toggle = true;\n        props.label = 'play';\n        props.labelPressed = 'pause';\n        props.icon = 'play';\n        props.iconPressed = 'pause';\n        break;\n\n      case 'mute':\n        props.toggle = true;\n        props.label = 'mute';\n        props.labelPressed = 'unmute';\n        props.icon = 'volume';\n        props.iconPressed = 'muted';\n        break;\n\n      case 'captions':\n        props.toggle = true;\n        props.label = 'enableCaptions';\n        props.labelPressed = 'disableCaptions';\n        props.icon = 'captions-off';\n        props.iconPressed = 'captions-on';\n        break;\n\n      case 'fullscreen':\n        props.toggle = true;\n        props.label = 'enterFullscreen';\n        props.labelPressed = 'exitFullscreen';\n        props.icon = 'enter-fullscreen';\n        props.iconPressed = 'exit-fullscreen';\n        break;\n\n      case 'play-large':\n        attributes.class += \" \".concat(this.config.classNames.control, \"--overlaid\");\n        type = 'play';\n        props.label = 'play';\n        props.icon = 'play';\n        break;\n\n      default:\n        if (is$1.empty(props.label)) {\n          props.label = type;\n        }\n\n        if (is$1.empty(props.icon)) {\n          props.icon = buttonType;\n        }\n\n    }\n\n    var button = createElement(props.element); // Setup toggle icon and labels\n\n    if (props.toggle) {\n      // Icon\n      button.appendChild(controls.createIcon.call(this, props.iconPressed, {\n        class: 'icon--pressed'\n      }));\n      button.appendChild(controls.createIcon.call(this, props.icon, {\n        class: 'icon--not-pressed'\n      })); // Label/Tooltip\n\n      button.appendChild(controls.createLabel.call(this, props.labelPressed, {\n        class: 'label--pressed'\n      }));\n      button.appendChild(controls.createLabel.call(this, props.label, {\n        class: 'label--not-pressed'\n      }));\n    } else {\n      button.appendChild(controls.createIcon.call(this, props.icon));\n      button.appendChild(controls.createLabel.call(this, props.label));\n    } // Merge and set attributes\n\n\n    extend(attributes, getAttributesFromSelector(this.config.selectors.buttons[type], attributes));\n    setAttributes(button, attributes); // We have multiple play buttons\n\n    if (type === 'play') {\n      if (!is$1.array(this.elements.buttons[type])) {\n        this.elements.buttons[type] = [];\n      }\n\n      this.elements.buttons[type].push(button);\n    } else {\n      this.elements.buttons[type] = button;\n    }\n\n    return button;\n  },\n  // Create an <input type='range'>\n  createRange: function createRange(type, attributes) {\n    // Seek input\n    var input = createElement('input', extend(getAttributesFromSelector(this.config.selectors.inputs[type]), {\n      type: 'range',\n      min: 0,\n      max: 100,\n      step: 0.01,\n      value: 0,\n      autocomplete: 'off',\n      // A11y fixes for https://github.com/sampotts/WassPlayer/issues/905\n      role: 'slider',\n      'aria-label': i18n.get(type, this.config),\n      'aria-valuemin': 0,\n      'aria-valuemax': 100,\n      'aria-valuenow': 0\n    }, attributes));\n    this.elements.inputs[type] = input; // Set the fill for webkit now\n\n    controls.updateRangeFill.call(this, input); // Improve support on touch devices\n\n    RangeTouch.setup(input);\n    return input;\n  },\n  // Create a <progress>\n  createProgress: function createProgress(type, attributes) {\n    var progress = createElement('progress', extend(getAttributesFromSelector(this.config.selectors.display[type]), {\n      min: 0,\n      max: 100,\n      value: 0,\n      role: 'progressbar',\n      'aria-hidden': true\n    }, attributes)); // Create the label inside\n\n    if (type !== 'volume') {\n      progress.appendChild(createElement('span', null, '0'));\n      var suffixKey = {\n        played: 'played',\n        buffer: 'buffered'\n      }[type];\n      var suffix = suffixKey ? i18n.get(suffixKey, this.config) : '';\n      progress.innerText = \"% \".concat(suffix.toLowerCase());\n    }\n\n    this.elements.display[type] = progress;\n    return progress;\n  },\n  // Create time display\n  createTime: function createTime(type, attrs) {\n    var attributes = getAttributesFromSelector(this.config.selectors.display[type], attrs);\n    var container = createElement('div', extend(attributes, {\n      class: \"\".concat(attributes.class ? attributes.class : '', \" \").concat(this.config.classNames.display.time, \" \").trim(),\n      'aria-label': i18n.get(type, this.config)\n    }), '00:00'); // Reference for updates\n\n    this.elements.display[type] = container;\n    return container;\n  },\n  // Bind keyboard shortcuts for a menu item\n  // We have to bind to keyup otherwise Firefox triggers a click when a keydown event handler shifts focus\n  // https://bugzilla.mozilla.org/show_bug.cgi?id=1220143\n  bindMenuItemShortcuts: function bindMenuItemShortcuts(menuItem, type) {\n    var _this2 = this;\n\n    // Navigate through menus via arrow keys and space\n    on.call(this, menuItem, 'keydown keyup', function (event) {\n      // We only care about space and ⬆️ ⬇️️ ➡️\n      if (![32, 38, 39, 40].includes(event.which)) {\n        return;\n      } // Prevent play / seek\n\n\n      event.preventDefault();\n      event.stopPropagation(); // We're just here to prevent the keydown bubbling\n\n      if (event.type === 'keydown') {\n        return;\n      }\n\n      var isRadioButton = matches$1(menuItem, '[role=\"menuitemradio\"]'); // Show the respective menu\n\n      if (!isRadioButton && [32, 39].includes(event.which)) {\n        controls.showMenuPanel.call(_this2, type, true);\n      } else {\n        var target;\n\n        if (event.which !== 32) {\n          if (event.which === 40 || isRadioButton && event.which === 39) {\n            target = menuItem.nextElementSibling;\n\n            if (!is$1.element(target)) {\n              target = menuItem.parentNode.firstElementChild;\n            }\n          } else {\n            target = menuItem.previousElementSibling;\n\n            if (!is$1.element(target)) {\n              target = menuItem.parentNode.lastElementChild;\n            }\n          }\n\n          setFocus.call(_this2, target, true);\n        }\n      }\n    }, false); // Enter will fire a `click` event but we still need to manage focus\n    // So we bind to keyup which fires after and set focus here\n\n    on.call(this, menuItem, 'keyup', function (event) {\n      if (event.which !== 13) {\n        return;\n      }\n\n      controls.focusFirstMenuItem.call(_this2, null, true);\n    });\n  },\n  // Create a settings menu item\n  createMenuItem: function createMenuItem(_ref) {\n    var _this3 = this;\n\n    var value = _ref.value,\n        list = _ref.list,\n        type = _ref.type,\n        title = _ref.title,\n        _ref$badge = _ref.badge,\n        badge = _ref$badge === void 0 ? null : _ref$badge,\n        _ref$checked = _ref.checked,\n        checked = _ref$checked === void 0 ? false : _ref$checked;\n    var attributes = getAttributesFromSelector(this.config.selectors.inputs[type]);\n    var menuItem = createElement('button', extend(attributes, {\n      type: 'button',\n      role: 'menuitemradio',\n      class: \"\".concat(this.config.classNames.control, \" \").concat(attributes.class ? attributes.class : '').trim(),\n      'aria-checked': checked,\n      value: value\n    }));\n    var flex = createElement('span'); // We have to set as HTML incase of special characters\n\n    flex.innerHTML = title;\n\n    if (is$1.element(badge)) {\n      flex.appendChild(badge);\n    }\n\n    menuItem.appendChild(flex); // Replicate radio button behaviour\n\n    Object.defineProperty(menuItem, 'checked', {\n      enumerable: true,\n      get: function get() {\n        return menuItem.getAttribute('aria-checked') === 'true';\n      },\n      set: function set(check) {\n        // Ensure exclusivity\n        if (check) {\n          Array.from(menuItem.parentNode.children).filter(function (node) {\n            return matches$1(node, '[role=\"menuitemradio\"]');\n          }).forEach(function (node) {\n            return node.setAttribute('aria-checked', 'false');\n          });\n        }\n\n        menuItem.setAttribute('aria-checked', check ? 'true' : 'false');\n      }\n    });\n    this.listeners.bind(menuItem, 'click keyup', function (event) {\n      if (is$1.keyboardEvent(event) && event.which !== 32) {\n        return;\n      }\n\n      event.preventDefault();\n      event.stopPropagation();\n      menuItem.checked = true;\n\n      switch (type) {\n        case 'language':\n          _this3.currentTrack = Number(value);\n          break;\n\n        case 'quality':\n          _this3.quality = value;\n          break;\n\n        case 'speed':\n          _this3.speed = parseFloat(value);\n          break;\n      }\n\n      controls.showMenuPanel.call(_this3, 'home', is$1.keyboardEvent(event));\n    }, type, false);\n    controls.bindMenuItemShortcuts.call(this, menuItem, type);\n    list.appendChild(menuItem);\n  },\n  // Format a time for display\n  formatTime: function formatTime$1() {\n    var time = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    var inverted = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n    // Bail if the value isn't a number\n    if (!is$1.number(time)) {\n      return time;\n    } // Always display hours if duration is over an hour\n\n\n    var forceHours = getHours(this.duration) > 0;\n    return formatTime(time, forceHours, inverted);\n  },\n  // Update the displayed time\n  updateTimeDisplay: function updateTimeDisplay() {\n    var target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    var time = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var inverted = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n    // Bail if there's no element to display or the value isn't a number\n    if (!is$1.element(target) || !is$1.number(time)) {\n      return;\n    } // eslint-disable-next-line no-param-reassign\n\n\n    target.innerText = controls.formatTime(time, inverted);\n  },\n  // Update volume UI and storage\n  updateVolume: function updateVolume() {\n    if (!this.supported.ui) {\n      return;\n    } // Update range\n\n\n    if (is$1.element(this.elements.inputs.volume)) {\n      controls.setRange.call(this, this.elements.inputs.volume, this.muted ? 0 : this.volume);\n    } // Update mute state\n\n\n    if (is$1.element(this.elements.buttons.mute)) {\n      this.elements.buttons.mute.pressed = this.muted || this.volume === 0;\n    }\n  },\n  // Update seek value and lower fill\n  setRange: function setRange(target) {\n    var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n    if (!is$1.element(target)) {\n      return;\n    } // eslint-disable-next-line\n\n\n    target.value = value; // Webkit range fill\n\n    controls.updateRangeFill.call(this, target);\n  },\n  // Update <progress> elements\n  updateProgress: function updateProgress(event) {\n    var _this4 = this;\n\n    if (!this.supported.ui || !is$1.event(event)) {\n      return;\n    }\n\n    var value = 0;\n\n    var setProgress = function setProgress(target, input) {\n      var val = is$1.number(input) ? input : 0;\n      var progress = is$1.element(target) ? target : _this4.elements.display.buffer; // Update value and label\n\n      if (is$1.element(progress)) {\n        progress.value = val; // Update text label inside\n\n        var label = progress.getElementsByTagName('span')[0];\n\n        if (is$1.element(label)) {\n          label.childNodes[0].nodeValue = val;\n        }\n      }\n    };\n\n    if (event) {\n      switch (event.type) {\n        // Video playing\n        case 'timeupdate':\n        case 'seeking':\n        case 'seeked':\n          value = getPercentage(this.currentTime, this.duration); // Set seek range value only if it's a 'natural' time event\n\n          if (event.type === 'timeupdate') {\n            controls.setRange.call(this, this.elements.inputs.seek, value);\n          }\n\n          break;\n        // Check buffer status\n\n        case 'playing':\n        case 'progress':\n          setProgress(this.elements.display.buffer, this.buffered * 100);\n          break;\n      }\n    }\n  },\n  // Webkit polyfill for lower fill range\n  updateRangeFill: function updateRangeFill(target) {\n    // Get range from event if event passed\n    var range = is$1.event(target) ? target.target : target; // Needs to be a valid <input type='range'>\n\n    if (!is$1.element(range) || range.getAttribute('type') !== 'range') {\n      return;\n    } // Set aria values for https://github.com/sampotts/WassPlayer/issues/905\n\n\n    if (matches$1(range, this.config.selectors.inputs.seek)) {\n      range.setAttribute('aria-valuenow', this.currentTime);\n      var currentTime = controls.formatTime(this.currentTime);\n      var duration = controls.formatTime(this.duration);\n      var format = i18n.get('seekLabel', this.config);\n      range.setAttribute('aria-valuetext', format.replace('{currentTime}', currentTime).replace('{duration}', duration));\n    } else if (matches$1(range, this.config.selectors.inputs.volume)) {\n      var percent = range.value * 100;\n      range.setAttribute('aria-valuenow', percent);\n      range.setAttribute('aria-valuetext', \"\".concat(percent.toFixed(1), \"%\"));\n    } else {\n      range.setAttribute('aria-valuenow', range.value);\n    } // WebKit only\n\n\n    if (!browser.isWebkit) {\n      return;\n    } // Set CSS custom property\n\n\n    range.style.setProperty('--value', \"\".concat(range.value / range.max * 100, \"%\"));\n  },\n  // Update hover tooltip for seeking\n  updateSeekTooltip: function updateSeekTooltip(event) {\n    var _this5 = this;\n\n    // Bail if setting not true\n    if (!this.config.tooltips.seek || !is$1.element(this.elements.inputs.seek) || !is$1.element(this.elements.display.seekTooltip) || this.duration === 0) {\n      return;\n    }\n\n    var visible = \"\".concat(this.config.classNames.tooltip, \"--visible\");\n\n    var toggle = function toggle(show) {\n      return toggleClass(_this5.elements.display.seekTooltip, visible, show);\n    }; // Hide on touch\n\n\n    if (this.touch) {\n      toggle(false);\n      return;\n    } // Determine percentage, if already visible\n\n\n    var percent = 0;\n    var clientRect = this.elements.progress.getBoundingClientRect();\n\n    if (is$1.event(event)) {\n      percent = 100 / clientRect.width * (event.pageX - clientRect.left);\n    } else if (hasClass(this.elements.display.seekTooltip, visible)) {\n      percent = parseFloat(this.elements.display.seekTooltip.style.left, 10);\n    } else {\n      return;\n    } // Set bounds\n\n\n    if (percent < 0) {\n      percent = 0;\n    } else if (percent > 100) {\n      percent = 100;\n    } // Display the time a click would seek to\n\n\n    controls.updateTimeDisplay.call(this, this.elements.display.seekTooltip, this.duration / 100 * percent); // Set position\n\n    this.elements.display.seekTooltip.style.left = \"\".concat(percent, \"%\"); // Show/hide the tooltip\n    // If the event is a moues in/out and percentage is inside bounds\n\n    if (is$1.event(event) && ['mouseenter', 'mouseleave'].includes(event.type)) {\n      toggle(event.type === 'mouseenter');\n    }\n  },\n  // Handle time change event\n  timeUpdate: function timeUpdate(event) {\n    // Only invert if only one time element is displayed and used for both duration and currentTime\n    var invert = !is$1.element(this.elements.display.duration) && this.config.invertTime; // Duration\n\n    controls.updateTimeDisplay.call(this, this.elements.display.currentTime, invert ? this.duration - this.currentTime : this.currentTime, invert); // Ignore updates while seeking\n\n    if (event && event.type === 'timeupdate' && this.media.seeking) {\n      return;\n    } // Playing progress\n\n\n    controls.updateProgress.call(this, event);\n  },\n  // Show the duration on metadataloaded or durationchange events\n  durationUpdate: function durationUpdate() {\n    // Bail if no UI or durationchange event triggered after playing/seek when invertTime is false\n    if (!this.supported.ui || !this.config.invertTime && this.currentTime) {\n      return;\n    } // If duration is the 2**32 (shaka), Infinity (HLS), DASH-IF (Number.MAX_SAFE_INTEGER || Number.MAX_VALUE) indicating live we hide the currentTime and progressbar.\n    // https://github.com/video-dev/hls.js/blob/5820d29d3c4c8a46e8b75f1e3afa3e68c1a9a2db/src/controller/buffer-controller.js#L415\n    // https://github.com/google/shaka-player/blob/4d889054631f4e1cf0fbd80ddd2b71887c02e232/lib/media/streaming_engine.js#L1062\n    // https://github.com/Dash-Industry-Forum/dash.js/blob/69859f51b969645b234666800d4cb596d89c602d/src/dash/models/DashManifestModel.js#L338\n\n\n    if (this.duration >= Math.pow(2, 32)) {\n      toggleHidden(this.elements.display.currentTime, true);\n      toggleHidden(this.elements.progress, true);\n      return;\n    } // Update ARIA values\n\n\n    if (is$1.element(this.elements.inputs.seek)) {\n      this.elements.inputs.seek.setAttribute('aria-valuemax', this.duration);\n    } // If there's a spot to display duration\n\n\n    var hasDuration = is$1.element(this.elements.display.duration); // If there's only one time display, display duration there\n\n    if (!hasDuration && this.config.displayDuration && this.paused) {\n      controls.updateTimeDisplay.call(this, this.elements.display.currentTime, this.duration);\n    } // If there's a duration element, update content\n\n\n    if (hasDuration) {\n      controls.updateTimeDisplay.call(this, this.elements.display.duration, this.duration);\n    } // Update the tooltip (if visible)\n\n\n    controls.updateSeekTooltip.call(this);\n  },\n  // Hide/show a tab\n  toggleMenuButton: function toggleMenuButton(setting, toggle) {\n    toggleHidden(this.elements.settings.buttons[setting], !toggle);\n  },\n  // Update the selected setting\n  updateSetting: function updateSetting(setting, container, input) {\n    var pane = this.elements.settings.panels[setting];\n    var value = null;\n    var list = container;\n\n    if (setting === 'captions') {\n      value = this.currentTrack;\n    } else {\n      value = !is$1.empty(input) ? input : this[setting]; // Get default\n\n      if (is$1.empty(value)) {\n        value = this.config[setting].default;\n      } // Unsupported value\n\n\n      if (!is$1.empty(this.options[setting]) && !this.options[setting].includes(value)) {\n        this.debug.warn(\"Unsupported value of '\".concat(value, \"' for \").concat(setting));\n        return;\n      } // Disabled value\n\n\n      if (!this.config[setting].options.includes(value)) {\n        this.debug.warn(\"Disabled value of '\".concat(value, \"' for \").concat(setting));\n        return;\n      }\n    } // Get the list if we need to\n\n\n    if (!is$1.element(list)) {\n      list = pane && pane.querySelector('[role=\"menu\"]');\n    } // If there's no list it means it's not been rendered...\n\n\n    if (!is$1.element(list)) {\n      return;\n    } // Update the label\n\n\n    var label = this.elements.settings.buttons[setting].querySelector(\".\".concat(this.config.classNames.menu.value));\n    label.innerHTML = controls.getLabel.call(this, setting, value); // Find the radio option and check it\n\n    var target = list && list.querySelector(\"[value=\\\"\".concat(value, \"\\\"]\"));\n\n    if (is$1.element(target)) {\n      target.checked = true;\n    }\n  },\n  // Translate a value into a nice label\n  getLabel: function getLabel(setting, value) {\n    switch (setting) {\n      case 'speed':\n        return value === 1 ? i18n.get('normal', this.config) : \"\".concat(value, \"&times;\");\n\n      case 'quality':\n        if (is$1.number(value)) {\n          var label = i18n.get(\"qualityLabel.\".concat(value), this.config);\n\n          if (!label.length) {\n            return \"\".concat(value, \"p\");\n          }\n\n          return label;\n        }\n\n        return toTitleCase(value);\n\n      case 'captions':\n        return captions.getLabel.call(this);\n\n      default:\n        return null;\n    }\n  },\n  // Set the quality menu\n  setQualityMenu: function setQualityMenu(options) {\n    var _this6 = this;\n\n    // Menu required\n    if (!is$1.element(this.elements.settings.panels.quality)) {\n      return;\n    }\n\n    var type = 'quality';\n    var list = this.elements.settings.panels.quality.querySelector('[role=\"menu\"]'); // Set options if passed and filter based on uniqueness and config\n\n    if (is$1.array(options)) {\n      this.options.quality = dedupe(options).filter(function (quality) {\n        return _this6.config.quality.options.includes(quality);\n      });\n    } // Toggle the pane and tab\n\n\n    var toggle = !is$1.empty(this.options.quality) && this.options.quality.length > 1;\n    controls.toggleMenuButton.call(this, type, toggle); // Empty the menu\n\n    emptyElement(list); // Check if we need to toggle the parent\n\n    controls.checkMenu.call(this); // If we're hiding, nothing more to do\n\n    if (!toggle) {\n      return;\n    } // Get the badge HTML for HD, 4K etc\n\n\n    var getBadge = function getBadge(quality) {\n      var label = i18n.get(\"qualityBadge.\".concat(quality), _this6.config);\n\n      if (!label.length) {\n        return null;\n      }\n\n      return controls.createBadge.call(_this6, label);\n    }; // Sort options by the config and then render options\n\n\n    this.options.quality.sort(function (a, b) {\n      var sorting = _this6.config.quality.options;\n      return sorting.indexOf(a) > sorting.indexOf(b) ? 1 : -1;\n    }).forEach(function (quality) {\n      controls.createMenuItem.call(_this6, {\n        value: quality,\n        list: list,\n        type: type,\n        title: controls.getLabel.call(_this6, 'quality', quality),\n        badge: getBadge(quality)\n      });\n    });\n    controls.updateSetting.call(this, type, list);\n  },\n  // Set the looping options\n\n  /* setLoopMenu() {\n        // Menu required\n        if (!is.element(this.elements.settings.panels.loop)) {\n            return;\n        }\n         const options = ['start', 'end', 'all', 'reset'];\n        const list = this.elements.settings.panels.loop.querySelector('[role=\"menu\"]');\n         // Show the pane and tab\n        toggleHidden(this.elements.settings.buttons.loop, false);\n        toggleHidden(this.elements.settings.panels.loop, false);\n         // Toggle the pane and tab\n        const toggle = !is.empty(this.loop.options);\n        controls.toggleMenuButton.call(this, 'loop', toggle);\n         // Empty the menu\n        emptyElement(list);\n         options.forEach(option => {\n            const item = createElement('li');\n             const button = createElement(\n                'button',\n                extend(getAttributesFromSelector(this.config.selectors.buttons.loop), {\n                    type: 'button',\n                    class: this.config.classNames.control,\n                    'data-wassPlayer-loop-action': option,\n                }),\n                i18n.get(option, this.config)\n            );\n             if (['start', 'end'].includes(option)) {\n                const badge = controls.createBadge.call(this, '00:00');\n                button.appendChild(badge);\n            }\n             item.appendChild(button);\n            list.appendChild(item);\n        });\n    }, */\n  // Get current selected caption language\n  // Set a list of available captions languages\n  setCaptionsMenu: function setCaptionsMenu() {\n    var _this7 = this;\n\n    // Menu required\n    if (!is$1.element(this.elements.settings.panels.captions)) {\n      return;\n    }\n\n    var type = 'captions';\n    var list = this.elements.settings.panels.captions.querySelector('[role=\"menu\"]');\n    var tracks = captions.getTracks.call(this);\n    var toggle = Boolean(tracks.length); // Toggle the pane and tab\n\n    controls.toggleMenuButton.call(this, type, toggle); // Empty the menu\n\n    emptyElement(list); // Check if we need to toggle the parent\n\n    controls.checkMenu.call(this); // If there's no captions, bail\n\n    if (!toggle) {\n      return;\n    } // Generate options data\n\n\n    var options = tracks.map(function (track, value) {\n      return {\n        value: value,\n        checked: _this7.captions.toggled && _this7.currentTrack === value,\n        title: captions.getLabel.call(_this7, track),\n        badge: track.language && controls.createBadge.call(_this7, track.language.toUpperCase()),\n        list: list,\n        type: 'language'\n      };\n    }); // Add the \"Disabled\" option to turn off captions\n\n    options.unshift({\n      value: -1,\n      checked: !this.captions.toggled,\n      title: i18n.get('disabled', this.config),\n      list: list,\n      type: 'language'\n    }); // Generate options\n\n    options.forEach(controls.createMenuItem.bind(this));\n    controls.updateSetting.call(this, type, list);\n  },\n  // Set a list of available captions languages\n  setSpeedMenu: function setSpeedMenu() {\n    var _this8 = this;\n\n    // Menu required\n    if (!is$1.element(this.elements.settings.panels.speed)) {\n      return;\n    }\n\n    var type = 'speed';\n    var list = this.elements.settings.panels.speed.querySelector('[role=\"menu\"]'); // Filter out invalid speeds\n\n    this.options.speed = this.options.speed.filter(function (o) {\n      return o >= _this8.minimumSpeed && o <= _this8.maximumSpeed;\n    }); // Toggle the pane and tab\n\n    var toggle = !is$1.empty(this.options.speed) && this.options.speed.length > 1;\n    controls.toggleMenuButton.call(this, type, toggle); // Empty the menu\n\n    emptyElement(list); // Check if we need to toggle the parent\n\n    controls.checkMenu.call(this); // If we're hiding, nothing more to do\n\n    if (!toggle) {\n      return;\n    } // Create items\n\n\n    this.options.speed.forEach(function (speed) {\n      controls.createMenuItem.call(_this8, {\n        value: speed,\n        list: list,\n        type: type,\n        title: controls.getLabel.call(_this8, 'speed', speed)\n      });\n    });\n    controls.updateSetting.call(this, type, list);\n  },\n  // Check if we need to hide/show the settings menu\n  checkMenu: function checkMenu() {\n    var buttons = this.elements.settings.buttons;\n    var visible = !is$1.empty(buttons) && Object.values(buttons).some(function (button) {\n      return !button.hidden;\n    });\n    toggleHidden(this.elements.settings.menu, !visible);\n  },\n  // Focus the first menu item in a given (or visible) menu\n  focusFirstMenuItem: function focusFirstMenuItem(pane) {\n    var tabFocus = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n    if (this.elements.settings.popup.hidden) {\n      return;\n    }\n\n    var target = pane;\n\n    if (!is$1.element(target)) {\n      target = Object.values(this.elements.settings.panels).find(function (p) {\n        return !p.hidden;\n      });\n    }\n\n    var firstItem = target.querySelector('[role^=\"menuitem\"]');\n    setFocus.call(this, firstItem, tabFocus);\n  },\n  // Show/hide menu\n  toggleMenu: function toggleMenu(input) {\n    var popup = this.elements.settings.popup;\n    var button = this.elements.buttons.settings; // Menu and button are required\n\n    if (!is$1.element(popup) || !is$1.element(button)) {\n      return;\n    } // True toggle by default\n\n\n    var hidden = popup.hidden;\n    var show = hidden;\n\n    if (is$1.boolean(input)) {\n      show = input;\n    } else if (is$1.keyboardEvent(input) && input.which === 27) {\n      show = false;\n    } else if (is$1.event(input)) {\n      // If WassPlayer is in a shadowDOM, the event target is set to the component, instead of the\n      // Element in the shadowDOM. The path, if available, is complete.\n      var target = is$1.function(input.composedPath) ? input.composedPath()[0] : input.target;\n      var isMenuItem = popup.contains(target); // If the click was inside the menu or if the click\n      // wasn't the button or menu item and we're trying to\n      // show the menu (a doc click shouldn't show the menu)\n\n      if (isMenuItem || !isMenuItem && input.target !== button && show) {\n        return;\n      }\n    } // Set button attributes\n\n\n    button.setAttribute('aria-expanded', show); // Show the actual popup\n\n    toggleHidden(popup, !show); // Add class hook\n\n    toggleClass(this.elements.container, this.config.classNames.menu.open, show); // Focus the first item if key interaction\n\n    if (show && is$1.keyboardEvent(input)) {\n      controls.focusFirstMenuItem.call(this, null, true);\n    } else if (!show && !hidden) {\n      // If closing, re-focus the button\n      setFocus.call(this, button, is$1.keyboardEvent(input));\n    }\n  },\n  // Get the natural size of a menu panel\n  getMenuSize: function getMenuSize(tab) {\n    var clone = tab.cloneNode(true);\n    clone.style.position = 'absolute';\n    clone.style.opacity = 0;\n    clone.removeAttribute('hidden'); // Append to parent so we get the \"real\" size\n\n    tab.parentNode.appendChild(clone); // Get the sizes before we remove\n\n    var width = clone.scrollWidth;\n    var height = clone.scrollHeight; // Remove from the DOM\n\n    removeElement(clone);\n    return {\n      width: width,\n      height: height\n    };\n  },\n  // Show a panel in the menu\n  showMenuPanel: function showMenuPanel() {\n    var _this9 = this;\n\n    var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n    var tabFocus = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    var target = this.elements.container.querySelector(\"#wassPlayer-settings-\".concat(this.id, \"-\").concat(type)); // Nothing to show, bail\n\n    if (!is$1.element(target)) {\n      return;\n    } // Hide all other panels\n\n\n    var container = target.parentNode;\n    var current = Array.from(container.children).find(function (node) {\n      return !node.hidden;\n    }); // If we can do fancy animations, we'll animate the height/width\n\n    if (support.transitions && !support.reducedMotion) {\n      // Set the current width as a base\n      container.style.width = \"\".concat(current.scrollWidth, \"px\");\n      container.style.height = \"\".concat(current.scrollHeight, \"px\"); // Get potential sizes\n\n      var size = controls.getMenuSize.call(this, target); // Restore auto height/width\n\n      var restore = function restore(event) {\n        // We're only bothered about height and width on the container\n        if (event.target !== container || !['width', 'height'].includes(event.propertyName)) {\n          return;\n        } // Revert back to auto\n\n\n        container.style.width = '';\n        container.style.height = ''; // Only listen once\n\n        off.call(_this9, container, transitionEndEvent, restore);\n      }; // Listen for the transition finishing and restore auto height/width\n\n\n      on.call(this, container, transitionEndEvent, restore); // Set dimensions to target\n\n      container.style.width = \"\".concat(size.width, \"px\");\n      container.style.height = \"\".concat(size.height, \"px\");\n    } // Set attributes on current tab\n\n\n    toggleHidden(current, true); // Set attributes on target\n\n    toggleHidden(target, false); // Focus the first item\n\n    controls.focusFirstMenuItem.call(this, target, tabFocus);\n  },\n  // Set the download URL\n  setDownloadUrl: function setDownloadUrl() {\n    var button = this.elements.buttons.download; // Bail if no button\n\n    if (!is$1.element(button)) {\n      return;\n    } // Set attribute\n\n\n    button.setAttribute('href', this.download);\n  },\n  // Build the default HTML\n  create: function create(data) {\n    var _this10 = this;\n\n    var bindMenuItemShortcuts = controls.bindMenuItemShortcuts,\n        createButton = controls.createButton,\n        createProgress = controls.createProgress,\n        createRange = controls.createRange,\n        createTime = controls.createTime,\n        setQualityMenu = controls.setQualityMenu,\n        setSpeedMenu = controls.setSpeedMenu,\n        showMenuPanel = controls.showMenuPanel;\n    this.elements.controls = null; // Larger overlaid play button\n\n    if (is$1.array(this.config.controls) && this.config.controls.includes('play-large')) {\n      this.elements.container.appendChild(createButton.call(this, 'play-large'));\n    } // Create the container\n\n\n    var container = createElement('div', getAttributesFromSelector(this.config.selectors.controls.wrapper));\n    this.elements.controls = container; // Default item attributes\n\n    var defaultAttributes = {\n      class: 'wassPlayer__controls__item'\n    }; // Loop through controls in order\n\n    dedupe(is$1.array(this.config.controls) ? this.config.controls : []).forEach(function (control) {\n      // Restart button\n      if (control === 'restart') {\n        container.appendChild(createButton.call(_this10, 'restart', defaultAttributes));\n      } // Rewind button\n\n\n      if (control === 'rewind') {\n        container.appendChild(createButton.call(_this10, 'rewind', defaultAttributes));\n      } // Play/Pause button\n\n\n      if (control === 'play') {\n        container.appendChild(createButton.call(_this10, 'play', defaultAttributes));\n      } // Fast forward button\n\n\n      if (control === 'fast-forward') {\n        container.appendChild(createButton.call(_this10, 'fast-forward', defaultAttributes));\n      } // Progress\n\n\n      if (control === 'progress') {\n        var progressContainer = createElement('div', {\n          class: \"\".concat(defaultAttributes.class, \" wassPlayer__progress__container\")\n        });\n        var progress = createElement('div', getAttributesFromSelector(_this10.config.selectors.progress)); // Seek range slider\n\n        progress.appendChild(createRange.call(_this10, 'seek', {\n          id: \"wassPlayer-seek-\".concat(data.id)\n        })); // Buffer progress\n\n        progress.appendChild(createProgress.call(_this10, 'buffer')); // Seek tooltip\n\n        if (_this10.config.tooltips.seek) {\n          var tooltip = createElement('span', {\n            class: _this10.config.classNames.tooltip\n          }, '00:00');\n          progress.appendChild(tooltip);\n          _this10.elements.display.seekTooltip = tooltip;\n        }\n\n        _this10.elements.progress = progress;\n        progressContainer.appendChild(_this10.elements.progress);\n        container.appendChild(progressContainer);\n      } // Media current time display\n\n\n      if (control === 'current-time') {\n        container.appendChild(createTime.call(_this10, 'currentTime', defaultAttributes));\n      } // Media duration display\n\n\n      if (control === 'duration') {\n        container.appendChild(createTime.call(_this10, 'duration', defaultAttributes));\n      } // Volume controls\n\n\n      if (control === 'mute' || control === 'volume') {\n        var volume = _this10.elements.volume; // Create the volume container if needed\n\n        if (!is$1.element(volume) || !container.contains(volume)) {\n          volume = createElement('div', extend({}, defaultAttributes, {\n            class: \"\".concat(defaultAttributes.class, \" wassPlayer__volume\").trim()\n          }));\n          _this10.elements.volume = volume;\n          container.appendChild(volume);\n        } // Toggle mute button\n\n\n        if (control === 'mute') {\n          volume.appendChild(createButton.call(_this10, 'mute'));\n        } // Volume range control\n        // Ignored on iOS as it's handled globally\n        // https://developer.apple.com/library/safari/documentation/AudioVideo/Conceptual/Using_HTML5_Audio_Video/Device-SpecificConsiderations/Device-SpecificConsiderations.html\n\n\n        if (control === 'volume' && !browser.isIos) {\n          // Set the attributes\n          var attributes = {\n            max: 1,\n            step: 0.05,\n            value: _this10.config.volume\n          }; // Create the volume range slider\n\n          volume.appendChild(createRange.call(_this10, 'volume', extend(attributes, {\n            id: \"wassPlayer-volume-\".concat(data.id)\n          })));\n        }\n      } // Toggle captions button\n\n\n      if (control === 'captions') {\n        container.appendChild(createButton.call(_this10, 'captions', defaultAttributes));\n      } // Settings button / menu\n\n\n      if (control === 'settings' && !is$1.empty(_this10.config.settings)) {\n        var wrapper = createElement('div', extend({}, defaultAttributes, {\n          class: \"\".concat(defaultAttributes.class, \" wassPlayer__menu\").trim(),\n          hidden: ''\n        }));\n        wrapper.appendChild(createButton.call(_this10, 'settings', {\n          'aria-haspopup': true,\n          'aria-controls': \"wassPlayer-settings-\".concat(data.id),\n          'aria-expanded': false\n        }));\n        var popup = createElement('div', {\n          class: 'wassPlayer__menu__container',\n          id: \"wassPlayer-settings-\".concat(data.id),\n          hidden: ''\n        });\n        var inner = createElement('div');\n        var home = createElement('div', {\n          id: \"wassPlayer-settings-\".concat(data.id, \"-home\")\n        }); // Create the menu\n\n        var menu = createElement('div', {\n          role: 'menu'\n        });\n        home.appendChild(menu);\n        inner.appendChild(home);\n        _this10.elements.settings.panels.home = home; // Build the menu items\n\n        _this10.config.settings.forEach(function (type) {\n          var menuItem = createElement('button', extend(getAttributesFromSelector(_this10.config.selectors.buttons.settings), {\n            type: 'button',\n            class: \"\".concat(_this10.config.classNames.control, \" \").concat(_this10.config.classNames.control, \"--forward\"),\n            role: 'menuitem',\n            'aria-haspopup': true,\n            hidden: ''\n          })); // Bind menu shortcuts for keyboard users\n\n          bindMenuItemShortcuts.call(_this10, menuItem, type); // Show menu on click\n\n          on.call(_this10, menuItem, 'click', function () {\n            showMenuPanel.call(_this10, type, false);\n          });\n          var flex = createElement('span', null, i18n.get(type, _this10.config));\n          var value = createElement('span', {\n            class: _this10.config.classNames.menu.value\n          }); // Speed contains HTML entities\n\n          value.innerHTML = data[type];\n          flex.appendChild(value);\n          menuItem.appendChild(flex);\n          menu.appendChild(menuItem); // Build the panes\n\n          var pane = createElement('div', {\n            id: \"wassPlayer-settings-\".concat(data.id, \"-\").concat(type),\n            hidden: ''\n          }); // Back button\n\n          var backButton = createElement('button', {\n            type: 'button',\n            class: \"\".concat(_this10.config.classNames.control, \" \").concat(_this10.config.classNames.control, \"--back\")\n          }); // Visible label\n\n          backButton.appendChild(createElement('span', {\n            'aria-hidden': true\n          }, i18n.get(type, _this10.config))); // Screen reader label\n\n          backButton.appendChild(createElement('span', {\n            class: _this10.config.classNames.hidden\n          }, i18n.get('menuBack', _this10.config))); // Go back via keyboard\n\n          on.call(_this10, pane, 'keydown', function (event) {\n            // We only care about <-\n            if (event.which !== 37) {\n              return;\n            } // Prevent seek\n\n\n            event.preventDefault();\n            event.stopPropagation(); // Show the respective menu\n\n            showMenuPanel.call(_this10, 'home', true);\n          }, false); // Go back via button click\n\n          on.call(_this10, backButton, 'click', function () {\n            showMenuPanel.call(_this10, 'home', false);\n          }); // Add to pane\n\n          pane.appendChild(backButton); // Menu\n\n          pane.appendChild(createElement('div', {\n            role: 'menu'\n          }));\n          inner.appendChild(pane);\n          _this10.elements.settings.buttons[type] = menuItem;\n          _this10.elements.settings.panels[type] = pane;\n        });\n\n        popup.appendChild(inner);\n        wrapper.appendChild(popup);\n        container.appendChild(wrapper);\n        _this10.elements.settings.popup = popup;\n        _this10.elements.settings.menu = wrapper;\n      } // Picture in picture button\n\n\n      if (control === 'pip' && support.pip) {\n        container.appendChild(createButton.call(_this10, 'pip', defaultAttributes));\n      } // Airplay button\n\n\n      if (control === 'airplay' && support.airplay) {\n        container.appendChild(createButton.call(_this10, 'airplay', defaultAttributes));\n      } // Download button\n\n\n      if (control === 'download') {\n        var _attributes = extend({}, defaultAttributes, {\n          element: 'a',\n          href: _this10.download,\n          target: '_blank'\n        }); // Set download attribute for HTML5 only\n\n\n        if (_this10.isHTML5) {\n          _attributes.download = '';\n        }\n\n        var download = _this10.config.urls.download;\n\n        if (!is$1.url(download) && _this10.isEmbed) {\n          extend(_attributes, {\n            icon: \"logo-\".concat(_this10.provider),\n            label: _this10.provider\n          });\n        }\n\n        container.appendChild(createButton.call(_this10, 'download', _attributes));\n      } // Toggle fullscreen button\n\n\n      if (control === 'fullscreen') {\n        container.appendChild(createButton.call(_this10, 'fullscreen', defaultAttributes));\n      }\n    }); // Set available quality levels\n\n    if (this.isHTML5) {\n      setQualityMenu.call(this, html5.getQualityOptions.call(this));\n    }\n\n    setSpeedMenu.call(this);\n    return container;\n  },\n  // Insert controls\n  inject: function inject() {\n    var _this11 = this;\n\n    // Sprite\n    if (this.config.loadSprite) {\n      var icon = controls.getIconUrl.call(this); // Only load external sprite using AJAX\n\n      if (icon.cors) {\n        loadSprite(icon.url, 'sprite-wassPlayer');\n      }\n    } // Create a unique ID\n\n\n    this.id = Math.floor(Math.random() * 10000); // Null by default\n\n    var container = null;\n    this.elements.controls = null; // Set template properties\n\n    var props = {\n      id: this.id,\n      seektime: this.config.seekTime,\n      title: this.config.title\n    };\n    var update = true; // If function, run it and use output\n\n    if (is$1.function(this.config.controls)) {\n      this.config.controls = this.config.controls.call(this, props);\n    } // Convert falsy controls to empty array (primarily for empty strings)\n\n\n    if (!this.config.controls) {\n      this.config.controls = [];\n    }\n\n    if (is$1.element(this.config.controls) || is$1.string(this.config.controls)) {\n      // HTMLElement or Non-empty string passed as the option\n      container = this.config.controls;\n    } else {\n      // Create controls\n      container = controls.create.call(this, {\n        id: this.id,\n        seektime: this.config.seekTime,\n        speed: this.speed,\n        quality: this.quality,\n        captions: captions.getLabel.call(this) // loop: 'None',\n\n      });\n      update = false;\n    } // Replace props with their value\n\n\n    var replace = function replace(input) {\n      var result = input;\n      Object.entries(props).forEach(function (_ref2) {\n        var _ref3 = _slicedToArray(_ref2, 2),\n            key = _ref3[0],\n            value = _ref3[1];\n\n        result = replaceAll(result, \"{\".concat(key, \"}\"), value);\n      });\n      return result;\n    }; // Update markup\n\n\n    if (update) {\n      if (is$1.string(this.config.controls)) {\n        container = replace(container);\n      }\n    } // Controls container\n\n\n    var target; // Inject to custom location\n\n    if (is$1.string(this.config.selectors.controls.container)) {\n      target = document.querySelector(this.config.selectors.controls.container);\n    } // Inject into the container by default\n\n\n    if (!is$1.element(target)) {\n      target = this.elements.container;\n    } // Inject controls HTML (needs to be before captions, hence \"afterbegin\")\n\n\n    var insertMethod = is$1.element(container) ? 'insertAdjacentElement' : 'insertAdjacentHTML';\n    target[insertMethod]('afterbegin', container); // Find the elements if need be\n\n    if (!is$1.element(this.elements.controls)) {\n      controls.findElements.call(this);\n    } // Add pressed property to buttons\n\n\n    if (!is$1.empty(this.elements.buttons)) {\n      var addProperty = function addProperty(button) {\n        var className = _this11.config.classNames.controlPressed;\n        Object.defineProperty(button, 'pressed', {\n          enumerable: true,\n          get: function get() {\n            return hasClass(button, className);\n          },\n          set: function set() {\n            var pressed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n            toggleClass(button, className, pressed);\n          }\n        });\n      }; // Toggle classname when pressed property is set\n\n\n      Object.values(this.elements.buttons).filter(Boolean).forEach(function (button) {\n        if (is$1.array(button) || is$1.nodeList(button)) {\n          Array.from(button).filter(Boolean).forEach(addProperty);\n        } else {\n          addProperty(button);\n        }\n      });\n    } // Edge sometimes doesn't finish the paint so force a repaint\n\n\n    if (browser.isEdge) {\n      repaint(target);\n    } // Setup tooltips\n\n\n    if (this.config.tooltips.controls) {\n      var _this$config = this.config,\n          classNames = _this$config.classNames,\n          selectors = _this$config.selectors;\n      var selector = \"\".concat(selectors.controls.wrapper, \" \").concat(selectors.labels, \" .\").concat(classNames.hidden);\n      var labels = getElements.call(this, selector);\n      Array.from(labels).forEach(function (label) {\n        toggleClass(label, _this11.config.classNames.hidden, false);\n        toggleClass(label, _this11.config.classNames.tooltip, true);\n      });\n    }\n  }\n};\n\n/**\n * Parse a string to a URL object\n * @param {String} input - the URL to be parsed\n * @param {Boolean} safe - failsafe parsing\n */\n\nfunction parseUrl(input) {\n  var safe = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  var url = input;\n\n  if (safe) {\n    var parser = document.createElement('a');\n    parser.href = url;\n    url = parser.href;\n  }\n\n  try {\n    return new URL(url);\n  } catch (e) {\n    return null;\n  }\n} // Convert object to URLSearchParams\n\nvar captions = {\n  // Setup captions\n  setup: function setup() {\n    // Requires UI support\n    if (!this.supported.ui) {\n      return;\n    } // Only Vimeo and HTML5 video supported at this point\n\n\n    if (!this.isVideo || this.isYouTube || this.isHTML5 && !support.textTracks) {\n      // Clear menu and hide\n      if (is$1.array(this.config.controls) && this.config.controls.includes('settings') && this.config.settings.includes('captions')) {\n        controls.setCaptionsMenu.call(this);\n      }\n\n      return;\n    } // Inject the container\n\n\n    if (!is$1.element(this.elements.captions)) {\n      this.elements.captions = createElement('div', getAttributesFromSelector(this.config.selectors.captions));\n      insertAfter(this.elements.captions, this.elements.wrapper);\n    } // Fix IE captions if CORS is used\n    // Fetch captions and inject as blobs instead (data URIs not supported!)\n\n\n    if (browser.isIE && window.URL) {\n      var elements = this.media.querySelectorAll('track');\n      Array.from(elements).forEach(function (track) {\n        var src = track.getAttribute('src');\n        var url = parseUrl(src);\n\n        if (url !== null && url.hostname !== window.location.href.hostname && ['http:', 'https:'].includes(url.protocol)) {\n          fetch(src, 'blob').then(function (blob) {\n            track.setAttribute('src', window.URL.createObjectURL(blob));\n          }).catch(function () {\n            removeElement(track);\n          });\n        }\n      });\n    }\n\n    var browserLanguages = navigator.languages || [navigator.language || navigator.userLanguage || 'en'];\n    var languages = dedupe(browserLanguages.map(function (language) {\n      return language.split('-')[0];\n    }));\n    var language = (this.storage.get('language') || this.config.captions.language || 'auto').toLowerCase(); // Use first browser language when language is 'auto'\n\n    if (language === 'auto') {\n      var _languages = _slicedToArray(languages, 1);\n\n      language = _languages[0];\n    }\n\n    var active = this.storage.get('captions');\n\n    if (!is$1.boolean(active)) {\n      active = this.config.captions.active;\n    }\n\n    Object.assign(this.captions, {\n      toggled: false,\n      active: active,\n      language: language,\n      languages: languages\n    }); // Watch changes to textTracks and update captions menu\n\n    if (this.isHTML5) {\n      var trackEvents = this.config.captions.update ? 'addtrack removetrack' : 'removetrack';\n      on.call(this, this.media.textTracks, trackEvents, captions.update.bind(this));\n    } // Update available languages in list next tick (the event must not be triggered before the listeners)\n\n\n    setTimeout(captions.update.bind(this), 0);\n  },\n  // Update available language options in settings based on tracks\n  update: function update() {\n    var _this = this;\n\n    var tracks = captions.getTracks.call(this, true); // Get the wanted language\n\n    var _this$captions = this.captions,\n        active = _this$captions.active,\n        language = _this$captions.language,\n        meta = _this$captions.meta,\n        currentTrackNode = _this$captions.currentTrackNode;\n    var languageExists = Boolean(tracks.find(function (track) {\n      return track.language === language;\n    })); // Handle tracks (add event listener and \"pseudo\"-default)\n\n    if (this.isHTML5 && this.isVideo) {\n      tracks.filter(function (track) {\n        return !meta.get(track);\n      }).forEach(function (track) {\n        _this.debug.log('Track added', track); // Attempt to store if the original dom element was \"default\"\n\n\n        meta.set(track, {\n          default: track.mode === 'showing'\n        }); // eslint-disable-next-line no-param-reassign\n\n        if (track.mode === 'showing') {\n          // eslint-disable-next-line no-param-reassign\n          track.mode = 'hidden';\n        } // Add event listener for cue changes\n\n\n        on.call(_this, track, 'cuechange', function () {\n          return captions.updateCues.call(_this);\n        });\n      });\n    } // Update language first time it matches, or if the previous matching track was removed\n\n\n    if (languageExists && this.language !== language || !tracks.includes(currentTrackNode)) {\n      captions.setLanguage.call(this, language);\n      captions.toggle.call(this, active && languageExists);\n    } // Enable or disable captions based on track length\n\n\n    toggleClass(this.elements.container, this.config.classNames.captions.enabled, !is$1.empty(tracks)); // Update available languages in list\n\n    if (is$1.array(this.config.controls) && this.config.controls.includes('settings') && this.config.settings.includes('captions')) {\n      controls.setCaptionsMenu.call(this);\n    }\n  },\n  // Toggle captions display\n  // Used internally for the toggleCaptions method, with the passive option forced to false\n  toggle: function toggle(input) {\n    var _this2 = this;\n\n    var passive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n    // If there's no full support\n    if (!this.supported.ui) {\n      return;\n    }\n\n    var toggled = this.captions.toggled; // Current state\n\n    var activeClass = this.config.classNames.captions.active; // Get the next state\n    // If the method is called without parameter, toggle based on current value\n\n    var active = is$1.nullOrUndefined(input) ? !toggled : input; // Update state and trigger event\n\n    if (active !== toggled) {\n      // When passive, don't override user preferences\n      if (!passive) {\n        this.captions.active = active;\n        this.storage.set({\n          captions: active\n        });\n      } // Force language if the call isn't passive and there is no matching language to toggle to\n\n\n      if (!this.language && active && !passive) {\n        var tracks = captions.getTracks.call(this);\n        var track = captions.findTrack.call(this, [this.captions.language].concat(_toConsumableArray(this.captions.languages)), true); // Override user preferences to avoid switching languages if a matching track is added\n\n        this.captions.language = track.language; // Set caption, but don't store in localStorage as user preference\n\n        captions.set.call(this, tracks.indexOf(track));\n        return;\n      } // Toggle button if it's enabled\n\n\n      if (this.elements.buttons.captions) {\n        this.elements.buttons.captions.pressed = active;\n      } // Add class hook\n\n\n      toggleClass(this.elements.container, activeClass, active);\n      this.captions.toggled = active; // Update settings menu\n\n      controls.updateSetting.call(this, 'captions'); // Trigger event (not used internally)\n\n      triggerEvent.call(this, this.media, active ? 'captionsenabled' : 'captionsdisabled');\n    } // on the active track - forcing the browser to download it\n\n\n    setTimeout(function () {\n      if (active && _this2.captions.toggled) {\n        _this2.captions.currentTrackNode.mode = 'hidden';\n      }\n    });\n  },\n  // Set captions by track index\n  // Used internally for the currentTrack setter with the passive option forced to false\n  set: function set(index) {\n    var passive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    var tracks = captions.getTracks.call(this); // Disable captions if setting to -1\n\n    if (index === -1) {\n      captions.toggle.call(this, false, passive);\n      return;\n    }\n\n    if (!is$1.number(index)) {\n      this.debug.warn('Invalid caption argument', index);\n      return;\n    }\n\n    if (!(index in tracks)) {\n      this.debug.warn('Track not found', index);\n      return;\n    }\n\n    if (this.captions.currentTrack !== index) {\n      this.captions.currentTrack = index;\n      var track = tracks[index];\n\n      var _ref = track || {},\n          language = _ref.language; // Store reference to node for invalidation on remove\n\n\n      this.captions.currentTrackNode = track; // Update settings menu\n\n      controls.updateSetting.call(this, 'captions'); // When passive, don't override user preferences\n\n      if (!passive) {\n        this.captions.language = language;\n        this.storage.set({\n          language: language\n        });\n      } // Handle Vimeo captions\n\n\n      if (this.isVimeo) {\n        this.embed.enableTextTrack(language);\n      } // Trigger event\n\n\n      triggerEvent.call(this, this.media, 'languagechange');\n    } // Show captions\n\n\n    captions.toggle.call(this, true, passive);\n\n    if (this.isHTML5 && this.isVideo) {\n      // If we change the active track while a cue is already displayed we need to update it\n      captions.updateCues.call(this);\n    }\n  },\n  // Set captions by language\n  // Used internally for the language setter with the passive option forced to false\n  setLanguage: function setLanguage(input) {\n    var passive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n    if (!is$1.string(input)) {\n      this.debug.warn('Invalid language argument', input);\n      return;\n    } // Normalize\n\n\n    var language = input.toLowerCase();\n    this.captions.language = language; // Set currentTrack\n\n    var tracks = captions.getTracks.call(this);\n    var track = captions.findTrack.call(this, [language]);\n    captions.set.call(this, tracks.indexOf(track), passive);\n  },\n  // Get current valid caption tracks\n  // If update is false it will also ignore tracks without metadata\n  // This is used to \"freeze\" the language options when captions.update is false\n  getTracks: function getTracks() {\n    var _this3 = this;\n\n    var update = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    // Handle media or textTracks missing or null\n    var tracks = Array.from((this.media || {}).textTracks || []); // For HTML5, use cache instead of current tracks when it exists (if captions.update is false)\n    // Filter out removed tracks and tracks that aren't captions/subtitles (for example metadata)\n\n    return tracks.filter(function (track) {\n      return !_this3.isHTML5 || update || _this3.captions.meta.has(track);\n    }).filter(function (track) {\n      return ['captions', 'subtitles'].includes(track.kind);\n    });\n  },\n  // Match tracks based on languages and get the first\n  findTrack: function findTrack(languages) {\n    var _this4 = this;\n\n    var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    var tracks = captions.getTracks.call(this);\n\n    var sortIsDefault = function sortIsDefault(track) {\n      return Number((_this4.captions.meta.get(track) || {}).default);\n    };\n\n    var sorted = Array.from(tracks).sort(function (a, b) {\n      return sortIsDefault(b) - sortIsDefault(a);\n    });\n    var track;\n    languages.every(function (language) {\n      track = sorted.find(function (t) {\n        return t.language === language;\n      });\n      return !track; // Break iteration if there is a match\n    }); // If no match is found but is required, get first\n\n    return track || (force ? sorted[0] : undefined);\n  },\n  // Get the current track\n  getCurrentTrack: function getCurrentTrack() {\n    return captions.getTracks.call(this)[this.currentTrack];\n  },\n  // Get UI label for track\n  getLabel: function getLabel(track) {\n    var currentTrack = track;\n\n    if (!is$1.track(currentTrack) && support.textTracks && this.captions.toggled) {\n      currentTrack = captions.getCurrentTrack.call(this);\n    }\n\n    if (is$1.track(currentTrack)) {\n      if (!is$1.empty(currentTrack.label)) {\n        return currentTrack.label;\n      }\n\n      if (!is$1.empty(currentTrack.language)) {\n        return track.language.toUpperCase();\n      }\n\n      return i18n.get('enabled', this.config);\n    }\n\n    return i18n.get('disabled', this.config);\n  },\n  // Update captions using current track's active cues\n  // Also optional array argument in case there isn't any track (ex: vimeo)\n  updateCues: function updateCues(input) {\n    // Requires UI\n    if (!this.supported.ui) {\n      return;\n    }\n\n    if (!is$1.element(this.elements.captions)) {\n      this.debug.warn('No captions element to render to');\n      return;\n    } // Only accept array or empty input\n\n\n    if (!is$1.nullOrUndefined(input) && !Array.isArray(input)) {\n      this.debug.warn('updateCues: Invalid input', input);\n      return;\n    }\n\n    var cues = input; // Get cues from track\n\n    if (!cues) {\n      var track = captions.getCurrentTrack.call(this);\n      cues = Array.from((track || {}).activeCues || []).map(function (cue) {\n        return cue.getCueAsHTML();\n      }).map(getHTML);\n    } // Set new caption text\n\n\n    var content = cues.map(function (cueText) {\n      return cueText.trim();\n    }).join('\\n');\n    var changed = content !== this.elements.captions.innerHTML;\n\n    if (changed) {\n      // Empty the container and create a new child element\n      emptyElement(this.elements.captions);\n      var caption = createElement('span', getAttributesFromSelector(this.config.selectors.caption));\n      caption.innerHTML = content;\n      this.elements.captions.appendChild(caption); // Trigger event\n\n      triggerEvent.call(this, this.media, 'cuechange');\n    }\n  }\n};\n\n// ==========================================================================\n// WassPlayer default config file\n// ==========================================================================\nvar defaults$1 = {\n  // Disable\n  enabled: true,\n  // Custom media title\n  title: '',\n  // Logging to console\n  debug: false,\n  // Auto play (if supported)\n  autoplay: false,\n  // Only allow one media playing at once\n  autopause: true,\n  // Allow inline playback on iOS\n  playsinline: true,\n  // Default time to skip when rewind/fast forward\n  seekTime: 10,\n  // Default volume\n  volume: 1,\n  muted: false,\n  // Pass a custom duration\n  duration: null,\n  // Display the media duration on load in the current time position\n  // If you have opted to display both duration and currentTime, this is ignored\n  displayDuration: true,\n  // Invert the current time to be a countdown\n  invertTime: true,\n  // Clicking the currentTime inverts it's value to show time left rather than elapsed\n  toggleInvert: true,\n  // Force an aspect ratio\n  // The format must be `'w:h'` (e.g. `'16:9'`)\n  ratio: null,\n  // Click video container to play/pause\n  clickToPlay: true,\n  // Auto hide the controls\n  hideControls: true,\n  // Reset to start when playback ended\n  resetOnEnd: false,\n  // Disable the standard context menu\n  disableContextMenu: true,\n  // Sprite (for icons)\n  loadSprite: true,\n  iconPrefix: 'wassPlayer',\n  iconUrl: 'http://code4stack.com/wassplayer.svg',\n  // Quality default\n  quality: {\n    default: 576,\n    // The options to display in the UI, if available for the source media\n    options: [4320, 2880, 2160, 1440, 1080, 720, 576, 480, 360, 240],\n    forced: false,\n    onChange: null\n  },\n  // Set loops\n  loop: {\n    active: false // start: null,\n    // end: null,\n\n  },\n  // Speed default and options to display\n  speed: {\n    selected: 1,\n    // The options to display in the UI, if available for the source media\n    options: [0.5, 0.75, 1, 1.25, 1.5, 1.75, 2, 4]\n  },\n  // Keyboard shortcut settings\n  keyboard: {\n    focused: true,\n    global: false\n  },\n  // Display tooltips\n  tooltips: {\n    controls: false,\n    seek: true\n  },\n  // Captions settings\n  captions: {\n    active: false,\n    language: 'auto',\n    // Listen to new tracks added after Plyr is initialized.\n    // This is needed for streaming captions, but may result in unselectable options\n    update: false\n  },\n  // Fullscreen settings\n  fullscreen: {\n    enabled: true,\n    // Allow fullscreen?\n    fallback: true,\n    // Fallback using full viewport/window\n    iosNative: false // Use the native fullscreen in iOS (disables custom controls)\n    // Selector for the fullscreen container so contextual / non-player content can remain visible in fullscreen mode\n    // Non-ancestors of the player element will be ignored\n    // container: null, // defaults to the player element\n\n  },\n  // Local storage\n  storage: {\n    enabled: true,\n    key: 'wassPlayer'\n  },\n  // Default controls\n  controls: ['play-large', // 'restart',\n  'rewind', 'play', 'fast-forward', 'progress', 'current-time', // 'duration',\n  'mute', 'volume', 'captions', 'settings', 'pip', 'airplay', // 'download',\n  'fullscreen'],\n  settings: ['captions', 'quality', 'speed'],\n  // Localisation\n  i18n: {\n    restart: 'Restart',\n    rewind: 'Rewind {seektime}s',\n    play: 'Play',\n    pause: 'Pause',\n    fastForward: 'Forward {seektime}s',\n    seek: 'Seek',\n    seekLabel: '{currentTime} of {duration}',\n    played: 'Played',\n    buffered: 'Buffered',\n    currentTime: 'Current time',\n    duration: 'Duration',\n    volume: 'Volume',\n    mute: 'Mute',\n    unmute: 'Unmute',\n    enableCaptions: 'Enable captions',\n    disableCaptions: 'Disable captions',\n    download: 'Download',\n    enterFullscreen: 'Enter fullscreen',\n    exitFullscreen: 'Exit fullscreen',\n    frameTitle: 'Player for {title}',\n    captions: 'Captions',\n    settings: 'Settings',\n    pip: 'PIP',\n    menuBack: 'Go back to previous menu',\n    speed: 'Speed',\n    normal: 'Normal',\n    quality: 'Quality',\n    loop: 'Loop',\n    start: 'Start',\n    end: 'End',\n    all: 'All',\n    reset: 'Reset',\n    disabled: 'Disabled',\n    enabled: 'Enabled',\n    advertisement: 'Ad',\n    qualityBadge: {\n      2160: '4K',\n      1440: 'HD',\n      1080: 'HD',\n      720: 'HD',\n      576: 'SD',\n      480: 'SD'\n    }\n  },\n  // Custom control listeners\n  listeners: {\n    seek: null,\n    play: null,\n    pause: null,\n    restart: null,\n    rewind: null,\n    fastForward: null,\n    mute: null,\n    volume: null,\n    captions: null,\n    download: null,\n    fullscreen: null,\n    pip: null,\n    airplay: null,\n    speed: null,\n    quality: null,\n    loop: null,\n    language: null\n  },\n  // Events to watch and bubble\n  events: [// Events to watch on HTML5 media elements and bubble\n  // https://developer.mozilla.org/en/docs/Web/Guide/Events/Media_events\n  'ended', 'progress', 'stalled', 'playing', 'waiting', 'canplay', 'canplaythrough', 'loadstart', 'loadeddata', 'loadedmetadata', 'timeupdate', 'volumechange', 'play', 'pause', 'error', 'seeking', 'seeked', 'emptied', 'ratechange', 'cuechange', // Custom events\n  'download', 'enterfullscreen', 'exitfullscreen', 'captionsenabled', 'captionsdisabled', 'languagechange', 'controlshidden', 'controlsshown', 'ready', // Quality\n  'qualitychange'],\n  // Selectors\n  // Change these to match your template if using custom HTML\n  selectors: {\n    editable: 'input, textarea, select, [contenteditable]',\n    container: '.wassPlayer',\n    controls: {\n      container: null,\n      wrapper: '.wassPlayer__controls'\n    },\n    labels: '[data-wassPlayer]',\n    buttons: {\n      play: '[data-wassPlayer=\"play\"]',\n      pause: '[data-wassPlayer=\"pause\"]',\n      restart: '[data-wassPlayer=\"restart\"]',\n      rewind: '[data-wassPlayer=\"rewind\"]',\n      fastForward: '[data-wassPlayer=\"fast-forward\"]',\n      mute: '[data-wassPlayer=\"mute\"]',\n      captions: '[data-wassPlayer=\"captions\"]',\n      download: '[data-wassPlayer=\"download\"]',\n      fullscreen: '[data-wassPlayer=\"fullscreen\"]',\n      pip: '[data-wassPlayer=\"pip\"]',\n      airplay: '[data-wassPlayer=\"airplay\"]',\n      settings: '[data-wassPlayer=\"settings\"]',\n      loop: '[data-wassPlayer=\"loop\"]'\n    },\n    inputs: {\n      seek: '[data-wassPlayer=\"seek\"]',\n      volume: '[data-wassPlayer=\"volume\"]',\n      speed: '[data-wassPlayer=\"speed\"]',\n      language: '[data-wassPlayer=\"language\"]',\n      quality: '[data-wassPlayer=\"quality\"]'\n    },\n    display: {\n      currentTime: '.wassPlayer__time--current',\n      duration: '.wassPlayer__time--duration',\n      buffer: '.wassPlayer__progress__buffer',\n      loop: '.wassPlayer__progress__loop',\n      // Used later\n      volume: '.wassPlayer__volume--display'\n    },\n    progress: '.wassPlayer__progress',\n    captions: '.wassPlayer__captions',\n    caption: '.wassPlayer__caption'\n  },\n  // Class hooks added to the player in different states\n  classNames: {\n    type: 'wassPlayer--{0}',\n    provider: 'wassPlayer--{0}',\n    video: 'wassPlayer__video-wrapper',\n    embed: 'wassPlayer__video-embed',\n    videoFixedRatio: 'wassPlayer__video-wrapper--fixed-ratio',\n    embedContainer: 'wassPlayer__video-embed__container',\n    poster: 'wassPlayer__poster',\n    posterEnabled: 'wassPlayer__poster-enabled',\n    control: 'wassPlayer__control',\n    controlPressed: 'wassPlayer__control--pressed',\n    playing: 'wassPlayer--playing',\n    paused: 'wassPlayer--paused',\n    stopped: 'wassPlayer--stopped',\n    loading: 'wassPlayer--loading',\n    hover: 'wassPlayer--hover',\n    tooltip: 'wassPlayer__tooltip',\n    cues: 'wassPlayer__cues',\n    hidden: 'wassPlayer__sr-only',\n    hideControls: 'wassPlayer--hide-controls',\n    isIos: 'wassPlayer--is-ios',\n    isTouch: 'wassPlayer--is-touch',\n    uiSupported: 'wassPlayer--full-ui',\n    noTransition: 'wassPlayer--no-transition',\n    display: {\n      time: 'wassPlayer__time'\n    },\n    menu: {\n      value: 'wassPlayer__menu__value',\n      badge: 'wassPlayer__badge',\n      open: 'wassPlayer--menu-open'\n    },\n    captions: {\n      enabled: 'wassPlayer--captions-enabled',\n      active: 'wassPlayer--captions-active'\n    },\n    fullscreen: {\n      enabled: 'wassPlayer--fullscreen-enabled',\n      fallback: 'wassPlayer--fullscreen-fallback'\n    },\n    pip: {\n      supported: 'wassPlayer--pip-supported',\n      active: 'wassPlayer--pip-active'\n    },\n    airplay: {\n      supported: 'wassPlayer--airplay-supported',\n      active: 'wassPlayer--airplay-active'\n    },\n    tabFocus: 'wassPlayer__tab-focus',\n    previewThumbnails: {\n      // Tooltip thumbs\n      thumbContainer: 'wassPlayer__preview-thumb',\n      thumbContainerShown: 'wassPlayer__preview-thumb--is-shown',\n      imageContainer: 'wassPlayer__preview-thumb__image-container',\n      timeContainer: 'wassPlayer__preview-thumb__time-container',\n      // Scrubbing\n      scrubbingContainer: 'wassPlayer__preview-scrubbing',\n      scrubbingContainerShown: 'wassPlayer__preview-scrubbing--is-shown'\n    }\n  },\n  // Embed attributes\n  attributes: {\n    embed: {\n      provider: 'data-wassPlayer-provider',\n      id: 'data-wassPlayer-embed-id'\n    }\n  },\n  // Preview Thumbnails plugin\n  previewThumbnails: {\n    enabled: false,\n    src: ''\n  }\n};\n\n// ==========================================================================\n// WassPlayer states\n// ==========================================================================\nvar pip = {\n  active: 'picture-in-picture',\n  inactive: 'inline'\n};\n\n// ==========================================================================\n// WassPlayer supported types and providers\n// ==========================================================================\nvar providers = {\n  html5: 'html5'\n};\nvar types = {\n  video: 'video'\n};\n/**\n * Get provider by URL\n * @param {String} url\n */\n\nfunction getProviderByUrl() {\n  return null;\n}\n\n// ==========================================================================\n// Console wrapper\n// ==========================================================================\nvar noop = function noop() {};\n\nvar Console = /*#__PURE__*/function () {\n  function Console() {\n    var enabled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n    _classCallCheck(this, Console);\n\n    this.enabled = window.console && enabled;\n\n    if (this.enabled) {\n      this.log('Debugging enabled');\n    }\n  }\n\n  _createClass(Console, [{\n    key: \"log\",\n    get: function get() {\n      // eslint-disable-next-line no-console\n      return this.enabled ? Function.prototype.bind.call(console.log, console) : noop;\n    }\n  }, {\n    key: \"warn\",\n    get: function get() {\n      // eslint-disable-next-line no-console\n      return this.enabled ? Function.prototype.bind.call(console.warn, console) : noop;\n    }\n  }, {\n    key: \"error\",\n    get: function get() {\n      // eslint-disable-next-line no-console\n      return this.enabled ? Function.prototype.bind.call(console.error, console) : noop;\n    }\n  }]);\n\n  return Console;\n}();\n\nvar Fullscreen = /*#__PURE__*/function () {\n  function Fullscreen(player) {\n    var _this = this;\n\n    _classCallCheck(this, Fullscreen);\n\n    // Keep reference to parent\n    this.player = player; // Get prefix\n\n    this.prefix = Fullscreen.prefix;\n    this.property = Fullscreen.property; // Scroll position\n\n    this.scrollPosition = {\n      x: 0,\n      y: 0\n    }; // Force the use of 'full window/browser' rather than fullscreen\n\n    this.forceFallback = player.config.fullscreen.fallback === 'force'; // Get the fullscreen element\n    // Checks container is an ancestor, defaults to null\n\n    this.player.elements.fullscreen = player.config.fullscreen.container && closest(this.player.elements.container, player.config.fullscreen.container); // Register event listeners\n    // Handle event (incase user presses escape etc)\n\n    on.call(this.player, document, this.prefix === 'ms' ? 'MSFullscreenChange' : \"\".concat(this.prefix, \"fullscreenchange\"), function () {\n      _this.onChange();\n    }); // Fullscreen toggle on double click\n\n    on.call(this.player, this.player.elements.container, 'dblclick', function (event) {\n      // Ignore double click in controls\n      if (is$1.element(_this.player.elements.controls) && _this.player.elements.controls.contains(event.target)) {\n        return;\n      }\n\n      _this.toggle();\n    }); // Tap focus when in fullscreen\n\n    on.call(this, this.player.elements.container, 'keydown', function (event) {\n      return _this.trapFocus(event);\n    }); // Update the UI\n\n    this.update();\n  } // Determine if native supported\n\n\n  _createClass(Fullscreen, [{\n    key: \"onChange\",\n    value: function onChange() {\n      if (!this.enabled) {\n        return;\n      } // Update toggle button\n\n\n      var button = this.player.elements.buttons.fullscreen;\n\n      if (is$1.element(button)) {\n        button.pressed = this.active;\n      } // Trigger an event\n\n\n      triggerEvent.call(this.player, this.target, this.active ? 'enterfullscreen' : 'exitfullscreen', true);\n    }\n  }, {\n    key: \"toggleFallback\",\n    value: function toggleFallback() {\n      var toggle = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n      // Store or restore scroll position\n      if (toggle) {\n        this.scrollPosition = {\n          x: window.scrollX || 0,\n          y: window.scrollY || 0\n        };\n      } else {\n        window.scrollTo(this.scrollPosition.x, this.scrollPosition.y);\n      } // Toggle scroll\n\n\n      document.body.style.overflow = toggle ? 'hidden' : ''; // Toggle class hook\n\n      toggleClass(this.target, this.player.config.classNames.fullscreen.fallback, toggle); // Force full viewport on iPhone X+\n\n      if (browser.isIos) {\n        var viewport = document.head.querySelector('meta[name=\"viewport\"]');\n        var property = 'viewport-fit=cover'; // Inject the viewport meta if required\n\n        if (!viewport) {\n          viewport = document.createElement('meta');\n          viewport.setAttribute('name', 'viewport');\n        } // Check if the property already exists\n\n\n        var hasProperty = is$1.string(viewport.content) && viewport.content.includes(property);\n\n        if (toggle) {\n          this.cleanupViewport = !hasProperty;\n\n          if (!hasProperty) {\n            viewport.content += \",\".concat(property);\n          }\n        } else if (this.cleanupViewport) {\n          viewport.content = viewport.content.split(',').filter(function (part) {\n            return part.trim() !== property;\n          }).join(',');\n        }\n      } // Toggle button and fire events\n\n\n      this.onChange();\n    } // Trap focus inside container\n\n  }, {\n    key: \"trapFocus\",\n    value: function trapFocus(event) {\n      // Bail if iOS, not active, not the tab key\n      if (browser.isIos || !this.active || event.key !== 'Tab' || event.keyCode !== 9) {\n        return;\n      } // Get the current focused element\n\n\n      var focused = document.activeElement;\n      var focusable = getElements.call(this.player, 'a[href], button:not(:disabled), input:not(:disabled), [tabindex]');\n\n      var _focusable = _slicedToArray(focusable, 1),\n          first = _focusable[0];\n\n      var last = focusable[focusable.length - 1];\n\n      if (focused === last && !event.shiftKey) {\n        // Move focus to first element that can be tabbed if Shift isn't used\n        first.focus();\n        event.preventDefault();\n      } else if (focused === first && event.shiftKey) {\n        // Move focus to last element that can be tabbed if Shift is used\n        last.focus();\n        event.preventDefault();\n      }\n    } // Update UI\n\n  }, {\n    key: \"update\",\n    value: function update() {\n      if (this.enabled) {\n        var mode;\n\n        if (this.forceFallback) {\n          mode = 'Fallback (forced)';\n        } else if (Fullscreen.native) {\n          mode = 'Native';\n        } else {\n          mode = 'Fallback';\n        }\n\n        this.player.debug.log(\"\".concat(mode, \" fullscreen enabled\"));\n      } else {\n        this.player.debug.log('Fullscreen not supported and fallback disabled');\n      } // Add styling hook to show button\n\n\n      toggleClass(this.player.elements.container, this.player.config.classNames.fullscreen.enabled, this.enabled);\n    } // Make an element fullscreen\n\n  }, {\n    key: \"enter\",\n    value: function enter() {\n      if (!this.enabled) {\n        return;\n      } // iOS native fullscreen doesn't need the request step\n\n\n      if (browser.isIos && this.player.config.fullscreen.iosNative) {\n        this.target.webkitEnterFullscreen();\n      } else if (!Fullscreen.native || this.forceFallback) {\n        this.toggleFallback(true);\n      } else if (!this.prefix) {\n        this.target.requestFullscreen({\n          navigationUI: 'hide'\n        });\n      } else if (!is$1.empty(this.prefix)) {\n        this.target[\"\".concat(this.prefix, \"Request\").concat(this.property)]();\n      }\n    } // Bail from fullscreen\n\n  }, {\n    key: \"exit\",\n    value: function exit() {\n      if (!this.enabled) {\n        return;\n      } // iOS native fullscreen\n\n\n      if (browser.isIos && this.player.config.fullscreen.iosNative) {\n        this.target.webkitExitFullscreen();\n        silencePromise(this.player.play());\n      } else if (!Fullscreen.native || this.forceFallback) {\n        this.toggleFallback(false);\n      } else if (!this.prefix) {\n        (document.cancelFullScreen || document.exitFullscreen).call(document);\n      } else if (!is$1.empty(this.prefix)) {\n        var action = this.prefix === 'moz' ? 'Cancel' : 'Exit';\n        document[\"\".concat(this.prefix).concat(action).concat(this.property)]();\n      }\n    } // Toggle state\n\n  }, {\n    key: \"toggle\",\n    value: function toggle() {\n      if (!this.active) {\n        this.enter();\n      } else {\n        this.exit();\n      }\n    }\n  }, {\n    key: \"usingNative\",\n    // If we're actually using native\n    get: function get() {\n      return Fullscreen.native && !this.forceFallback;\n    } // Get the prefix for handlers\n\n  }, {\n    key: \"enabled\",\n    // Determine if fullscreen is enabled\n    get: function get() {\n      return (Fullscreen.native || this.player.config.fullscreen.fallback) && this.player.config.fullscreen.enabled && this.player.supported.ui && this.player.isVideo;\n    } // Get active state\n\n  }, {\n    key: \"active\",\n    get: function get() {\n      if (!this.enabled) {\n        return false;\n      } // Fallback using classname\n\n\n      if (!Fullscreen.native || this.forceFallback) {\n        return hasClass(this.target, this.player.config.classNames.fullscreen.fallback);\n      }\n\n      var element = !this.prefix ? document.fullscreenElement : document[\"\".concat(this.prefix).concat(this.property, \"Element\")];\n      return element && element.shadowRoot ? element === this.target.getRootNode().host : element === this.target;\n    } // Get target element\n\n  }, {\n    key: \"target\",\n    get: function get() {\n      return browser.isIos && this.player.config.fullscreen.iosNative ? this.player.media : this.player.elements.fullscreen || this.player.elements.container;\n    }\n  }], [{\n    key: \"native\",\n    get: function get() {\n      return !!(document.fullscreenEnabled || document.webkitFullscreenEnabled || document.mozFullScreenEnabled || document.msFullscreenEnabled);\n    }\n  }, {\n    key: \"prefix\",\n    get: function get() {\n      // No prefix\n      if (is$1.function(document.exitFullscreen)) {\n        return '';\n      } // Check for fullscreen support by vendor prefix\n\n\n      var value = '';\n      var prefixes = ['webkit', 'moz', 'ms'];\n      prefixes.some(function (pre) {\n        if (is$1.function(document[\"\".concat(pre, \"ExitFullscreen\")]) || is$1.function(document[\"\".concat(pre, \"CancelFullScreen\")])) {\n          value = pre;\n          return true;\n        }\n\n        return false;\n      });\n      return value;\n    }\n  }, {\n    key: \"property\",\n    get: function get() {\n      return this.prefix === 'moz' ? 'FullScreen' : 'Fullscreen';\n    }\n  }]);\n\n  return Fullscreen;\n}();\n\n// ==========================================================================\n// Load image avoiding xhr/fetch CORS issues\n// Server status can't be obtained this way unfortunately, so this uses \"naturalWidth\" to determine if the image has loaded\n// By default it checks if it is at least 1px, but you can add a second argument to change this\n// ==========================================================================\nfunction loadImage(src) {\n  var minWidth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  return new Promise(function (resolve, reject) {\n    var image = new Image();\n\n    var handler = function handler() {\n      delete image.onload;\n      delete image.onerror;\n      (image.naturalWidth >= minWidth ? resolve : reject)(image);\n    };\n\n    Object.assign(image, {\n      onload: handler,\n      onerror: handler,\n      src: src\n    });\n  });\n}\n\nvar ui = {\n  addStyleHook: function addStyleHook() {\n    toggleClass(this.elements.container, this.config.selectors.container.replace('.', ''), true);\n    toggleClass(this.elements.container, this.config.classNames.uiSupported, this.supported.ui);\n  },\n  // Toggle native HTML5 media controls\n  toggleNativeControls: function toggleNativeControls() {\n    var toggle = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n    if (toggle && this.isHTML5) {\n      this.media.setAttribute('controls', '');\n    } else {\n      this.media.removeAttribute('controls');\n    }\n  },\n  // Setup the UI\n  build: function build() {\n    var _this = this;\n\n    // Re-attach media element listeners\n    // TODO: Use event bubbling?\n    this.listeners.media(); // Don't setup interface if no support\n\n    if (!this.supported.ui) {\n      this.debug.warn(\"Basic support only for \".concat(this.provider, \" \").concat(this.type)); // Restore native controls\n\n      ui.toggleNativeControls.call(this, true); // Bail\n\n      return;\n    } // Inject custom controls if not present\n\n\n    if (!is$1.element(this.elements.controls)) {\n      // Inject custom controls\n      controls.inject.call(this); // Re-attach control listeners\n\n      this.listeners.controls();\n    } // Remove native controls\n\n\n    ui.toggleNativeControls.call(this); // Setup captions for HTML5\n\n    if (this.isHTML5) {\n      captions.setup.call(this);\n    } // Reset volume\n\n\n    this.volume = null; // Reset mute state\n\n    this.muted = null; // Reset loop state\n\n    this.loop = null; // Reset quality setting\n\n    this.quality = null; // Reset speed\n\n    this.speed = null; // Reset volume display\n\n    controls.updateVolume.call(this); // Reset time display\n\n    controls.timeUpdate.call(this); // Update the UI\n\n    ui.checkPlaying.call(this); // Check for picture-in-picture support\n\n    toggleClass(this.elements.container, this.config.classNames.pip.supported, support.pip && this.isHTML5 && this.isVideo); // Check for airplay support\n\n    toggleClass(this.elements.container, this.config.classNames.airplay.supported, support.airplay && this.isHTML5); // Add iOS class\n\n    toggleClass(this.elements.container, this.config.classNames.isIos, browser.isIos); // Add touch class\n\n    toggleClass(this.elements.container, this.config.classNames.isTouch, this.touch); // Ready for API calls\n\n    this.ready = true; // Ready event at end of execution stack\n\n    setTimeout(function () {\n      triggerEvent.call(_this, _this.media, 'ready');\n    }, 0); // Set the title\n\n    ui.setTitle.call(this); // Assure the poster image is set, if the property was added before the element was created\n\n    if (this.poster) {\n      ui.setPoster.call(this, this.poster, false).catch(function () {});\n    } // Manually set the duration if user has overridden it.\n    // The event listeners for it doesn't get called if preload is disabled (#701)\n\n\n    if (this.config.duration) {\n      controls.durationUpdate.call(this);\n    }\n  },\n  // Setup aria attribute for play and iframe title\n  setTitle: function setTitle() {\n    // Find the current text\n    var label = i18n.get('play', this.config); // If there's a media title set, use that for the label\n\n    if (is$1.string(this.config.title) && !is$1.empty(this.config.title)) {\n      label += \", \".concat(this.config.title);\n    } // If there's a play button, set label\n\n\n    Array.from(this.elements.buttons.play || []).forEach(function (button) {\n      button.setAttribute('aria-label', label);\n    }); // Set iframe title\n    // https://github.com/sampotts/WassPlayer/issues/124\n\n    if (this.isEmbed) {\n      var iframe = getElement.call(this, 'iframe');\n\n      if (!is$1.element(iframe)) {\n        return;\n      } // Default to media type\n\n\n      var title = !is$1.empty(this.config.title) ? this.config.title : 'video';\n      var format = i18n.get('frameTitle', this.config);\n      iframe.setAttribute('title', format.replace('{title}', title));\n    }\n  },\n  // Toggle poster\n  togglePoster: function togglePoster(enable) {\n    toggleClass(this.elements.container, this.config.classNames.posterEnabled, enable);\n  },\n  // Set the poster image (async)\n  // Used internally for the poster setter, with the passive option forced to false\n  setPoster: function setPoster(poster) {\n    var _this2 = this;\n\n    var passive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n    // Don't override if call is passive\n    if (passive && this.poster) {\n      return Promise.reject(new Error('Poster already set'));\n    } // Set property synchronously to respect the call order\n\n\n    this.media.setAttribute('data-poster', poster); // Wait until ui is ready\n\n    return ready.call(this) // Load image\n    .then(function () {\n      return loadImage(poster);\n    }).catch(function (err) {\n      // Hide poster on error unless it's been set by another call\n      if (poster === _this2.poster) {\n        ui.togglePoster.call(_this2, false);\n      } // Rethrow\n\n\n      throw err;\n    }).then(function () {\n      // Prevent race conditions\n      if (poster !== _this2.poster) {\n        throw new Error('setPoster cancelled by later call to setPoster');\n      }\n    }).then(function () {\n      Object.assign(_this2.elements.poster.style, {\n        backgroundImage: \"url('\".concat(poster, \"')\"),\n        // Reset backgroundSize as well (since it can be set to \"cover\" for padded thumbnails for youtube)\n        backgroundSize: ''\n      });\n      ui.togglePoster.call(_this2, true);\n      return poster;\n    });\n  },\n  // Check playing state\n  checkPlaying: function checkPlaying(event) {\n    var _this3 = this;\n\n    // Class hooks\n    toggleClass(this.elements.container, this.config.classNames.playing, this.playing);\n    toggleClass(this.elements.container, this.config.classNames.paused, this.paused);\n    toggleClass(this.elements.container, this.config.classNames.stopped, this.stopped); // Set state\n\n    Array.from(this.elements.buttons.play || []).forEach(function (target) {\n      Object.assign(target, {\n        pressed: _this3.playing\n      });\n      target.setAttribute('aria-label', i18n.get(_this3.playing ? 'pause' : 'play', _this3.config));\n    }); // Only update controls on non timeupdate events\n\n    if (is$1.event(event) && event.type === 'timeupdate') {\n      return;\n    } // Toggle controls\n\n\n    ui.toggleControls.call(this);\n  },\n  // Check if media is loading\n  checkLoading: function checkLoading(event) {\n    var _this4 = this;\n\n    this.loading = ['stalled', 'waiting'].includes(event.type); // Clear timer\n\n    clearTimeout(this.timers.loading); // Timer to prevent flicker when seeking\n\n    this.timers.loading = setTimeout(function () {\n      // Update progress bar loading class state\n      toggleClass(_this4.elements.container, _this4.config.classNames.loading, _this4.loading); // Update controls visibility\n\n      ui.toggleControls.call(_this4);\n    }, this.loading ? 250 : 0);\n  },\n  // Toggle controls based on state and `force` argument\n  toggleControls: function toggleControls(force) {\n    var controlsElement = this.elements.controls;\n\n    if (controlsElement && this.config.hideControls) {\n      // Don't hide controls if a touch-device user recently seeked. (Must be limited to touch devices, or it occasionally prevents desktop controls from hiding.)\n      var recentTouchSeek = this.touch && this.lastSeekTime + 2000 > Date.now(); // Show controls if force, loading, paused, button interaction, or recent seek, otherwise hide\n\n      this.toggleControls(Boolean(force || this.loading || this.paused || controlsElement.pressed || controlsElement.hover || recentTouchSeek));\n    }\n  },\n  // Migrate any custom properties from the media to the parent\n  migrateStyles: function migrateStyles() {\n    var _this5 = this;\n\n    // Loop through values (as they are the keys when the object is spread 🤔)\n    Object.values(_objectSpread2({}, this.media.style)) // We're only fussed about WassPlayer specific properties\n    .filter(function (key) {\n      return !is$1.empty(key) && key.startsWith('--wassPlayer');\n    }).forEach(function (key) {\n      // Set on the container\n      _this5.elements.container.style.setProperty(key, _this5.media.style.getPropertyValue(key)); // Clean up from media element\n\n\n      _this5.media.style.removeProperty(key);\n    }); // Remove attribute if empty\n\n    if (is$1.empty(this.media.style)) {\n      this.media.removeAttribute('style');\n    }\n  }\n};\n\nvar Listeners = /*#__PURE__*/function () {\n  function Listeners(player) {\n    _classCallCheck(this, Listeners);\n\n    this.player = player;\n    this.lastKey = null;\n    this.focusTimer = null;\n    this.lastKeyDown = null;\n    this.handleKey = this.handleKey.bind(this);\n    this.toggleMenu = this.toggleMenu.bind(this);\n    this.setTabFocus = this.setTabFocus.bind(this);\n    this.firstTouch = this.firstTouch.bind(this);\n  } // Handle key presses\n\n\n  _createClass(Listeners, [{\n    key: \"handleKey\",\n    value: function handleKey(event) {\n      var player = this.player;\n      var elements = player.elements;\n      var code = event.keyCode ? event.keyCode : event.which;\n      var pressed = event.type === 'keydown';\n      var repeat = pressed && code === this.lastKey; // Bail if a modifier key is set\n\n      if (event.altKey || event.ctrlKey || event.metaKey || event.shiftKey) {\n        return;\n      } // If the event is bubbled from the media element\n      // Firefox doesn't get the keycode for whatever reason\n\n\n      if (!is$1.number(code)) {\n        return;\n      } // Seek by the number keys\n\n\n      var seekByKey = function seekByKey() {\n        // Divide the max duration into 10th's and times by the number value\n        player.currentTime = player.duration / 10 * (code - 48);\n      }; // Handle the key on keydown\n      // Reset on keyup\n\n\n      if (pressed) {\n        // Check focused element\n        // and if the focused element is not editable (e.g. text input)\n        // and any that accept key input http://webaim.org/techniques/keyboard/\n        var focused = document.activeElement;\n\n        if (is$1.element(focused)) {\n          var editable = player.config.selectors.editable;\n          var seek = elements.inputs.seek;\n\n          if (focused !== seek && matches$1(focused, editable)) {\n            return;\n          }\n\n          if (event.which === 32 && matches$1(focused, 'button, [role^=\"menuitem\"]')) {\n            return;\n          }\n        } // Which keycodes should we prevent default\n\n\n        var preventDefault = [32, 37, 38, 39, 40, 48, 49, 50, 51, 52, 53, 54, 56, 57, 67, 70, 73, 75, 76, 77, 79]; // If the code is found prevent default (e.g. prevent scrolling for arrows)\n\n        if (preventDefault.includes(code)) {\n          event.preventDefault();\n          event.stopPropagation();\n        }\n\n        switch (code) {\n          case 48:\n          case 49:\n          case 50:\n          case 51:\n          case 52:\n          case 53:\n          case 54:\n          case 55:\n          case 56:\n          case 57:\n            // 0-9\n            if (!repeat) {\n              seekByKey();\n            }\n\n            break;\n\n          case 32:\n          case 75:\n            // Space and K key\n            if (!repeat) {\n              silencePromise(player.togglePlay());\n            }\n\n            break;\n\n          case 38:\n            // Arrow up\n            player.increaseVolume(0.1);\n            break;\n\n          case 40:\n            // Arrow down\n            player.decreaseVolume(0.1);\n            break;\n\n          case 77:\n            // M key\n            if (!repeat) {\n              player.muted = !player.muted;\n            }\n\n            break;\n\n          case 39:\n            // Arrow forward\n            player.forward();\n            break;\n\n          case 37:\n            // Arrow back\n            player.rewind();\n            break;\n\n          case 70:\n            // F key\n            player.fullscreen.toggle();\n            break;\n\n          case 67:\n            // C key\n            if (!repeat) {\n              player.toggleCaptions();\n            }\n\n            break;\n\n          case 76:\n            // L key\n            player.loop = !player.loop;\n            break;\n        } // Escape is handle natively when in full screen\n        // So we only need to worry about non native\n\n\n        if (code === 27 && !player.fullscreen.usingNative && player.fullscreen.active) {\n          player.fullscreen.toggle();\n        } // Store last code for next cycle\n\n\n        this.lastKey = code;\n      } else {\n        this.lastKey = null;\n      }\n    } // Toggle menu\n\n  }, {\n    key: \"toggleMenu\",\n    value: function toggleMenu(event) {\n      controls.toggleMenu.call(this.player, event);\n    } // Device is touch enabled\n\n  }, {\n    key: \"firstTouch\",\n    value: function firstTouch() {\n      var player = this.player;\n      var elements = player.elements;\n      player.touch = true; // Add touch class\n\n      toggleClass(elements.container, player.config.classNames.isTouch, true);\n    }\n  }, {\n    key: \"setTabFocus\",\n    value: function setTabFocus(event) {\n      var player = this.player;\n      var elements = player.elements;\n      clearTimeout(this.focusTimer); // Ignore any key other than tab\n\n      if (event.type === 'keydown' && event.which !== 9) {\n        return;\n      } // Store reference to event timeStamp\n\n\n      if (event.type === 'keydown') {\n        this.lastKeyDown = event.timeStamp;\n      } // Remove current classes\n\n\n      var removeCurrent = function removeCurrent() {\n        var className = player.config.classNames.tabFocus;\n        var current = getElements.call(player, \".\".concat(className));\n        toggleClass(current, className, false);\n      }; // Determine if a key was pressed to trigger this event\n\n\n      var wasKeyDown = event.timeStamp - this.lastKeyDown <= 20; // Ignore focus events if a key was pressed prior\n\n      if (event.type === 'focus' && !wasKeyDown) {\n        return;\n      } // Remove all current\n\n\n      removeCurrent(); // Delay the adding of classname until the focus has changed\n      // This event fires before the focusin event\n\n      if (event.type !== 'focusout') {\n        this.focusTimer = setTimeout(function () {\n          var focused = document.activeElement; // Ignore if current focus element isn't inside the player\n\n          if (!elements.container.contains(focused)) {\n            return;\n          }\n\n          toggleClass(document.activeElement, player.config.classNames.tabFocus, true);\n        }, 10);\n      }\n    } // Global window & document listeners\n\n  }, {\n    key: \"global\",\n    value: function global() {\n      var toggle = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      var player = this.player; // Keyboard shortcuts\n\n      if (player.config.keyboard.global) {\n        toggleListener.call(player, window, 'keydown keyup', this.handleKey, toggle, false);\n      } // Click anywhere closes menu\n\n\n      toggleListener.call(player, document.body, 'click', this.toggleMenu, toggle); // Detect touch by events\n\n      once.call(player, document.body, 'touchstart', this.firstTouch); // Tab focus detection\n\n      toggleListener.call(player, document.body, 'keydown focus blur focusout', this.setTabFocus, toggle, false, true);\n    } // Container listeners\n\n  }, {\n    key: \"container\",\n    value: function container() {\n      var player = this.player;\n      var config = player.config,\n          elements = player.elements,\n          timers = player.timers; // Keyboard shortcuts\n\n      if (!config.keyboard.global && config.keyboard.focused) {\n        on.call(player, elements.container, 'keydown keyup', this.handleKey, false);\n      } // Toggle controls on mouse events and entering fullscreen\n\n\n      on.call(player, elements.container, 'mousemove mouseleave touchstart touchmove enterfullscreen exitfullscreen', function (event) {\n        var controlsElement = elements.controls; // Remove button states for fullscreen\n\n        if (controlsElement && event.type === 'enterfullscreen') {\n          controlsElement.pressed = false;\n          controlsElement.hover = false;\n        } // Show, then hide after a timeout unless another control event occurs\n\n\n        var show = ['touchstart', 'touchmove', 'mousemove'].includes(event.type);\n        var delay = 0;\n\n        if (show) {\n          ui.toggleControls.call(player, true); // Use longer timeout for touch devices\n\n          delay = player.touch ? 3000 : 2000;\n        } // Clear timer\n\n\n        clearTimeout(timers.controls); // Set new timer to prevent flicker when seeking\n\n        timers.controls = setTimeout(function () {\n          return ui.toggleControls.call(player, false);\n        }, delay);\n      }); // Set a gutter for Vimeo\n\n      var setGutter = function setGutter(ratio, padding, toggle) {\n        if (!player.isVimeo || player.config.vimeo.premium) {\n          return;\n        }\n\n        var target = player.elements.wrapper.firstChild;\n\n        var _ratio = _slicedToArray(ratio, 2),\n            y = _ratio[1];\n\n        var _getAspectRatio$call = getAspectRatio.call(player),\n            _getAspectRatio$call2 = _slicedToArray(_getAspectRatio$call, 2),\n            videoX = _getAspectRatio$call2[0],\n            videoY = _getAspectRatio$call2[1];\n\n        target.style.maxWidth = toggle ? \"\".concat(y / videoY * videoX, \"px\") : null;\n        target.style.margin = toggle ? '0 auto' : null;\n      }; // Resize on fullscreen change\n\n\n      var setPlayerSize = function setPlayerSize(measure) {\n        // If we don't need to measure the viewport\n        if (!measure) {\n          return setAspectRatio.call(player);\n        }\n\n        var rect = elements.container.getBoundingClientRect();\n        var width = rect.width,\n            height = rect.height;\n        return setAspectRatio.call(player, \"\".concat(width, \":\").concat(height));\n      };\n\n      var resized = function resized() {\n        clearTimeout(timers.resized);\n        timers.resized = setTimeout(setPlayerSize, 50);\n      };\n\n      on.call(player, elements.container, 'enterfullscreen exitfullscreen', function (event) {\n        var _player$fullscreen = player.fullscreen,\n            target = _player$fullscreen.target,\n            usingNative = _player$fullscreen.usingNative; // Ignore events not from target\n\n        if (target !== elements.container) {\n          return;\n        } // If it's not an embed and no ratio specified\n\n\n        if (!player.isEmbed && is$1.empty(player.config.ratio)) {\n          return;\n        }\n\n        var isEnter = event.type === 'enterfullscreen'; // Set the player size when entering fullscreen to viewport size\n\n        var _setPlayerSize = setPlayerSize(isEnter),\n            padding = _setPlayerSize.padding,\n            ratio = _setPlayerSize.ratio; // Set Vimeo gutter\n\n\n        setGutter(ratio, padding, isEnter); // If not using native browser fullscreen API, we need to check for resizes of viewport\n\n        if (!usingNative) {\n          if (isEnter) {\n            on.call(player, window, 'resize', resized);\n          } else {\n            off.call(player, window, 'resize', resized);\n          }\n        }\n      });\n    } // Listen for media events\n\n  }, {\n    key: \"media\",\n    value: function media() {\n      var _this = this;\n\n      var player = this.player;\n      var elements = player.elements; // Time change on media\n\n      on.call(player, player.media, 'timeupdate seeking seeked', function (event) {\n        return controls.timeUpdate.call(player, event);\n      }); // Display duration\n\n      on.call(player, player.media, 'durationchange loadeddata loadedmetadata', function (event) {\n        return controls.durationUpdate.call(player, event);\n      }); // Handle the media finishing\n\n      on.call(player, player.media, 'ended', function () {\n        // Show poster on end\n        if (player.isHTML5 && player.isVideo && player.config.resetOnEnd) {\n          // Restart\n          player.restart(); // Call pause otherwise IE11 will start playing the video again\n\n          player.pause();\n        }\n      }); // Check for buffer progress\n\n      on.call(player, player.media, 'progress playing seeking seeked', function (event) {\n        return controls.updateProgress.call(player, event);\n      }); // Handle volume changes\n\n      on.call(player, player.media, 'volumechange', function (event) {\n        return controls.updateVolume.call(player, event);\n      }); // Handle play/pause\n\n      on.call(player, player.media, 'playing play pause ended emptied timeupdate', function (event) {\n        return ui.checkPlaying.call(player, event);\n      }); // Loading state\n\n      on.call(player, player.media, 'waiting canplay seeked playing', function (event) {\n        return ui.checkLoading.call(player, event);\n      }); // Click video\n\n      if (player.supported.ui && player.config.clickToPlay && !player.isAudio) {\n        // Re-fetch the wrapper\n        var wrapper = getElement.call(player, \".\".concat(player.config.classNames.video)); // Bail if there's no wrapper (this should never happen)\n\n        if (!is$1.element(wrapper)) {\n          return;\n        } // On click play, pause or restart\n\n\n        on.call(player, elements.container, 'click', function (event) {\n          var targets = [elements.container, wrapper]; // Ignore if click if not container or in video wrapper\n\n          if (!targets.includes(event.target) && !wrapper.contains(event.target)) {\n            return;\n          } // Touch devices will just show controls (if hidden)\n\n\n          if (player.touch && player.config.hideControls) {\n            return;\n          }\n\n          if (player.ended) {\n            _this.proxy(event, player.restart, 'restart');\n\n            _this.proxy(event, function () {\n              silencePromise(player.play());\n            }, 'play');\n          } else {\n            _this.proxy(event, function () {\n              silencePromise(player.togglePlay());\n            }, 'play');\n          }\n        });\n      } // Disable right click\n\n\n      if (player.supported.ui && player.config.disableContextMenu) {\n        on.call(player, elements.wrapper, 'contextmenu', function (event) {\n          event.preventDefault();\n        }, false);\n      } // Volume change\n\n\n      on.call(player, player.media, 'volumechange', function () {\n        // Save to storage\n        player.storage.set({\n          volume: player.volume,\n          muted: player.muted\n        });\n      }); // Speed change\n\n      on.call(player, player.media, 'ratechange', function () {\n        // Update UI\n        controls.updateSetting.call(player, 'speed'); // Save to storage\n\n\n        player.storage.set({\n          speed: player.speed\n        });\n      }); // Quality change\n\n      on.call(player, player.media, 'qualitychange', function (event) {\n        // Update UI\n        controls.updateSetting.call(player, 'quality', null, event.detail.quality);\n      }); // Update download link when ready and if quality changes\n\n      on.call(player, player.media, 'ready qualitychange', function () {\n        controls.setDownloadUrl.call(player);\n      }); // Proxy events to container\n      // Bubble up key events for Edge\n\n      var proxyEvents = player.config.events.concat(['keyup', 'keydown']).join(' ');\n      on.call(player, player.media, proxyEvents, function (event) {\n        var _event$detail = event.detail,\n            detail = _event$detail === void 0 ? {} : _event$detail; // Get error details from media\n\n        if (event.type === 'error') {\n          detail = player.media.error;\n        }\n\n        triggerEvent.call(player, elements.container, event.type, true, detail);\n      });\n    } // Run default and custom handlers\n\n  }, {\n    key: \"proxy\",\n    value: function proxy(event, defaultHandler, customHandlerKey) {\n      var player = this.player;\n      var customHandler = player.config.listeners[customHandlerKey];\n      var hasCustomHandler = is$1.function(customHandler);\n      var returned = true; // Execute custom handler\n\n      if (hasCustomHandler) {\n        returned = customHandler.call(player, event);\n      } // Only call default handler if not prevented in custom handler\n\n\n      if (returned !== false && is$1.function(defaultHandler)) {\n        defaultHandler.call(player, event);\n      }\n    } // Trigger custom and default handlers\n\n  }, {\n    key: \"bind\",\n    value: function bind(element, type, defaultHandler, customHandlerKey) {\n      var _this2 = this;\n\n      var passive = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n      var player = this.player;\n      var customHandler = player.config.listeners[customHandlerKey];\n      var hasCustomHandler = is$1.function(customHandler);\n      on.call(player, element, type, function (event) {\n        return _this2.proxy(event, defaultHandler, customHandlerKey);\n      }, passive && !hasCustomHandler);\n    } // Listen for control events\n\n  }, {\n    key: \"controls\",\n    value: function controls$1() {\n      var _this3 = this;\n\n      var player = this.player;\n      var elements = player.elements; // IE doesn't support input event, so we fallback to change\n\n      var inputEvent = browser.isIE ? 'change' : 'input'; // Play/pause toggle\n\n      if (elements.buttons.play) {\n        Array.from(elements.buttons.play).forEach(function (button) {\n          _this3.bind(button, 'click', function () {\n            silencePromise(player.togglePlay());\n          }, 'play');\n        });\n      } // Pause\n\n\n      this.bind(elements.buttons.restart, 'click', player.restart, 'restart'); // Rewind\n\n      this.bind(elements.buttons.rewind, 'click', player.rewind, 'rewind'); // Rewind\n\n      this.bind(elements.buttons.fastForward, 'click', player.forward, 'fastForward'); // Mute toggle\n\n      this.bind(elements.buttons.mute, 'click', function () {\n        player.muted = !player.muted;\n      }, 'mute'); // Captions toggle\n\n      this.bind(elements.buttons.captions, 'click', function () {\n        return player.toggleCaptions();\n      }); // Download\n\n      this.bind(elements.buttons.download, 'click', function () {\n        triggerEvent.call(player, player.media, 'download');\n      }, 'download'); // Fullscreen toggle\n\n      this.bind(elements.buttons.fullscreen, 'click', function () {\n        player.fullscreen.toggle();\n      }, 'fullscreen'); // Picture-in-Picture\n\n      this.bind(elements.buttons.pip, 'click', function () {\n        player.pip = 'toggle';\n      }, 'pip'); // Airplay\n\n      this.bind(elements.buttons.airplay, 'click', player.airplay, 'airplay'); // Settings menu - click toggle\n\n      this.bind(elements.buttons.settings, 'click', function (event) {\n        // Prevent the document click listener closing the menu\n        event.stopPropagation();\n        event.preventDefault();\n\n        controls.toggleMenu.call(player, event);\n      }, null, false); // Can't be passive as we're preventing default\n      // Settings menu - keyboard toggle\n      // We have to bind to keyup otherwise Firefox triggers a click when a keydown event handler shifts focus\n      // https://bugzilla.mozilla.org/show_bug.cgi?id=1220143\n\n      this.bind(elements.buttons.settings, 'keyup', function (event) {\n        var code = event.which; // We only care about space and return\n\n        if (![13, 32].includes(code)) {\n          return;\n        } // Because return triggers a click anyway, all we need to do is set focus\n\n\n        if (code === 13) {\n          controls.focusFirstMenuItem.call(player, null, true);\n\n          return;\n        } // Prevent scroll\n\n\n        event.preventDefault(); // Prevent playing video (Firefox)\n\n        event.stopPropagation(); // Toggle menu\n\n        controls.toggleMenu.call(player, event);\n      }, null, false // Can't be passive as we're preventing default\n      ); // Escape closes menu\n\n      this.bind(elements.settings.menu, 'keydown', function (event) {\n        if (event.which === 27) {\n          controls.toggleMenu.call(player, event);\n        }\n      }); // Set range input alternative \"value\", which matches the tooltip time (#954)\n\n      this.bind(elements.inputs.seek, 'mousedown mousemove', function (event) {\n        var rect = elements.progress.getBoundingClientRect();\n        var percent = 100 / rect.width * (event.pageX - rect.left);\n        event.currentTarget.setAttribute('seek-value', percent);\n      }); // Pause while seeking\n\n      this.bind(elements.inputs.seek, 'mousedown mouseup keydown keyup touchstart touchend', function (event) {\n        var seek = event.currentTarget;\n        var code = event.keyCode ? event.keyCode : event.which;\n        var attribute = 'play-on-seeked';\n\n        if (is$1.keyboardEvent(event) && code !== 39 && code !== 37) {\n          return;\n        } // Record seek time so we can prevent hiding controls for a few seconds after seek\n\n\n        player.lastSeekTime = Date.now(); // Was playing before?\n\n        var play = seek.hasAttribute(attribute); // Done seeking\n\n        var done = ['mouseup', 'touchend', 'keyup'].includes(event.type); // If we're done seeking and it was playing, resume playback\n\n        if (play && done) {\n          seek.removeAttribute(attribute);\n          silencePromise(player.play());\n        } else if (!done && player.playing) {\n          seek.setAttribute(attribute, '');\n          player.pause();\n        }\n      }); // Fix range inputs on iOS\n      // Super weird iOS bug where after you interact with an <input type=\"range\">,\n      // it takes over further interactions on the page. This is a hack\n\n      if (browser.isIos) {\n        var inputs = getElements.call(player, 'input[type=\"range\"]');\n        Array.from(inputs).forEach(function (input) {\n          return _this3.bind(input, inputEvent, function (event) {\n            return repaint(event.target);\n          });\n        });\n      } // Seek\n\n\n      this.bind(elements.inputs.seek, inputEvent, function (event) {\n        var seek = event.currentTarget; // If it exists, use seek-value instead of \"value\" for consistency with tooltip time (#954)\n\n        var seekTo = seek.getAttribute('seek-value');\n\n        if (is$1.empty(seekTo)) {\n          seekTo = seek.value;\n        }\n\n        seek.removeAttribute('seek-value');\n        player.currentTime = seekTo / seek.max * player.duration;\n      }, 'seek'); // Seek tooltip\n\n      this.bind(elements.progress, 'mouseenter mouseleave mousemove', function (event) {\n        return controls.updateSeekTooltip.call(player, event);\n      }); // Preview thumbnails plugin\n\n      this.bind(elements.progress, 'mousemove touchmove', function (event) {\n        var previewThumbnails = player.previewThumbnails;\n\n        if (previewThumbnails && previewThumbnails.loaded) {\n          previewThumbnails.startMove(event);\n        }\n      }); // Hide thumbnail preview - on mouse click, mouse leave, and video play/seek. All four are required, e.g., for buffering\n\n      this.bind(elements.progress, 'mouseleave touchend click', function () {\n        var previewThumbnails = player.previewThumbnails;\n\n        if (previewThumbnails && previewThumbnails.loaded) {\n          previewThumbnails.endMove(false, true);\n        }\n      }); // Show scrubbing preview\n\n      this.bind(elements.progress, 'mousedown touchstart', function (event) {\n        var previewThumbnails = player.previewThumbnails;\n\n        if (previewThumbnails && previewThumbnails.loaded) {\n          previewThumbnails.startScrubbing(event);\n        }\n      });\n      this.bind(elements.progress, 'mouseup touchend', function (event) {\n        var previewThumbnails = player.previewThumbnails;\n\n        if (previewThumbnails && previewThumbnails.loaded) {\n          previewThumbnails.endScrubbing(event);\n        }\n      }); // Polyfill for lower fill in <input type=\"range\"> for webkit\n\n      if (browser.isWebkit) {\n        Array.from(getElements.call(player, 'input[type=\"range\"]')).forEach(function (element) {\n          _this3.bind(element, 'input', function (event) {\n            return controls.updateRangeFill.call(player, event.target);\n          });\n        });\n      } // Current time invert\n      // Only if one time element is used for both currentTime and duration\n\n\n      if (player.config.toggleInvert && !is$1.element(elements.display.duration)) {\n        this.bind(elements.display.currentTime, 'click', function () {\n          // Do nothing if we're at the start\n          if (player.currentTime === 0) {\n            return;\n          }\n\n          player.config.invertTime = !player.config.invertTime;\n\n          controls.timeUpdate.call(player);\n        });\n      } // Volume\n\n\n      this.bind(elements.inputs.volume, inputEvent, function (event) {\n        player.volume = event.target.value;\n      }, 'volume'); // Update controls.hover state (used for ui.toggleControls to avoid hiding when interacting)\n\n      this.bind(elements.controls, 'mouseenter mouseleave', function (event) {\n        elements.controls.hover = !player.touch && event.type === 'mouseenter';\n      }); // Also update controls.hover state for any non-player children of fullscreen element (as above)\n\n      if (elements.fullscreen) {\n        Array.from(elements.fullscreen.children).filter(function (c) {\n          return !c.contains(elements.container);\n        }).forEach(function (child) {\n          _this3.bind(child, 'mouseenter mouseleave', function (event) {\n            elements.controls.hover = !player.touch && event.type === 'mouseenter';\n          });\n        });\n      } // Update controls.pressed state (used for ui.toggleControls to avoid hiding when interacting)\n\n\n      this.bind(elements.controls, 'mousedown mouseup touchstart touchend touchcancel', function (event) {\n        elements.controls.pressed = ['mousedown', 'touchstart'].includes(event.type);\n      }); // Show controls when they receive focus (e.g., when using keyboard tab key)\n\n      this.bind(elements.controls, 'focusin', function () {\n        var config = player.config,\n            timers = player.timers; // Skip transition to prevent focus from scrolling the parent element\n\n        toggleClass(elements.controls, config.classNames.noTransition, true); // Toggle\n\n        ui.toggleControls.call(player, true); // Restore transition\n\n        setTimeout(function () {\n          toggleClass(elements.controls, config.classNames.noTransition, false);\n        }, 0); // Delay a little more for mouse users\n\n        var delay = _this3.touch ? 3000 : 4000; // Clear timer\n\n        clearTimeout(timers.controls); // Hide again after delay\n\n        timers.controls = setTimeout(function () {\n          return ui.toggleControls.call(player, false);\n        }, delay);\n      }); // Mouse wheel for volume\n\n      this.bind(elements.inputs.volume, 'wheel', function (event) {\n        // Detect \"natural\" scroll - suppored on OS X Safari only\n        // Other browsers on OS X will be inverted until support improves\n        var inverted = event.webkitDirectionInvertedFromDevice; // Get delta from event. Invert if `inverted` is true\n\n        var _map = [event.deltaX, -event.deltaY].map(function (value) {\n          return inverted ? -value : value;\n        }),\n            _map2 = _slicedToArray(_map, 2),\n            x = _map2[0],\n            y = _map2[1]; // Using the biggest delta, normalize to 1 or -1 (or 0 if no delta)\n\n\n        var direction = Math.sign(Math.abs(x) > Math.abs(y) ? x : y); // Change the volume by 2%\n\n        player.increaseVolume(direction / 50); // Don't break page scrolling at max and min\n\n        var volume = player.media.volume;\n\n        if (direction === 1 && volume < 1 || direction === -1 && volume > 0) {\n          event.preventDefault();\n        }\n      }, 'volume', false);\n    }\n  }]);\n\n  return Listeners;\n}();\n\n// ==========================================================================\nvar media = {\n  // Setup media\n  setup: function setup() {\n    // If there's no media, bail\n    if (!this.media) {\n      this.debug.warn('No media element found!');\n      return;\n    } // Add type class\n\n\n    toggleClass(this.elements.container, this.config.classNames.type.replace('{0}', this.type), true); // Add provider class\n\n    toggleClass(this.elements.container, this.config.classNames.provider.replace('{0}', this.provider), true); // Add video class for embeds\n    // This will require changes if audio embeds are added\n\n    if (this.isEmbed) {\n      toggleClass(this.elements.container, this.config.classNames.type.replace('{0}', 'video'), true);\n    } // Inject the player wrapper\n\n\n    if (this.isVideo) {\n      // Create the wrapper div\n      this.elements.wrapper = createElement('div', {\n        class: this.config.classNames.video\n      }); // Wrap the video in a container\n\n      wrap(this.media, this.elements.wrapper); // Poster image container\n\n      this.elements.poster = createElement('div', {\n        class: this.config.classNames.poster\n      });\n      this.elements.wrapper.appendChild(this.elements.poster);\n    }\n\n    if (this.isHTML5) {\n      html5.setup.call(this);\n    }\n  }\n};\n\nvar parseVtt = function parseVtt(vttDataString) {\n  var processedList = [];\n  var frames = vttDataString.split(/\\r\\n\\r\\n|\\n\\n|\\r\\r/);\n  frames.forEach(function (frame) {\n    var result = {};\n    var lines = frame.split(/\\r\\n|\\n|\\r/);\n    lines.forEach(function (line) {\n      if (!is$1.number(result.startTime)) {\n        // The line with start and end times on it is the first line of interest\n        var matchTimes = line.match(/([0-9]{2})?:?([0-9]{2}):([0-9]{2}).([0-9]{2,3})( ?--> ?)([0-9]{2})?:?([0-9]{2}):([0-9]{2}).([0-9]{2,3})/); // Note that this currently ignores caption formatting directives that are optionally on the end of this line - fine for non-captions VTT\n\n        if (matchTimes) {\n          result.startTime = Number(matchTimes[1] || 0) * 60 * 60 + Number(matchTimes[2]) * 60 + Number(matchTimes[3]) + Number(\"0.\".concat(matchTimes[4]));\n          result.endTime = Number(matchTimes[6] || 0) * 60 * 60 + Number(matchTimes[7]) * 60 + Number(matchTimes[8]) + Number(\"0.\".concat(matchTimes[9]));\n        }\n      } else if (!is$1.empty(line.trim()) && is$1.empty(result.text)) {\n        // If we already have the startTime, then we're definitely up to the text line(s)\n        var lineSplit = line.trim().split('#xywh=');\n\n        var _lineSplit = _slicedToArray(lineSplit, 1);\n\n        result.text = _lineSplit[0];\n\n        // If there's content in lineSplit[1], then we have sprites. If not, then it's just one frame per image\n        if (lineSplit[1]) {\n          var _lineSplit$1$split = lineSplit[1].split(',');\n\n          var _lineSplit$1$split2 = _slicedToArray(_lineSplit$1$split, 4);\n\n          result.x = _lineSplit$1$split2[0];\n          result.y = _lineSplit$1$split2[1];\n          result.w = _lineSplit$1$split2[2];\n          result.h = _lineSplit$1$split2[3];\n        }\n      }\n    });\n\n    if (result.text) {\n      processedList.push(result);\n    }\n  });\n  return processedList;\n};\n\nvar fitRatio = function fitRatio(ratio, outer) {\n  var targetRatio = outer.width / outer.height;\n  var result = {};\n\n  if (ratio > targetRatio) {\n    result.width = outer.width;\n    result.height = 1 / ratio * outer.width;\n  } else {\n    result.height = outer.height;\n    result.width = ratio * outer.height;\n  }\n\n  return result;\n};\n\nvar PreviewThumbnails = /*#__PURE__*/function () {\n  /**\n   * PreviewThumbnails constructor.\n   * @param {wassPlayer} player\n   * @return {PreviewThumbnails}\n   */\n  function PreviewThumbnails(player) {\n    _classCallCheck(this, PreviewThumbnails);\n\n    this.player = player;\n    this.thumbnails = [];\n    this.loaded = false;\n    this.lastMouseMoveTime = Date.now();\n    this.mouseDown = false;\n    this.loadedImages = [];\n    this.elements = {\n      thumb: {},\n      scrubbing: {}\n    };\n    this.load();\n  }\n\n  _createClass(PreviewThumbnails, [{\n    key: \"load\",\n    value: function load() {\n      var _this = this;\n\n      // Toggle the regular seek tooltip\n      if (this.player.elements.display.seekTooltip) {\n        this.player.elements.display.seekTooltip.hidden = this.enabled;\n      }\n\n      if (!this.enabled) {\n        return;\n      }\n\n      this.getThumbnails().then(function () {\n        if (!_this.enabled) {\n          return;\n        } // Render DOM elements\n\n\n        _this.render(); // Check to see if thumb container size was specified manually in CSS\n\n\n        _this.determineContainerAutoSizing();\n\n        _this.loaded = true;\n      });\n    } // Download VTT files and parse them\n\n  }, {\n    key: \"getThumbnails\",\n    value: function getThumbnails() {\n      var _this2 = this;\n\n      return new Promise(function (resolve) {\n        var src = _this2.player.config.previewThumbnails.src;\n\n        if (is$1.empty(src)) {\n          throw new Error('Missing previewThumbnails.src config attribute');\n        } // Resolve promise\n\n\n        var sortAndResolve = function sortAndResolve() {\n          // Sort smallest to biggest (e.g., [120p, 480p, 1080p])\n          _this2.thumbnails.sort(function (x, y) {\n            return x.height - y.height;\n          });\n\n          _this2.player.debug.log('Preview thumbnails', _this2.thumbnails);\n\n          resolve();\n        }; // Via callback()\n\n\n        if (is$1.function(src)) {\n          src(function (thumbnails) {\n            _this2.thumbnails = thumbnails;\n            sortAndResolve();\n          });\n        } // VTT urls\n        else {\n            // If string, convert into single-element list\n            var urls = is$1.string(src) ? [src] : src; // Loop through each src URL. Download and process the VTT file, storing the resulting data in this.thumbnails\n\n            var promises = urls.map(function (u) {\n              return _this2.getThumbnail(u);\n            }); // Resolve\n\n            Promise.all(promises).then(sortAndResolve);\n          }\n      });\n    } // Process individual VTT file\n\n  }, {\n    key: \"getThumbnail\",\n    value: function getThumbnail(url) {\n      var _this3 = this;\n\n      return new Promise(function (resolve) {\n        fetch(url).then(function (response) {\n          var thumbnail = {\n            frames: parseVtt(response),\n            height: null,\n            urlPrefix: ''\n          };\n\n          if (!thumbnail.frames[0].text.startsWith('/') && !thumbnail.frames[0].text.startsWith('http://') && !thumbnail.frames[0].text.startsWith('https://')) {\n            thumbnail.urlPrefix = url.substring(0, url.lastIndexOf('/') + 1);\n          } // Download the first frame, so that we can determine/set the height of this thumbnailsDef\n\n\n          var tempImage = new Image();\n\n          tempImage.onload = function () {\n            thumbnail.height = tempImage.naturalHeight;\n            thumbnail.width = tempImage.naturalWidth;\n\n            _this3.thumbnails.push(thumbnail);\n\n            resolve();\n          };\n\n          tempImage.src = thumbnail.urlPrefix + thumbnail.frames[0].text;\n        });\n      });\n    }\n  }, {\n    key: \"startMove\",\n    value: function startMove(event) {\n      if (!this.loaded) {\n        return;\n      }\n\n      if (!is$1.event(event) || !['touchmove', 'mousemove'].includes(event.type)) {\n        return;\n      } // Wait until media has a duration\n\n\n      if (!this.player.media.duration) {\n        return;\n      }\n\n      if (event.type === 'touchmove') {\n        // Calculate seek hover position as approx video seconds\n        this.seekTime = this.player.media.duration * (this.player.elements.inputs.seek.value / 100);\n      } else {\n        // Calculate seek hover position as approx video seconds\n        var clientRect = this.player.elements.progress.getBoundingClientRect();\n        var percentage = 100 / clientRect.width * (event.pageX - clientRect.left);\n        this.seekTime = this.player.media.duration * (percentage / 100);\n\n        if (this.seekTime < 0) {\n          // The mousemove fires for 10+px out to the left\n          this.seekTime = 0;\n        }\n\n        if (this.seekTime > this.player.media.duration - 1) {\n          // Took 1 second off the duration for safety, because different players can disagree on the real duration of a video\n          this.seekTime = this.player.media.duration - 1;\n        }\n\n        this.mousePosX = event.pageX; // Set time text inside image container\n\n        this.elements.thumb.time.innerText = formatTime(this.seekTime);\n      } // Download and show image\n\n\n      this.showImageAtCurrentTime();\n    }\n  }, {\n    key: \"endMove\",\n    value: function endMove() {\n      this.toggleThumbContainer(false, true);\n    }\n  }, {\n    key: \"startScrubbing\",\n    value: function startScrubbing(event) {\n      // Only act on left mouse button (0), or touch device (event.button does not exist or is false)\n      if (is$1.nullOrUndefined(event.button) || event.button === false || event.button === 0) {\n        this.mouseDown = true; // Wait until media has a duration\n\n        if (this.player.media.duration) {\n          this.toggleScrubbingContainer(true);\n          this.toggleThumbContainer(false, true); // Download and show image\n\n          this.showImageAtCurrentTime();\n        }\n      }\n    }\n  }, {\n    key: \"endScrubbing\",\n    value: function endScrubbing() {\n      var _this4 = this;\n\n      this.mouseDown = false; // Hide scrubbing preview. But wait until the video has successfully seeked before hiding the scrubbing preview\n\n      if (Math.ceil(this.lastTime) === Math.ceil(this.player.media.currentTime)) {\n        // The video was already seeked/loaded at the chosen time - hide immediately\n        this.toggleScrubbingContainer(false);\n      } else {\n        // The video hasn't seeked yet. Wait for that\n        once.call(this.player, this.player.media, 'timeupdate', function () {\n          // Re-check mousedown - we might have already started scrubbing again\n          if (!_this4.mouseDown) {\n            _this4.toggleScrubbingContainer(false);\n          }\n        });\n      }\n    }\n    /**\n     * Setup hooks for wassPlayer and window events\n     */\n\n  }, {\n    key: \"listeners\",\n    value: function listeners() {\n      var _this5 = this;\n\n      this.player.on('play', function () {\n        _this5.toggleThumbContainer(false, true);\n      });\n      this.player.on('seeked', function () {\n        _this5.toggleThumbContainer(false);\n      });\n      this.player.on('timeupdate', function () {\n        _this5.lastTime = _this5.player.media.currentTime;\n      });\n    }\n    /**\n     * Create HTML elements for image containers\n     */\n\n  }, {\n    key: \"render\",\n    value: function render() {\n      // Create HTML element: wassPlayer__preview-thumbnail-container\n      this.elements.thumb.container = createElement('div', {\n        class: this.player.config.classNames.previewThumbnails.thumbContainer\n      }); // Wrapper for the image for styling\n\n      this.elements.thumb.imageContainer = createElement('div', {\n        class: this.player.config.classNames.previewThumbnails.imageContainer\n      });\n      this.elements.thumb.container.appendChild(this.elements.thumb.imageContainer); // Create HTML element, parent+span: time text (e.g., 01:32:00)\n\n      var timeContainer = createElement('div', {\n        class: this.player.config.classNames.previewThumbnails.timeContainer\n      });\n      this.elements.thumb.time = createElement('span', {}, '00:00');\n      timeContainer.appendChild(this.elements.thumb.time);\n      this.elements.thumb.container.appendChild(timeContainer); // Inject the whole thumb\n\n      if (is$1.element(this.player.elements.progress)) {\n        this.player.elements.progress.appendChild(this.elements.thumb.container);\n      } // Create HTML element: wassPlayer__preview-scrubbing-container\n\n\n      this.elements.scrubbing.container = createElement('div', {\n        class: this.player.config.classNames.previewThumbnails.scrubbingContainer\n      });\n      this.player.elements.wrapper.appendChild(this.elements.scrubbing.container);\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      if (this.elements.thumb.container) {\n        this.elements.thumb.container.remove();\n      }\n\n      if (this.elements.scrubbing.container) {\n        this.elements.scrubbing.container.remove();\n      }\n    }\n  }, {\n    key: \"showImageAtCurrentTime\",\n    value: function showImageAtCurrentTime() {\n      var _this6 = this;\n\n      if (this.mouseDown) {\n        this.setScrubbingContainerSize();\n      } else {\n        this.setThumbContainerSizeAndPos();\n      } // Find the desired thumbnail index\n\n\n      var thumbNum = this.thumbnails[0].frames.findIndex(function (frame) {\n        return _this6.seekTime >= frame.startTime && _this6.seekTime <= frame.endTime;\n      });\n      var hasThumb = thumbNum >= 0;\n      var qualityIndex = 0; // Show the thumb container if we're not scrubbing\n\n      if (!this.mouseDown) {\n        this.toggleThumbContainer(hasThumb);\n      } // No matching thumb found\n\n\n      if (!hasThumb) {\n        return;\n      } // Check to see if we've already downloaded higher quality versions of this image\n\n\n      this.thumbnails.forEach(function (thumbnail, index) {\n        if (_this6.loadedImages.includes(thumbnail.frames[thumbNum].text)) {\n          qualityIndex = index;\n        }\n      }); // Only proceed if either thumbnum or thumbfilename has changed\n\n      if (thumbNum !== this.showingThumb) {\n        this.showingThumb = thumbNum;\n        this.loadImage(qualityIndex);\n      }\n    } // Show the image that's currently specified in this.showingThumb\n\n  }, {\n    key: \"loadImage\",\n    value: function loadImage() {\n      var _this7 = this;\n\n      var qualityIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var thumbNum = this.showingThumb;\n      var thumbnail = this.thumbnails[qualityIndex];\n      var urlPrefix = thumbnail.urlPrefix;\n      var frame = thumbnail.frames[thumbNum];\n      var thumbFilename = thumbnail.frames[thumbNum].text;\n      var thumbUrl = urlPrefix + thumbFilename;\n\n      if (!this.currentImageElement || this.currentImageElement.dataset.filename !== thumbFilename) {\n        if (this.loadingImage && this.usingSprites) {\n          this.loadingImage.onload = null;\n        }\n\n        var previewImage = new Image();\n        previewImage.src = thumbUrl;\n        previewImage.dataset.index = thumbNum;\n        previewImage.dataset.filename = thumbFilename;\n        this.showingThumbFilename = thumbFilename;\n        this.player.debug.log(\"Loading image: \".concat(thumbUrl)); // For some reason, passing the named function directly causes it to execute immediately. So I've wrapped it in an anonymous function...\n\n        previewImage.onload = function () {\n          return _this7.showImage(previewImage, frame, qualityIndex, thumbNum, thumbFilename, true);\n        };\n\n        this.loadingImage = previewImage;\n        this.removeOldImages(previewImage);\n      } else {\n        // Update the existing image\n        this.showImage(this.currentImageElement, frame, qualityIndex, thumbNum, thumbFilename, false);\n        this.currentImageElement.dataset.index = thumbNum;\n        this.removeOldImages(this.currentImageElement);\n      }\n    }\n  }, {\n    key: \"showImage\",\n    value: function showImage(previewImage, frame, qualityIndex, thumbNum, thumbFilename) {\n      var newImage = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n      this.player.debug.log(\"Showing thumb: \".concat(thumbFilename, \". num: \").concat(thumbNum, \". qual: \").concat(qualityIndex, \". newimg: \").concat(newImage));\n      this.setImageSizeAndOffset(previewImage, frame);\n\n      if (newImage) {\n        this.currentImageContainer.appendChild(previewImage);\n        this.currentImageElement = previewImage;\n\n        if (!this.loadedImages.includes(thumbFilename)) {\n          this.loadedImages.push(thumbFilename);\n        }\n      }\n\n      this.preloadNearby(thumbNum, true).then(this.preloadNearby(thumbNum, false)).then(this.getHigherQuality(qualityIndex, previewImage, frame, thumbFilename));\n    } // Remove all preview images that aren't the designated current image\n\n  }, {\n    key: \"removeOldImages\",\n    value: function removeOldImages(currentImage) {\n      var _this8 = this;\n\n      // Get a list of all images, convert it from a DOM list to an array\n      Array.from(this.currentImageContainer.children).forEach(function (image) {\n        if (image.tagName.toLowerCase() !== 'img') {\n          return;\n        }\n\n        var removeDelay = _this8.usingSprites ? 500 : 1000;\n\n        if (image.dataset.index !== currentImage.dataset.index && !image.dataset.deleting) {\n          // eslint-disable-next-line no-param-reassign\n          image.dataset.deleting = true; // This has to be set before the timeout - to prevent issues switching between hover and scrub\n\n          var currentImageContainer = _this8.currentImageContainer;\n          setTimeout(function () {\n            currentImageContainer.removeChild(image);\n\n            _this8.player.debug.log(\"Removing thumb: \".concat(image.dataset.filename));\n          }, removeDelay);\n        }\n      });\n    } // Preload images before and after the current one. Only if the user is still hovering/seeking the same frame\n    // This will only preload the lowest quality\n\n  }, {\n    key: \"preloadNearby\",\n    value: function preloadNearby(thumbNum) {\n      var _this9 = this;\n\n      var forward = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      return new Promise(function (resolve) {\n        setTimeout(function () {\n          var oldThumbFilename = _this9.thumbnails[0].frames[thumbNum].text;\n\n          if (_this9.showingThumbFilename === oldThumbFilename) {\n            // Find the nearest thumbs with different filenames. Sometimes it'll be the next index, but in the case of sprites, it might be 100+ away\n            var thumbnailsClone;\n\n            if (forward) {\n              thumbnailsClone = _this9.thumbnails[0].frames.slice(thumbNum);\n            } else {\n              thumbnailsClone = _this9.thumbnails[0].frames.slice(0, thumbNum).reverse();\n            }\n\n            var foundOne = false;\n            thumbnailsClone.forEach(function (frame) {\n              var newThumbFilename = frame.text;\n\n              if (newThumbFilename !== oldThumbFilename) {\n                // Found one with a different filename. Make sure it hasn't already been loaded on this page visit\n                if (!_this9.loadedImages.includes(newThumbFilename)) {\n                  foundOne = true;\n\n                  _this9.player.debug.log(\"Preloading thumb filename: \".concat(newThumbFilename));\n\n                  var urlPrefix = _this9.thumbnails[0].urlPrefix;\n                  var thumbURL = urlPrefix + newThumbFilename;\n                  var previewImage = new Image();\n                  previewImage.src = thumbURL;\n\n                  previewImage.onload = function () {\n                    _this9.player.debug.log(\"Preloaded thumb filename: \".concat(newThumbFilename));\n\n                    if (!_this9.loadedImages.includes(newThumbFilename)) _this9.loadedImages.push(newThumbFilename); // We don't resolve until the thumb is loaded\n\n                    resolve();\n                  };\n                }\n              }\n            }); // If there are none to preload then we want to resolve immediately\n\n            if (!foundOne) {\n              resolve();\n            }\n          }\n        }, 300);\n      });\n    } // If user has been hovering current image for half a second, look for a higher quality one\n\n  }, {\n    key: \"getHigherQuality\",\n    value: function getHigherQuality(currentQualityIndex, previewImage, frame, thumbFilename) {\n      var _this10 = this;\n\n      if (currentQualityIndex < this.thumbnails.length - 1) {\n        // Only use the higher quality version if it's going to look any better - if the current thumb is of a lower pixel density than the thumbnail container\n        var previewImageHeight = previewImage.naturalHeight;\n\n        if (this.usingSprites) {\n          previewImageHeight = frame.h;\n        }\n\n        if (previewImageHeight < this.thumbContainerHeight) {\n          // Recurse back to the loadImage function - show a higher quality one, but only if the viewer is on this frame for a while\n          setTimeout(function () {\n            // Make sure the mouse hasn't already moved on and started hovering at another image\n            if (_this10.showingThumbFilename === thumbFilename) {\n              _this10.player.debug.log(\"Showing higher quality thumb for: \".concat(thumbFilename));\n\n              _this10.loadImage(currentQualityIndex + 1);\n            }\n          }, 300);\n        }\n      }\n    }\n  }, {\n    key: \"toggleThumbContainer\",\n    value: function toggleThumbContainer() {\n      var toggle = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var clearShowing = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var className = this.player.config.classNames.previewThumbnails.thumbContainerShown;\n      this.elements.thumb.container.classList.toggle(className, toggle);\n\n      if (!toggle && clearShowing) {\n        this.showingThumb = null;\n        this.showingThumbFilename = null;\n      }\n    }\n  }, {\n    key: \"toggleScrubbingContainer\",\n    value: function toggleScrubbingContainer() {\n      var toggle = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var className = this.player.config.classNames.previewThumbnails.scrubbingContainerShown;\n      this.elements.scrubbing.container.classList.toggle(className, toggle);\n\n      if (!toggle) {\n        this.showingThumb = null;\n        this.showingThumbFilename = null;\n      }\n    }\n  }, {\n    key: \"determineContainerAutoSizing\",\n    value: function determineContainerAutoSizing() {\n      if (this.elements.thumb.imageContainer.clientHeight > 20 || this.elements.thumb.imageContainer.clientWidth > 20) {\n        // This will prevent auto sizing in this.setThumbContainerSizeAndPos()\n        this.sizeSpecifiedInCSS = true;\n      }\n    } // Set the size to be about a quarter of the size of video. Unless option dynamicSize === false, in which case it needs to be set in CSS\n\n  }, {\n    key: \"setThumbContainerSizeAndPos\",\n    value: function setThumbContainerSizeAndPos() {\n      if (!this.sizeSpecifiedInCSS) {\n        var thumbWidth = Math.floor(this.thumbContainerHeight * this.thumbAspectRatio);\n        this.elements.thumb.imageContainer.style.height = \"\".concat(this.thumbContainerHeight, \"px\");\n        this.elements.thumb.imageContainer.style.width = \"\".concat(thumbWidth, \"px\");\n      } else if (this.elements.thumb.imageContainer.clientHeight > 20 && this.elements.thumb.imageContainer.clientWidth < 20) {\n        var _thumbWidth = Math.floor(this.elements.thumb.imageContainer.clientHeight * this.thumbAspectRatio);\n\n        this.elements.thumb.imageContainer.style.width = \"\".concat(_thumbWidth, \"px\");\n      } else if (this.elements.thumb.imageContainer.clientHeight < 20 && this.elements.thumb.imageContainer.clientWidth > 20) {\n        var thumbHeight = Math.floor(this.elements.thumb.imageContainer.clientWidth / this.thumbAspectRatio);\n        this.elements.thumb.imageContainer.style.height = \"\".concat(thumbHeight, \"px\");\n      }\n\n      this.setThumbContainerPos();\n    }\n  }, {\n    key: \"setThumbContainerPos\",\n    value: function setThumbContainerPos() {\n      var seekbarRect = this.player.elements.progress.getBoundingClientRect();\n      var wassPlayerRect = this.player.elements.container.getBoundingClientRect();\n      var container = this.elements.thumb.container; // Find the lowest and highest desired left-position, so we don't slide out the side of the video container\n\n      var minVal = wassPlayerRect.left - seekbarRect.left + 10;\n      var maxVal = wassPlayerRect.right - seekbarRect.left - container.clientWidth - 10; // Set preview container position to: mousepos, minus seekbar.left, minus half of previewContainer.clientWidth\n\n      var previewPos = this.mousePosX - seekbarRect.left - container.clientWidth / 2;\n\n      if (previewPos < minVal) {\n        previewPos = minVal;\n      }\n\n      if (previewPos > maxVal) {\n        previewPos = maxVal;\n      }\n\n      container.style.left = \"\".concat(previewPos, \"px\");\n    } // Can't use 100% width, in case the video is a different aspect ratio to the video container\n\n  }, {\n    key: \"setScrubbingContainerSize\",\n    value: function setScrubbingContainerSize() {\n      var _fitRatio = fitRatio(this.thumbAspectRatio, {\n        width: this.player.media.clientWidth,\n        height: this.player.media.clientHeight\n      }),\n          width = _fitRatio.width,\n          height = _fitRatio.height;\n\n      this.elements.scrubbing.container.style.width = \"\".concat(width, \"px\");\n      this.elements.scrubbing.container.style.height = \"\".concat(height, \"px\");\n    } // Sprites need to be offset to the correct location\n\n  }, {\n    key: \"setImageSizeAndOffset\",\n    value: function setImageSizeAndOffset(previewImage, frame) {\n      if (!this.usingSprites) {\n        return;\n      } // Find difference between height and preview container height\n\n\n      var multiplier = this.thumbContainerHeight / frame.h; // eslint-disable-next-line no-param-reassign\n\n      previewImage.style.height = \"\".concat(previewImage.naturalHeight * multiplier, \"px\"); // eslint-disable-next-line no-param-reassign\n\n      previewImage.style.width = \"\".concat(previewImage.naturalWidth * multiplier, \"px\"); // eslint-disable-next-line no-param-reassign\n\n      previewImage.style.left = \"-\".concat(frame.x * multiplier, \"px\"); // eslint-disable-next-line no-param-reassign\n\n      previewImage.style.top = \"-\".concat(frame.y * multiplier, \"px\");\n    }\n  }, {\n    key: \"enabled\",\n    get: function get() {\n      return this.player.isHTML5 && this.player.isVideo && this.player.config.previewThumbnails.enabled;\n    }\n  }, {\n    key: \"currentImageContainer\",\n    get: function get() {\n      if (this.mouseDown) {\n        return this.elements.scrubbing.container;\n      }\n\n      return this.elements.thumb.imageContainer;\n    }\n  }, {\n    key: \"usingSprites\",\n    get: function get() {\n      return Object.keys(this.thumbnails[0].frames[0]).includes('w');\n    }\n  }, {\n    key: \"thumbAspectRatio\",\n    get: function get() {\n      if (this.usingSprites) {\n        return this.thumbnails[0].frames[0].w / this.thumbnails[0].frames[0].h;\n      }\n\n      return this.thumbnails[0].width / this.thumbnails[0].height;\n    }\n  }, {\n    key: \"thumbContainerHeight\",\n    get: function get() {\n      if (this.mouseDown) {\n        var _fitRatio2 = fitRatio(this.thumbAspectRatio, {\n          width: this.player.media.clientWidth,\n          height: this.player.media.clientHeight\n        }),\n            height = _fitRatio2.height;\n\n        return height;\n      } // If css is used this needs to return the css height for sprites to work (see setImageSizeAndOffset)\n\n\n      if (this.sizeSpecifiedInCSS) {\n        return this.elements.thumb.imageContainer.clientHeight;\n      }\n\n      return Math.floor(this.player.media.clientWidth / this.thumbAspectRatio / 4);\n    }\n  }, {\n    key: \"currentImageElement\",\n    get: function get() {\n      if (this.mouseDown) {\n        return this.currentScrubbingImageElement;\n      }\n\n      return this.currentThumbnailImageElement;\n    },\n    set: function set(element) {\n      if (this.mouseDown) {\n        this.currentScrubbingImageElement = element;\n      } else {\n        this.currentThumbnailImageElement = element;\n      }\n    }\n  }]);\n\n  return PreviewThumbnails;\n}();\n\nvar source = {\n  // Add elements to HTML5 media (source, tracks, etc)\n  insertElements: function insertElements(type, attributes) {\n    var _this = this;\n\n    if (is$1.string(attributes)) {\n      insertElement(type, this.media, {\n        src: attributes\n      });\n    } else if (is$1.array(attributes)) {\n      attributes.forEach(function (attribute) {\n        insertElement(type, _this.media, attribute);\n      });\n    }\n  },\n  // Update source\n  // Sources are not checked for support so be careful\n  change: function change(input) {\n    var _this2 = this;\n\n    if (!getDeep(input, 'sources.length')) {\n      this.debug.warn('Invalid source format');\n      return;\n    } // Cancel current network requests\n\n\n    html5.cancelRequests.call(this); // Destroy instance and re-setup\n\n    this.destroy.call(this, function () {\n      // Reset quality options\n      _this2.options.quality = []; // Remove elements\n\n      removeElement(_this2.media);\n      _this2.media = null; // Reset class name\n\n      if (is$1.element(_this2.elements.container)) {\n        _this2.elements.container.removeAttribute('class');\n      } // Set the type and provider\n\n\n      var sources = input.sources,\n          type = input.type;\n\n      var _sources = _slicedToArray(sources, 1),\n          _sources$ = _sources[0],\n          _sources$$provider = _sources$.provider,\n          provider = _sources$$provider === void 0 ? providers.html5 : _sources$$provider,\n          src = _sources$.src;\n\n      var tagName = provider === 'html5' ? type : 'div';\n      var attributes = provider === 'html5' ? {} : {\n        src: src\n      };\n      Object.assign(_this2, {\n        provider: provider,\n        type: type,\n        // Check for support\n        supported: support.check(type, provider, _this2.config.playsinline),\n        // Create new element\n        media: createElement(tagName, attributes)\n      }); // Inject the new element\n\n      _this2.elements.container.appendChild(_this2.media); // Autoplay the new source?\n\n\n      if (is$1.boolean(input.autoplay)) {\n        _this2.config.autoplay = input.autoplay;\n      } // Set attributes for audio and video\n\n\n      if (_this2.isHTML5) {\n        if (_this2.config.crossorigin) {\n          _this2.media.setAttribute('crossorigin', '');\n        }\n\n        if (_this2.config.autoplay) {\n          _this2.media.setAttribute('autoplay', '');\n        }\n\n        if (!is$1.empty(input.poster)) {\n          _this2.poster = input.poster;\n        }\n\n        if (_this2.config.loop.active) {\n          _this2.media.setAttribute('loop', '');\n        }\n\n        if (_this2.config.muted) {\n          _this2.media.setAttribute('muted', '');\n        }\n\n        if (_this2.config.playsinline) {\n          _this2.media.setAttribute('playsinline', '');\n        }\n      } // Restore class hook\n\n\n      ui.addStyleHook.call(_this2); // Set new sources for html5\n\n      if (_this2.isHTML5) {\n        source.insertElements.call(_this2, 'source', sources);\n      } // Set video title\n\n\n      _this2.config.title = input.title; // Set up from scratch\n\n      media.setup.call(_this2); // HTML5 stuff\n\n      if (_this2.isHTML5) {\n        // Setup captions\n        if (Object.keys(input).includes('tracks')) {\n          source.insertElements.call(_this2, 'track', input.tracks);\n        }\n      } // If HTML5 or embed but not fully supported, setupInterface and call ready now\n\n\n      if (_this2.isHTML5 || _this2.isEmbed && !_this2.supported.ui) {\n        // Setup interface\n        ui.build.call(_this2);\n      } // Load HTML5 sources\n\n\n      if (_this2.isHTML5) {\n        _this2.media.load();\n      } // Update previewThumbnails config & reload plugin\n\n\n      if (!is$1.empty(input.previewThumbnails)) {\n        Object.assign(_this2.config.previewThumbnails, input.previewThumbnails); // Cleanup previewThumbnails plugin if it was loaded\n\n        if (_this2.previewThumbnails && _this2.previewThumbnails.loaded) {\n          _this2.previewThumbnails.destroy();\n\n          _this2.previewThumbnails = null;\n        } // Create new instance if it is still enabled\n\n\n        if (_this2.config.previewThumbnails.enabled) {\n          _this2.previewThumbnails = new PreviewThumbnails(_this2);\n        }\n      } // Update the fullscreen support\n\n\n      _this2.fullscreen.update();\n    }, true);\n  }\n};\n\n/**\n * Returns a number whose value is limited to the given range.\n *\n * Example: limit the output of this computation to between 0 and 255\n * (x * 255).clamp(0, 255)\n *\n * @param {Number} input\n * @param {Number} min The lower boundary of the output range\n * @param {Number} max The upper boundary of the output range\n * @returns A number in the range [min, max]\n * @type Number\n */\nfunction clamp() {\n  var input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n  var min = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var max = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 255;\n  return Math.min(Math.max(input, min), max);\n}\n\nvar WassPlayer = /*#__PURE__*/function () {\n  function WassPlayer(target, options) {\n    var _this = this;\n\n    _classCallCheck(this, WassPlayer);\n\n    this.timers = {}; // State\n\n    this.ready = false;\n    this.loading = false;\n    this.failed = false; // Touch device\n\n    this.touch = support.touch; // Set the media element\n\n    this.media = target; // String selector passed\n\n    if (is$1.string(this.media)) {\n      this.media = document.querySelectorAll(this.media);\n    } // jQuery, NodeList or Array passed, use first element\n\n\n    if (window.jQuery && this.media instanceof jQuery || is$1.nodeList(this.media) || is$1.array(this.media)) {\n      // eslint-disable-next-line\n      this.media = this.media[0];\n    } // Set config\n\n\n    this.config = extend({}, defaults$1, WassPlayer.defaults, options || {}, function () {\n      try {\n        return JSON.parse(_this.media.getAttribute('data-wassPlayer-config'));\n      } catch (e) {\n        return {};\n      }\n    }()); // Elements cache\n\n    this.elements = {\n      container: null,\n      fullscreen: null,\n      captions: null,\n      buttons: {},\n      display: {},\n      progress: {},\n      inputs: {},\n      settings: {\n        popup: null,\n        menu: null,\n        panels: {},\n        buttons: {}\n      }\n    }; // Captions\n\n    this.captions = {\n      active: null,\n      currentTrack: -1,\n      meta: new WeakMap()\n    }; // Fullscreen\n\n    this.fullscreen = {\n      active: false\n    }; // Options\n\n    this.options = {\n      speed: [],\n      quality: []\n    }; // Debugging\n    // TODO: move to globals\n\n    this.debug = new Console(this.config.debug); // Log config options and support\n\n    this.debug.log('Config', this.config);\n    this.debug.log('Support', support); // We need an element to setup\n\n    if (is$1.nullOrUndefined(this.media) || !is$1.element(this.media)) {\n      this.debug.error('Setup failed: no suitable element passed');\n      return;\n    } // Bail if the element is initialized\n\n\n    if (this.media.wassPlayer) {\n      this.debug.warn('Target already setup');\n      return;\n    } // Bail if not enabled\n\n\n    if (!this.config.enabled) {\n      this.debug.error('Setup failed: disabled by config');\n      return;\n    } // Bail if disabled or no basic support\n    // You may want to disable certain UAs etc\n\n\n    if (!support.check().api) {\n      this.debug.error('Setup failed: no support');\n      return;\n    } // Cache original element state for .destroy()\n\n\n    var clone = this.media.cloneNode(true);\n    clone.autoplay = false;\n    this.elements.original = clone; // Set media type based on tag or data attribute\n    // Supported: video\n\n    var type = this.media.tagName.toLowerCase(); // Embed properties\n\n    var iframe = null;\n    var url = null; // Different setup based on type\n\n    switch (type) {\n      case 'div':\n        // Find the frame\n        iframe = this.media.querySelector('iframe'); // <iframe> type\n\n        if (is$1.element(iframe)) {\n          // Detect provider\n          url = parseUrl(iframe.getAttribute('src'));\n          this.provider = getProviderByUrl(url.toString()); // Rework elements\n\n          this.elements.container = this.media;\n          this.media = iframe; // Reset classname\n\n          this.elements.container.className = ''; // Get attributes from URL and set config\n\n          if (url.search.length) {\n            var truthy = ['1', 'true'];\n\n            if (truthy.includes(url.searchParams.get('autoplay'))) {\n              this.config.autoplay = true;\n            }\n\n            if (truthy.includes(url.searchParams.get('loop'))) {\n              this.config.loop.active = true;\n            }\n\n            this.config.playsinline = true;\n          }\n        } else {\n          // <div> with attributes\n          this.provider = this.media.getAttribute(this.config.attributes.embed.provider); // Remove attribute\n\n          this.media.removeAttribute(this.config.attributes.embed.provider);\n        } // Unsupported or missing provider\n\n\n        if (is$1.empty(this.provider) || !Object.keys(providers).includes(this.provider)) {\n          this.debug.error('Setup failed: Invalid provider');\n          return;\n        } // Audio will come later for external providers\n\n\n        this.type = types.video;\n        break;\n\n      case 'video':\n      case 'audio':\n        this.type = type;\n        this.provider = providers.html5; // Get config from attributes\n\n        if (this.media.hasAttribute('crossorigin')) {\n          this.config.crossorigin = true;\n        }\n\n        if (this.media.hasAttribute('autoplay')) {\n          this.config.autoplay = true;\n        }\n\n        if (this.media.hasAttribute('playsinline') || this.media.hasAttribute('webkit-playsinline')) {\n          this.config.playsinline = true;\n        }\n\n        if (this.media.hasAttribute('muted')) {\n          this.config.muted = true;\n        }\n\n        if (this.media.hasAttribute('loop')) {\n          this.config.loop.active = true;\n        }\n\n        break;\n\n      default:\n        this.debug.error('Setup failed: unsupported type');\n        return;\n    } // Check for support again but with type\n\n\n    this.supported = support.check(this.type, this.provider, this.config.playsinline); // If no support for even API, bail\n\n    if (!this.supported.api) {\n      this.debug.error('Setup failed: no support');\n      return;\n    }\n\n    this.eventListeners = []; // Create listeners\n\n    this.listeners = new Listeners(this); // Setup local storage for user settings\n\n    this.storage = new Storage(this); // Store reference\n\n    this.media.wassPlayer = this; // Wrap media\n\n    if (!is$1.element(this.elements.container)) {\n      this.elements.container = createElement('div', {\n        tabindex: 0\n      });\n      wrap(this.media, this.elements.container);\n    } // Migrate custom properties from media to container (so they work 😉)\n\n\n    ui.migrateStyles.call(this); // Add style hook\n\n    ui.addStyleHook.call(this); // Setup media\n\n    media.setup.call(this); // Listen for events if debugging\n\n    if (this.config.debug) {\n      on.call(this, this.elements.container, this.config.events.join(' '), function (event) {\n        _this.debug.log(\"event: \".concat(event.type));\n      });\n    } // Setup fullscreen\n\n\n    this.fullscreen = new Fullscreen(this); // Setup interface\n    // If embed but not fully supported, build interface now to avoid flash of controls\n\n    if (this.isHTML5 || this.isEmbed && !this.supported.ui) {\n      ui.build.call(this);\n    } // Container listeners\n\n\n    this.listeners.container(); // Global listeners\n\n    this.listeners.global(); // Autoplay if required\n\n    if (this.isHTML5 && this.config.autoplay) {\n      setTimeout(function () {\n        return silencePromise(_this.play());\n      }, 10);\n    } // Seek time will be recorded (in listeners.js) so we can prevent hiding controls for a few seconds after seek\n\n\n    this.lastSeekTime = 0; // Setup preview thumbnails if enabled\n\n    if (this.config.previewThumbnails.enabled) {\n      this.previewThumbnails = new PreviewThumbnails(this);\n    }\n  } // ---------------------------------------\n  // API\n  // ---------------------------------------\n\n  /**\n   * Types and provider helpers\n   */\n\n\n  _createClass(WassPlayer, [{\n    key: \"play\",\n\n    /**\n     * Play the media, or play the advertisement (if they are not blocked)\n     */\n    value: function play() {\n      if (!is$1.function(this.media.play)) {\n        return null;\n      } // Return the promise (for HTML5)\n\n\n      return this.media.play();\n    }\n    /**\n     * Pause the media\n     */\n\n  }, {\n    key: \"pause\",\n    value: function pause() {\n      if (!this.playing || !is$1.function(this.media.pause)) {\n        return null;\n      }\n\n      return this.media.pause();\n    }\n    /**\n     * Get playing state\n     */\n\n  }, {\n    key: \"togglePlay\",\n\n    /**\n     * Toggle playback based on current status\n     * @param {Boolean} input\n     */\n    value: function togglePlay(input) {\n      // Toggle based on current state if nothing passed\n      var toggle = is$1.boolean(input) ? input : !this.playing;\n\n      if (toggle) {\n        return this.play();\n      }\n\n      return this.pause();\n    }\n    /**\n     * Stop playback\n     */\n\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      if (this.isHTML5) {\n        this.pause();\n        this.restart();\n      } else if (is$1.function(this.media.stop)) {\n        this.media.stop();\n      }\n    }\n    /**\n     * Restart playback\n     */\n\n  }, {\n    key: \"restart\",\n    value: function restart() {\n      this.currentTime = 0;\n    }\n    /**\n     * Rewind\n     * @param {Number} seekTime - how far to rewind in seconds. Defaults to the config.seekTime\n     */\n\n  }, {\n    key: \"rewind\",\n    value: function rewind(seekTime) {\n      this.currentTime -= is$1.number(seekTime) ? seekTime : this.config.seekTime;\n    }\n    /**\n     * Fast forward\n     * @param {Number} seekTime - how far to fast forward in seconds. Defaults to the config.seekTime\n     */\n\n  }, {\n    key: \"forward\",\n    value: function forward(seekTime) {\n      this.currentTime += is$1.number(seekTime) ? seekTime : this.config.seekTime;\n    }\n    /**\n     * Seek to a time\n     * @param {Number} input - where to seek to in seconds. Defaults to 0 (the start)\n     */\n\n  }, {\n    key: \"increaseVolume\",\n\n    /**\n     * Increase volume\n     * @param {Boolean} step - How much to decrease by (between 0 and 1)\n     */\n    value: function increaseVolume(step) {\n      var volume = this.media.muted ? 0 : this.volume;\n      this.volume = volume + (is$1.number(step) ? step : 0);\n    }\n    /**\n     * Decrease volume\n     * @param {Boolean} step - How much to decrease by (between 0 and 1)\n     */\n\n  }, {\n    key: \"decreaseVolume\",\n    value: function decreaseVolume(step) {\n      this.increaseVolume(-step);\n    }\n    /**\n     * Set muted state\n     * @param {Boolean} mute\n     */\n\n  }, {\n    key: \"toggleCaptions\",\n\n    /**\n     * Toggle captions\n     * @param {Boolean} input - Whether to enable captions\n     */\n    value: function toggleCaptions(input) {\n      captions.toggle.call(this, input, false);\n    }\n    /**\n     * Set the caption track by index\n     * @param {Number} - Caption index\n     */\n\n  }, {\n    key: \"airplay\",\n\n    /**\n     * Trigger the airplay dialog\n     */\n    value: function airplay() {\n      // Show dialog if supported\n      if (support.airplay) {\n        this.media.webkitShowPlaybackTargetPicker();\n      }\n    }\n    /**\n     * Toggle the player controls\n     * @param {Boolean} [toggle] - Whether to show the controls\n     */\n\n  }, {\n    key: \"toggleControls\",\n    value: function toggleControls(toggle) {\n      // Don't toggle if missing UI support or if it's audio\n      if (this.supported.ui && !this.isAudio) {\n        // Get state before change\n        var isHidden = hasClass(this.elements.container, this.config.classNames.hideControls); // Negate the argument if not undefined since adding the class to hides the controls\n\n        var force = typeof toggle === 'undefined' ? undefined : !toggle; // Apply and get updated state\n\n        var hiding = toggleClass(this.elements.container, this.config.classNames.hideControls, force); // Close menu\n\n        if (hiding && is$1.array(this.config.controls) && this.config.controls.includes('settings') && !is$1.empty(this.config.settings)) {\n          controls.toggleMenu.call(this, false);\n        } // Trigger event on change\n\n\n        if (hiding !== isHidden) {\n          var eventName = hiding ? 'controlshidden' : 'controlsshown';\n          triggerEvent.call(this, this.media, eventName);\n        }\n\n        return !hiding;\n      }\n\n      return false;\n    }\n    /**\n     * Add event listeners\n     * @param {String} event - Event type\n     * @param {Function} callback - Callback for when event occurs\n     */\n\n  }, {\n    key: \"on\",\n    value: function on$1(event, callback) {\n      on.call(this, this.elements.container, event, callback);\n    }\n    /**\n     * Add event listeners once\n     * @param {String} event - Event type\n     * @param {Function} callback - Callback for when event occurs\n     */\n\n  }, {\n    key: \"once\",\n    value: function once$1(event, callback) {\n      once.call(this, this.elements.container, event, callback);\n    }\n    /**\n     * Remove event listeners\n     * @param {String} event - Event type\n     * @param {Function} callback - Callback for when event occurs\n     */\n\n  }, {\n    key: \"off\",\n    value: function off$1(event, callback) {\n      off(this.elements.container, event, callback);\n    }\n    /**\n     * Destroy an instance\n     * Event listeners are removed when elements are removed\n     * http://stackoverflow.com/questions/12528049/if-a-dom-element-is-removed-are-its-listeners-also-removed-from-memory\n     * @param {Function} callback - Callback for when destroy is complete\n     * @param {Boolean} soft - Whether it's a soft destroy (for source changes etc)\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy(callback) {\n      var _this2 = this;\n\n      var soft = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n      if (!this.ready) {\n        return;\n      }\n\n      var done = function done() {\n        // Reset overflow (incase destroyed while in fullscreen)\n        document.body.style.overflow = ''; // GC for embed\n\n        _this2.embed = null; // If it's a soft destroy, make minimal changes\n\n        if (soft) {\n          if (Object.keys(_this2.elements).length) {\n            // Remove elements\n            removeElement(_this2.elements.buttons.play);\n            removeElement(_this2.elements.captions);\n            removeElement(_this2.elements.controls);\n            removeElement(_this2.elements.wrapper); // Clear for GC\n\n            _this2.elements.buttons.play = null;\n            _this2.elements.captions = null;\n            _this2.elements.controls = null;\n            _this2.elements.wrapper = null;\n          } // Callback\n\n\n          if (is$1.function(callback)) {\n            callback();\n          }\n        } else {\n          // Unbind listeners\n          unbindListeners.call(_this2); // Replace the container with the original element provided\n\n          replaceElement(_this2.elements.original, _this2.elements.container); // Event\n\n          triggerEvent.call(_this2, _this2.elements.original, 'destroyed', true); // Callback\n\n          if (is$1.function(callback)) {\n            callback.call(_this2.elements.original);\n          } // Reset state\n\n\n          _this2.ready = false; // Clear for garbage collection\n\n          setTimeout(function () {\n            _this2.elements = null;\n            _this2.media = null;\n          }, 200);\n        }\n      }; // Stop playback\n\n\n      this.stop(); // Clear timeouts\n\n      clearTimeout(this.timers.loading);\n      clearTimeout(this.timers.controls);\n      clearTimeout(this.timers.resized); // Provider specific stuff\n\n      if (this.isHTML5) {\n        // Restore native video controls\n        ui.toggleNativeControls.call(this, true); // Clean up\n\n        done();\n      }\n    }\n    /**\n     * Check for support for a mime type (HTML5 only)\n     * @param {String} type - Mime type\n     */\n\n  }, {\n    key: \"supports\",\n    value: function supports(type) {\n      return support.mime.call(this, type);\n    }\n    /**\n     * Check for support\n     * @param {String} type - Player type (video)\n     * @param {String} provider - Provider (html5)\n     * @param {Boolean} inline - Where player has `playsinline` sttribute\n     */\n\n  }, {\n    key: \"isHTML5\",\n    get: function get() {\n      return this.provider === providers.html5;\n    }\n  }, {\n    key: \"isVideo\",\n    get: function get() {\n      return this.type === types.video;\n    }\n  }, {\n    key: \"playing\",\n    get: function get() {\n      return Boolean(this.ready && !this.paused && !this.ended);\n    }\n    /**\n     * Get paused state\n     */\n\n  }, {\n    key: \"paused\",\n    get: function get() {\n      return Boolean(this.media.paused);\n    }\n    /**\n     * Get stopped state\n     */\n\n  }, {\n    key: \"stopped\",\n    get: function get() {\n      return Boolean(this.paused && this.currentTime === 0);\n    }\n    /**\n     * Get ended state\n     */\n\n  }, {\n    key: \"ended\",\n    get: function get() {\n      return Boolean(this.media.ended);\n    }\n  }, {\n    key: \"currentTime\",\n    set: function set(input) {\n      // Bail if media duration isn't available yet\n      if (!this.duration) {\n        return;\n      } // Validate input\n\n\n      var inputIsValid = is$1.number(input) && input > 0; // Set\n\n      this.media.currentTime = inputIsValid ? Math.min(input, this.duration) : 0; // Logging\n\n      this.debug.log(\"Seeking to \".concat(this.currentTime, \" seconds\"));\n    }\n    /**\n     * Get current time\n     */\n    ,\n    get: function get() {\n      return Number(this.media.currentTime);\n    }\n    /**\n     * Get buffered\n     */\n\n  }, {\n    key: \"buffered\",\n    get: function get() {\n      var buffered = this.media.buffered;\n\n      if (is$1.number(buffered)) {\n        return buffered;\n      } // HTML5\n      // (i.e. seek to another section buffers only that section)\n\n\n      if (buffered && buffered.length && this.duration > 0) {\n        return buffered.end(0) / this.duration;\n      }\n\n      return 0;\n    }\n    /**\n     * Get seeking status\n     */\n\n  }, {\n    key: \"seeking\",\n    get: function get() {\n      return Boolean(this.media.seeking);\n    }\n    /**\n     * Get the duration of the current media\n     */\n\n  }, {\n    key: \"duration\",\n    get: function get() {\n      // Faux duration set via config\n      var fauxDuration = parseFloat(this.config.duration); // Media duration can be NaN or Infinity before the media has loaded\n\n      var realDuration = (this.media || {}).duration;\n      var duration = !is$1.number(realDuration) || realDuration === Infinity ? 0 : realDuration; // If config duration is funky, use regular duration\n\n      return fauxDuration || duration;\n    }\n    /**\n     * Set the player volume\n     * @param {Number} value - must be between 0 and 1. Defaults to the value from local storage and config.volume if not set in storage\n     */\n\n  }, {\n    key: \"volume\",\n    set: function set(value) {\n      var volume = value;\n      var max = 1;\n      var min = 0;\n\n      if (is$1.string(volume)) {\n        volume = Number(volume);\n      } // Load volume from storage if no value specified\n\n\n      if (!is$1.number(volume)) {\n        volume = this.storage.get('volume');\n      } // Use config if all else fails\n\n\n      if (!is$1.number(volume)) {\n        volume = this.config.volume;\n      } // Maximum is volumeMax\n\n\n      if (volume > max) {\n        volume = max;\n      } // Minimum is volumeMin\n\n\n      if (volume < min) {\n        volume = min;\n      } // Update config\n\n\n      this.config.volume = volume; // Set the player volume\n\n      this.media.volume = volume; // If muted, and we're increasing volume manually, reset muted state\n\n      if (!is$1.empty(value) && this.muted && volume > 0) {\n        this.muted = false;\n      }\n    }\n    /**\n     * Get the current player volume\n     */\n    ,\n    get: function get() {\n      return Number(this.media.volume);\n    }\n  }, {\n    key: \"muted\",\n    set: function set(mute) {\n      var toggle = mute; // Load muted state from storage\n\n      if (!is$1.boolean(toggle)) {\n        toggle = this.storage.get('muted');\n      } // Use config if all else fails\n\n\n      if (!is$1.boolean(toggle)) {\n        toggle = this.config.muted;\n      } // Update config\n\n\n      this.config.muted = toggle; // Set mute on the player\n\n      this.media.muted = toggle;\n    }\n    /**\n     * Get current muted state\n     */\n    ,\n    get: function get() {\n      return Boolean(this.media.muted);\n    }\n    /**\n     * Check if the media has audio\n     */\n\n  }, {\n    key: \"hasAudio\",\n    get: function get() {\n      // Assume yes for all non HTML5 (as we can't tell...)\n      if (!this.isHTML5) {\n        return true;\n      }\n\n      if (this.isAudio) {\n        return true;\n      } // Get audio tracks\n\n\n      return Boolean(this.media.mozHasAudio) || Boolean(this.media.webkitAudioDecodedByteCount) || Boolean(this.media.audioTracks && this.media.audioTracks.length);\n    }\n    /**\n     * Set playback speed\n     * @param {Number} speed - the speed of playback (0.5-2.0)\n     */\n\n  }, {\n    key: \"speed\",\n    set: function set(input) {\n      var _this3 = this;\n\n      var speed = null;\n\n      if (is$1.number(input)) {\n        speed = input;\n      }\n\n      if (!is$1.number(speed)) {\n        speed = this.storage.get('speed');\n      }\n\n      if (!is$1.number(speed)) {\n        speed = this.config.speed.selected;\n      } // Clamp to min/max\n\n\n      var min = this.minimumSpeed,\n          max = this.maximumSpeed;\n      speed = clamp(speed, min, max); // Update config\n\n      this.config.speed.selected = speed; // Set media speed\n\n      setTimeout(function () {\n        _this3.media.playbackRate = speed;\n      }, 0);\n    }\n    /**\n     * Get current playback speed\n     */\n    ,\n    get: function get() {\n      return Number(this.media.playbackRate);\n    }\n    /**\n     * Get the minimum allowed speed\n     */\n    // eslint-disable-next-line class-methods-use-this\n\n  }, {\n    key: \"minimumSpeed\",\n    get: function get() {\n      return 0.0625;\n    }\n    /**\n     * Get the maximum allowed speed\n     */\n    // eslint-disable-next-line class-methods-use-this\n\n  }, {\n    key: \"maximumSpeed\",\n    get: function get() {\n      return 16;\n    }\n    /**\n     * Set playback quality\n     * Currently HTML5 only\n     * @param {Number} input - Quality level\n     */\n\n  }, {\n    key: \"quality\",\n    set: function set(input) {\n      var config = this.config.quality;\n      var options = this.options.quality;\n\n      if (!options.length) {\n        return;\n      }\n\n      var quality = [!is$1.empty(input) && Number(input), this.storage.get('quality'), config.selected, config.default].find(is$1.number);\n      var updateStorage = true;\n\n      if (!options.includes(quality)) {\n        var value = closest$1(options, quality);\n        this.debug.warn(\"Unsupported quality option: \".concat(quality, \", using \").concat(value, \" instead\"));\n        quality = value; // Don't update storage if quality is not supported\n\n        updateStorage = false;\n      } // Update config\n\n\n      config.selected = quality; // Set quality\n\n      this.media.quality = quality; // Save to storage\n\n      if (updateStorage) {\n        this.storage.set({\n          quality: quality\n        });\n      }\n    }\n    /**\n     * Get current quality level\n     */\n    ,\n    get: function get() {\n      return this.media.quality;\n    }\n    /**\n     * Toggle loop\n     * @param {Boolean} input - Whether to loop or not\n     */\n\n  }, {\n    key: \"loop\",\n    set: function set(input) {\n      var toggle = is$1.boolean(input) ? input : this.config.loop.active;\n      this.config.loop.active = toggle;\n      this.media.loop = toggle; // Set default to be a true toggle\n\n      /* const type = ['start', 'end', 'all', 'none', 'toggle'].includes(input) ? input : 'toggle';\n           switch (type) {\n              case 'start':\n                  if (this.config.loop.end && this.config.loop.end <= this.currentTime) {\n                      this.config.loop.end = null;\n                  }\n                  this.config.loop.start = this.currentTime;\n                  // this.config.loop.indicator.start = this.elements.display.played.value;\n                  break;\n               case 'end':\n                  if (this.config.loop.start >= this.currentTime) {\n                      return this;\n                  }\n                  this.config.loop.end = this.currentTime;\n                  // this.config.loop.indicator.end = this.elements.display.played.value;\n                  break;\n               case 'all':\n                  this.config.loop.start = 0;\n                  this.config.loop.end = this.duration - 2;\n                  this.config.loop.indicator.start = 0;\n                  this.config.loop.indicator.end = 100;\n                  break;\n               case 'toggle':\n                  if (this.config.loop.active) {\n                      this.config.loop.start = 0;\n                      this.config.loop.end = null;\n                  } else {\n                      this.config.loop.start = 0;\n                      this.config.loop.end = this.duration - 2;\n                  }\n                  break;\n               default:\n                  this.config.loop.start = 0;\n                  this.config.loop.end = null;\n                  break;\n          } */\n    }\n    /**\n     * Get current loop state\n     */\n    ,\n    get: function get() {\n      return Boolean(this.media.loop);\n    }\n    /**\n     * Set new media source\n     * @param {Object} input - The new source object (see docs)\n     */\n\n  }, {\n    key: \"source\",\n    set: function set(input) {\n      source.change.call(this, input);\n    }\n    /**\n     * Get current source\n     */\n    ,\n    get: function get() {\n      return this.media.currentSrc;\n    }\n    /**\n     * Get a download URL (either source or custom)\n     */\n\n  }, {\n    key: \"download\",\n    get: function get() {\n      var download = this.config.urls.download;\n      return is$1.url(download) ? download : this.source;\n    }\n    /**\n     * Set the download URL\n     */\n    ,\n    set: function set(input) {\n      if (!is$1.url(input)) {\n        return;\n      }\n\n      this.config.urls.download = input;\n      controls.setDownloadUrl.call(this);\n    }\n    /**\n     * Set the poster image for a video\n     * @param {String} input - the URL for the new poster image\n     */\n\n  }, {\n    key: \"poster\",\n    set: function set(input) {\n      if (!this.isVideo) {\n        this.debug.warn('Poster can only be set for video');\n        return;\n      }\n\n      ui.setPoster.call(this, input, false).catch(function () {});\n    }\n    /**\n     * Get the current poster image\n     */\n    ,\n    get: function get() {\n      if (!this.isVideo) {\n        return null;\n      }\n\n      return this.media.getAttribute('poster') || this.media.getAttribute('data-poster');\n    }\n    /**\n     * Get the current aspect ratio in use\n     */\n\n  }, {\n    key: \"ratio\",\n    get: function get() {\n      if (!this.isVideo) {\n        return null;\n      }\n\n      var ratio = reduceAspectRatio(getAspectRatio.call(this));\n      return is$1.array(ratio) ? ratio.join(':') : ratio;\n    }\n    /**\n     * Set video aspect ratio\n     */\n    ,\n    set: function set(input) {\n      if (!this.isVideo) {\n        this.debug.warn('Aspect ratio can only be set for video');\n        return;\n      }\n\n      if (!is$1.string(input) || !validateRatio(input)) {\n        this.debug.error(\"Invalid aspect ratio specified (\".concat(input, \")\"));\n        return;\n      }\n\n      this.config.ratio = input;\n      setAspectRatio.call(this);\n    }\n    /**\n     * Set the autoplay state\n     * @param {Boolean} input - Whether to autoplay or not\n     */\n\n  }, {\n    key: \"autoplay\",\n    set: function set(input) {\n      var toggle = is$1.boolean(input) ? input : this.config.autoplay;\n      this.config.autoplay = toggle;\n    }\n    /**\n     * Get the current autoplay state\n     */\n    ,\n    get: function get() {\n      return Boolean(this.config.autoplay);\n    }\n  }, {\n    key: \"currentTrack\",\n    set: function set(input) {\n      captions.set.call(this, input, false);\n    }\n    /**\n     * Get the current caption track index (-1 if disabled)\n     */\n    ,\n    get: function get() {\n      var _this$captions = this.captions,\n          toggled = _this$captions.toggled,\n          currentTrack = _this$captions.currentTrack;\n      return toggled ? currentTrack : -1;\n    }\n    /**\n     * Set the wanted language for captions\n     * Since tracks can be added later it won't update the actual caption track until there is a matching track\n     * @param {String} - Two character ISO language code (e.g. EN, FR, PT, etc)\n     */\n\n  }, {\n    key: \"language\",\n    set: function set(input) {\n      captions.setLanguage.call(this, input, false);\n    }\n    /**\n     * Get the current track's language\n     */\n    ,\n    get: function get() {\n      return (captions.getCurrentTrack.call(this) || {}).language;\n    }\n    /**\n     * Toggle picture-in-picture playback on WebKit/MacOS\n     */\n\n  }, {\n    key: \"pip\",\n    set: function set(input) {\n      // Bail if no support\n      if (!support.pip) {\n        return;\n      } // Toggle based on current state if not passed\n\n\n      var toggle = is$1.boolean(input) ? input : !this.pip; // Toggle based on current state\n      // Safari\n\n      if (is$1.function(this.media.webkitSetPresentationMode)) {\n        this.media.webkitSetPresentationMode(toggle ? pip.active : pip.inactive);\n      } // Chrome\n\n\n      if (is$1.function(this.media.requestPictureInPicture)) {\n        if (!this.pip && toggle) {\n          this.media.requestPictureInPicture();\n        } else if (this.pip && !toggle) {\n          document.exitPictureInPicture();\n        }\n      }\n    }\n    /**\n     * Get the current picture-in-picture state\n     */\n    ,\n    get: function get() {\n      if (!support.pip) {\n        return null;\n      } // Safari\n\n\n      if (!is$1.empty(this.media.webkitPresentationMode)) {\n        return this.media.webkitPresentationMode === pip.active;\n      } // Chrome\n\n\n      return this.media === document.pictureInPictureElement;\n    }\n  }], [{\n    key: \"supported\",\n    value: function supported(type, provider, inline) {\n      return support.check(type, provider, inline);\n    }\n    /**\n     * Load an SVG sprite into the page\n     * @param {String} url - URL for the SVG sprite\n     * @param {String} [id] - Unique ID\n     */\n\n  }, {\n    key: \"loadSprite\",\n    value: function loadSprite$1(url, id) {\n      return loadSprite(url, id);\n    }\n    /**\n     * Setup multiple instances\n     * @param {*} selector\n     * @param {Object} options\n     */\n\n  }, {\n    key: \"setup\",\n    value: function setup(selector) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var targets = null;\n\n      if (is$1.string(selector)) {\n        targets = Array.from(document.querySelectorAll(selector));\n      } else if (is$1.nodeList(selector)) {\n        targets = Array.from(selector);\n      } else if (is$1.array(selector)) {\n        targets = selector.filter(is$1.element);\n      }\n\n      if (is$1.empty(targets)) {\n        return null;\n      }\n\n      return targets.map(function (t) {\n        return new WassPlayer(t, options);\n      });\n    }\n  }]);\n\n  return WassPlayer;\n}();\n\nWassPlayer.defaults = cloneDeep(defaults$1);\n\nexport default WassPlayer;\n","function _classCallCheck(e,t){if(!(e instanceof t))throw new TypeError(\"Cannot call a class as a function\")}function _defineProperties(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,\"value\"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}function _createClass(e,t,n){return t&&_defineProperties(e.prototype,t),n&&_defineProperties(e,n),e}function _defineProperty(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function ownKeys(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function _objectSpread2(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?ownKeys(Object(n),!0).forEach((function(t){_defineProperty(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):ownKeys(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}var defaults={addCSS:!0,thumbWidth:15,watch:!0};function matches(e,t){return function(){return Array.from(document.querySelectorAll(t)).includes(this)}.call(e,t)}function trigger(e,t){if(e&&t){var n=new Event(t,{bubbles:!0});e.dispatchEvent(n)}}var getConstructor=function(e){return null!=e?e.constructor:null},instanceOf=function(e,t){return!!(e&&t&&e instanceof t)},isNullOrUndefined=function(e){return null==e},isObject=function(e){return getConstructor(e)===Object},isNumber=function(e){return getConstructor(e)===Number&&!Number.isNaN(e)},isString=function(e){return getConstructor(e)===String},isBoolean=function(e){return getConstructor(e)===Boolean},isFunction=function(e){return getConstructor(e)===Function},isArray=function(e){return Array.isArray(e)},isNodeList=function(e){return instanceOf(e,NodeList)},isElement=function(e){return instanceOf(e,Element)},isEvent=function(e){return instanceOf(e,Event)},isEmpty=function(e){return isNullOrUndefined(e)||(isString(e)||isArray(e)||isNodeList(e))&&!e.length||isObject(e)&&!Object.keys(e).length},is={nullOrUndefined:isNullOrUndefined,object:isObject,number:isNumber,string:isString,boolean:isBoolean,function:isFunction,array:isArray,nodeList:isNodeList,element:isElement,event:isEvent,empty:isEmpty};function getDecimalPlaces(e){var t=\"\".concat(e).match(/(?:\\.(\\d+))?(?:[eE]([+-]?\\d+))?$/);return t?Math.max(0,(t[1]?t[1].length:0)-(t[2]?+t[2]:0)):0}function round(e,t){if(1>t){var n=getDecimalPlaces(t);return parseFloat(e.toFixed(n))}return Math.round(e/t)*t}var RangeTouch=function(){function e(t,n){_classCallCheck(this,e),is.element(t)?this.element=t:is.string(t)&&(this.element=document.querySelector(t)),is.element(this.element)&&is.empty(this.element.rangeTouch)&&(this.config=_objectSpread2({},defaults,{},n),this.init())}return _createClass(e,[{key:\"init\",value:function(){e.enabled&&(this.config.addCSS&&(this.element.style.userSelect=\"none\",this.element.style.webKitUserSelect=\"none\",this.element.style.touchAction=\"manipulation\"),this.listeners(!0),this.element.rangeTouch=this)}},{key:\"destroy\",value:function(){e.enabled&&(this.config.addCSS&&(this.element.style.userSelect=\"\",this.element.style.webKitUserSelect=\"\",this.element.style.touchAction=\"\"),this.listeners(!1),this.element.rangeTouch=null)}},{key:\"listeners\",value:function(e){var t=this,n=e?\"addEventListener\":\"removeEventListener\";[\"touchstart\",\"touchmove\",\"touchend\"].forEach((function(e){t.element[n](e,(function(e){return t.set(e)}),!1)}))}},{key:\"get\",value:function(t){if(!e.enabled||!is.event(t))return null;var n,r=t.target,i=t.changedTouches[0],o=parseFloat(r.getAttribute(\"min\"))||0,s=parseFloat(r.getAttribute(\"max\"))||100,u=parseFloat(r.getAttribute(\"step\"))||1,c=r.getBoundingClientRect(),a=100/c.width*(this.config.thumbWidth/2)/100;return 0>(n=100/c.width*(i.clientX-c.left))?n=0:100<n&&(n=100),50>n?n-=(100-2*n)*a:50<n&&(n+=2*(n-50)*a),o+round(n/100*(s-o),u)}},{key:\"set\",value:function(t){e.enabled&&is.event(t)&&!t.target.disabled&&(t.preventDefault(),t.target.value=this.get(t),trigger(t.target,\"touchend\"===t.type?\"change\":\"input\"))}}],[{key:\"setup\",value:function(t){var n=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{},r=null;if(is.empty(t)||is.string(t)?r=Array.from(document.querySelectorAll(is.string(t)?t:'input[type=\"range\"]')):is.element(t)?r=[t]:is.nodeList(t)?r=Array.from(t):is.array(t)&&(r=t.filter(is.element)),is.empty(r))return null;var i=_objectSpread2({},defaults,{},n);if(is.string(t)&&i.watch){var o=new MutationObserver((function(n){Array.from(n).forEach((function(n){Array.from(n.addedNodes).forEach((function(n){is.element(n)&&matches(n,t)&&new e(n,i)}))}))}));o.observe(document.body,{childList:!0,subtree:!0})}return r.map((function(t){return new e(t,n)}))}},{key:\"enabled\",get:function(){return\"ontouchstart\"in document.documentElement}}]),e}();export default RangeTouch;","// ==========================================================================\n// Type checking utils\n// ==========================================================================\n\nconst getConstructor = input => (input !== null && typeof input !== 'undefined' ? input.constructor : null);\nconst instanceOf = (input, constructor) => Boolean(input && constructor && input instanceof constructor);\nconst isNullOrUndefined = input => input === null || typeof input === 'undefined';\nconst isObject = input => getConstructor(input) === Object;\nconst isNumber = input => getConstructor(input) === Number && !Number.isNaN(input);\nconst isString = input => getConstructor(input) === String;\nconst isBoolean = input => getConstructor(input) === Boolean;\nconst isFunction = input => getConstructor(input) === Function;\nconst isArray = input => Array.isArray(input);\nconst isWeakMap = input => instanceOf(input, WeakMap);\nconst isNodeList = input => instanceOf(input, NodeList);\nconst isElement = input => instanceOf(input, Element);\nconst isTextNode = input => getConstructor(input) === Text;\nconst isEvent = input => instanceOf(input, Event);\nconst isKeyboardEvent = input => instanceOf(input, KeyboardEvent);\nconst isCue = input => instanceOf(input, window.TextTrackCue) || instanceOf(input, window.VTTCue);\nconst isTrack = input => instanceOf(input, TextTrack) || (!isNullOrUndefined(input) && isString(input.kind));\nconst isPromise = input => instanceOf(input, Promise) && isFunction(input.then);\n\nconst isEmpty = input =>\n  isNullOrUndefined(input) ||\n  ((isString(input) || isArray(input) || isNodeList(input)) && !input.length) ||\n  (isObject(input) && !Object.keys(input).length);\n\nconst isUrl = input => {\n  // Accept a URL object\n  if (instanceOf(input, window.URL)) {\n    return true;\n  }\n\n  // Must be string from here\n  if (!isString(input)) {\n    return false;\n  }\n\n  // Add the protocol if required\n  let string = input;\n  if (!input.startsWith('http://') || !input.startsWith('https://')) {\n    string = `http://${input}`;\n  }\n\n  try {\n    return !isEmpty(new URL(string).hostname);\n  } catch (e) {\n    return false;\n  }\n};\n\nexport default {\n  nullOrUndefined: isNullOrUndefined,\n  object: isObject,\n  number: isNumber,\n  string: isString,\n  boolean: isBoolean,\n  function: isFunction,\n  array: isArray,\n  weakMap: isWeakMap,\n  nodeList: isNodeList,\n  element: isElement,\n  textNode: isTextNode,\n  event: isEvent,\n  keyboardEvent: isKeyboardEvent,\n  cue: isCue,\n  track: isTrack,\n  promise: isPromise,\n  url: isUrl,\n  empty: isEmpty,\n};\n","// ==========================================================================\n// Animation utils\n// ==========================================================================\n\nimport is from './is';\n\nexport const transitionEndEvent = (() => {\n  const element = document.createElement('span');\n\n  const events = {\n    WebkitTransition: 'webkitTransitionEnd',\n    MozTransition: 'transitionend',\n    OTransition: 'oTransitionEnd otransitionend',\n    transition: 'transitionend',\n  };\n\n  const type = Object.keys(events).find(event => element.style[event] !== undefined);\n\n  return is.string(type) ? events[type] : false;\n})();\n\n// Force repaint of element\nexport function repaint(element, delay) {\n  setTimeout(() => {\n    try {\n      // eslint-disable-next-line no-param-reassign\n      element.hidden = true;\n\n      // eslint-disable-next-line no-unused-expressions\n      element.offsetHeight;\n\n      // eslint-disable-next-line no-param-reassign\n      element.hidden = false;\n    } catch (e) {\n      // Do nothing\n    }\n  }, delay);\n}\n","// ==========================================================================\n// Browser sniffing\n// Unfortunately, due to mixed support, UA sniffing is required\n// ==========================================================================\n\nconst browser = {\n  isIE: /* @cc_on!@ */ false || !!document.documentMode,\n  isEdge: window.navigator.userAgent.includes('Edge'),\n  isWebkit: 'WebkitAppearance' in document.documentElement.style && !/Edge/.test(navigator.userAgent),\n  isIPhone: /(iPhone|iPod)/gi.test(navigator.platform),\n  isIos: /(iPad|iPhone|iPod)/gi.test(navigator.platform),\n};\n\nexport default browser;\n","// ==========================================================================\n// Object utils\n// ==========================================================================\n\nimport is from './is';\n\n// Clone nested objects\nexport function cloneDeep(object) {\n  return JSON.parse(JSON.stringify(object));\n}\n\n// Get a nested value in an object\nexport function getDeep(object, path) {\n  return path.split('.').reduce((obj, key) => obj && obj[key], object);\n}\n\n// Deep extend destination object with N more objects\nexport function extend(target = {}, ...sources) {\n  if (!sources.length) {\n    return target;\n  }\n\n  const source = sources.shift();\n\n  if (!is.object(source)) {\n    return target;\n  }\n\n  Object.keys(source).forEach(key => {\n    if (is.object(source[key])) {\n      if (!Object.keys(target).includes(key)) {\n        Object.assign(target, { [key]: {} });\n      }\n\n      extend(target[key], source[key]);\n    } else {\n      Object.assign(target, { [key]: source[key] });\n    }\n  });\n\n  return extend(target, ...sources);\n}\n","// ==========================================================================\n// Element utils\n// ==========================================================================\n\nimport is from './is';\nimport { extend } from './objects';\n\n// Wrap an element\nexport function wrap(elements, wrapper) {\n  // Convert `elements` to an array, if necessary.\n  const targets = elements.length ? elements : [elements];\n\n  // Loops backwards to prevent having to clone the wrapper on the\n  // first element (see `child` below).\n  Array.from(targets)\n    .reverse()\n    .forEach((element, index) => {\n      const child = index > 0 ? wrapper.cloneNode(true) : wrapper;\n      // Cache the current parent and sibling.\n      const parent = element.parentNode;\n      const sibling = element.nextSibling;\n\n      // Wrap the element (is automatically removed from its current\n      // parent).\n      child.appendChild(element);\n\n      // If the element had a sibling, insert the wrapper before\n      // the sibling to maintain the HTML structure; otherwise, just\n      // append it to the parent.\n      if (sibling) {\n        parent.insertBefore(child, sibling);\n      } else {\n        parent.appendChild(child);\n      }\n    });\n}\n\n// Set attributes\nexport function setAttributes(element, attributes) {\n  if (!is.element(element) || is.empty(attributes)) {\n    return;\n  }\n\n  // Assume null and undefined attributes should be left out,\n  // Setting them would otherwise convert them to \"null\" and \"undefined\"\n  Object.entries(attributes)\n    .filter(([, value]) => !is.nullOrUndefined(value))\n    .forEach(([key, value]) => element.setAttribute(key, value));\n}\n\n// Create a DocumentFragment\nexport function createElement(type, attributes, text) {\n  // Create a new <element>\n  const element = document.createElement(type);\n\n  // Set all passed attributes\n  if (is.object(attributes)) {\n    setAttributes(element, attributes);\n  }\n\n  // Add text node\n  if (is.string(text)) {\n    element.innerText = text;\n  }\n\n  // Return built element\n  return element;\n}\n\n// Inaert an element after another\nexport function insertAfter(element, target) {\n  if (!is.element(element) || !is.element(target)) {\n    return;\n  }\n\n  target.parentNode.insertBefore(element, target.nextSibling);\n}\n\n// Insert a DocumentFragment\nexport function insertElement(type, parent, attributes, text) {\n  if (!is.element(parent)) {\n    return;\n  }\n\n  parent.appendChild(createElement(type, attributes, text));\n}\n\n// Remove element(s)\nexport function removeElement(element) {\n  if (is.nodeList(element) || is.array(element)) {\n    Array.from(element).forEach(removeElement);\n    return;\n  }\n\n  if (!is.element(element) || !is.element(element.parentNode)) {\n    return;\n  }\n\n  element.parentNode.removeChild(element);\n}\n\n// Remove all child elements\nexport function emptyElement(element) {\n  if (!is.element(element)) {\n    return;\n  }\n\n  let { length } = element.childNodes;\n\n  while (length > 0) {\n    element.removeChild(element.lastChild);\n    length -= 1;\n  }\n}\n\n// Replace element\nexport function replaceElement(newChild, oldChild) {\n  if (!is.element(oldChild) || !is.element(oldChild.parentNode) || !is.element(newChild)) {\n    return null;\n  }\n\n  oldChild.parentNode.replaceChild(newChild, oldChild);\n\n  return newChild;\n}\n\n// Get an attribute object from a string selector\nexport function getAttributesFromSelector(sel, existingAttributes) {\n  // For example:\n  // '.test' to { class: 'test' }\n  // '#test' to { id: 'test' }\n  // '[data-test=\"test\"]' to { 'data-test': 'test' }\n\n  if (!is.string(sel) || is.empty(sel)) {\n    return {};\n  }\n\n  const attributes = {};\n  const existing = extend({}, existingAttributes);\n\n  sel.split(',').forEach(s => {\n    // Remove whitespace\n    const selector = s.trim();\n    const className = selector.replace('.', '');\n    const stripped = selector.replace(/[[\\]]/g, '');\n    // Get the parts and value\n    const parts = stripped.split('=');\n    const [key] = parts;\n    const value = parts.length > 1 ? parts[1].replace(/[\"']/g, '') : '';\n    // Get the first character\n    const start = selector.charAt(0);\n\n    switch (start) {\n      case '.':\n        // Add to existing classname\n        if (is.string(existing.class)) {\n          attributes.class = `${existing.class} ${className}`;\n        } else {\n          attributes.class = className;\n        }\n        break;\n\n      case '#':\n        // ID selector\n        attributes.id = selector.replace('#', '');\n        break;\n\n      case '[':\n        // Attribute selector\n        attributes[key] = value;\n\n        break;\n\n      default:\n        break;\n    }\n  });\n\n  return extend(existing, attributes);\n}\n\n// Toggle hidden\nexport function toggleHidden(element, hidden) {\n  if (!is.element(element)) {\n    return;\n  }\n\n  let hide = hidden;\n\n  if (!is.boolean(hide)) {\n    hide = !element.hidden;\n  }\n\n  // eslint-disable-next-line no-param-reassign\n  element.hidden = hide;\n}\n\n// Mirror Element.classList.toggle, with IE compatibility for \"force\" argument\nexport function toggleClass(element, className, force) {\n  if (is.nodeList(element)) {\n    return Array.from(element).map(e => toggleClass(e, className, force));\n  }\n\n  if (is.element(element)) {\n    let method = 'toggle';\n    if (typeof force !== 'undefined') {\n      method = force ? 'add' : 'remove';\n    }\n\n    element.classList[method](className);\n    return element.classList.contains(className);\n  }\n\n  return false;\n}\n\n// Has class name\nexport function hasClass(element, className) {\n  return is.element(element) && element.classList.contains(className);\n}\n\n// Element matches selector\nexport function matches(element, selector) {\n  const { prototype } = Element;\n\n  function match() {\n    return Array.from(document.querySelectorAll(selector)).includes(this);\n  }\n\n  const method =\n    prototype.matches ||\n    prototype.webkitMatchesSelector ||\n    prototype.mozMatchesSelector ||\n    prototype.msMatchesSelector ||\n    match;\n\n  return method.call(element, selector);\n}\n\n// Closest ancestor element matching selector (also tests element itself)\nexport function closest(element, selector) {\n  const { prototype } = Element;\n\n  // https://developer.mozilla.org/en-US/docs/Web/API/Element/closest#Polyfill\n  function closestElement() {\n    let el = this;\n\n    do {\n      if (matches.matches(el, selector)) return el;\n      el = el.parentElement || el.parentNode;\n    } while (el !== null && el.nodeType === 1);\n    return null;\n  }\n\n  const method = prototype.closest || closestElement;\n\n  return method.call(element, selector);\n}\n\n// Find all elements\nexport function getElements(selector) {\n  return this.elements.container.querySelectorAll(selector);\n}\n\n// Find a single element\nexport function getElement(selector) {\n  return this.elements.container.querySelector(selector);\n}\n\n// Set focus and tab focus class\nexport function setFocus(element = null, tabFocus = false) {\n  if (!is.element(element)) {\n    return;\n  }\n\n  // Set regular focus\n  element.focus({ preventScroll: true });\n\n  // If we want to mimic keyboard focus via tab\n  if (tabFocus) {\n    toggleClass(element, this.config.classNames.tabFocus);\n  }\n}\n","// ==========================================================================\n// WassPlayer support checks\n// ==========================================================================\n\nimport { transitionEndEvent } from './utils/animation';\nimport browser from './utils/browser';\nimport { createElement } from './utils/elements';\nimport is from './utils/is';\n\n// Default codecs for checking mimetype support\nconst defaultCodecs = {\n  'audio/ogg': 'vorbis',\n  'audio/wav': '1',\n  'video/webm': 'vp8, vorbis',\n  'video/mp4': 'avc1.42E01E, mp4a.40.2',\n  'video/ogg': 'theora',\n};\n\n// Check for feature support\nconst support = {\n  // Basic support\n  audio: 'canPlayType' in document.createElement('audio'),\n  video: 'canPlayType' in document.createElement('video'),\n\n  // Check for support\n  // Basic functionality vs full UI\n  check(type, provider, playsinline) {\n    const canPlayInline = browser.isIPhone && playsinline && support.playsinline;\n    const api = support[type] || provider !== 'html5';\n    const ui = api && support.rangeInput && (type !== 'video' || !browser.isIPhone || canPlayInline);\n\n    return {\n      api,\n      ui,\n    };\n  },\n\n  // Picture-in-picture support\n  // Safari & Chrome only currently\n  pip: (() => {\n    if (browser.isIPhone) {\n      return false;\n    }\n\n    // Safari\n    // https://developer.apple.com/documentation/webkitjs/adding_picture_in_picture_to_your_safari_media_controls\n    if (is.function(createElement('video').webkitSetPresentationMode)) {\n      return true;\n    }\n\n    // Chrome\n    // https://developers.google.com/web/updates/2018/10/watch-video-using-picture-in-picture\n    if (document.pictureInPictureEnabled && !createElement('video').disablePictureInPicture) {\n      return true;\n    }\n\n    return false;\n  })(),\n\n  // Airplay support\n  // Safari only currently\n  airplay: is.function(window.WebKitPlaybackTargetAvailabilityEvent),\n\n  // Inline playback support\n  // https://webkit.org/blog/6784/new-video-policies-for-ios/\n  playsinline: 'playsInline' in document.createElement('video'),\n\n  // Check for mime type support against a player instance\n  // Credits: http://diveintohtml5.info/everything.html\n  // Related: http://www.leanbackplayer.com/test/h5mt.html\n  mime(input) {\n    if (is.empty(input)) {\n      return false;\n    }\n\n    const [mediaType] = input.split('/');\n    let type = input;\n\n    // Verify we're using HTML5 and there's no media type mismatch\n    if (!this.isHTML5 || mediaType !== this.type) {\n      return false;\n    }\n\n    // Add codec if required\n    if (Object.keys(defaultCodecs).includes(type)) {\n      type += `; codecs=\"${defaultCodecs[input]}\"`;\n    }\n\n    try {\n      return Boolean(type && this.media.canPlayType(type).replace(/no/, ''));\n    } catch (e) {\n      return false;\n    }\n  },\n\n  // Check for textTracks support\n  textTracks: 'textTracks' in document.createElement('video'),\n\n  // <input type=\"range\"> Sliders\n  rangeInput: (() => {\n    const range = document.createElement('input');\n    range.type = 'range';\n    return range.type === 'range';\n  })(),\n\n  // Touch\n  // NOTE: Remember a device can be mouse + touch enabled so we check on first touch event\n  touch: 'ontouchstart' in document.documentElement,\n\n  // Detect transitions support\n  transitions: transitionEndEvent !== false,\n\n  // Reduced motion iOS & MacOS setting\n  // https://webkit.org/blog/7551/responsive-design-for-motion/\n  reducedMotion: 'matchMedia' in window && window.matchMedia('(prefers-reduced-motion)').matches,\n};\n\nexport default support;\n","// ==========================================================================\n// Event utils\n// ==========================================================================\n\nimport is from './is';\n\n// Check for passive event listener support\n// https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md\n// https://www.youtube.com/watch?v=NPM6172J22g\nconst supportsPassiveListeners = (() => {\n  // Test via a getter in the options object to see if the passive property is accessed\n  let supported = false;\n  try {\n    const options = Object.defineProperty({}, 'passive', {\n      get() {\n        supported = true;\n        return null;\n      },\n    });\n    window.addEventListener('test', null, options);\n    window.removeEventListener('test', null, options);\n  } catch (e) {\n    // Do nothing\n  }\n\n  return supported;\n})();\n\n// Toggle event listener\nexport function toggleListener(element, event, callback, toggle = false, passive = true, capture = false) {\n  // Bail if no element, event, or callback\n  if (!element || !('addEventListener' in element) || is.empty(event) || !is.function(callback)) {\n    return;\n  }\n\n  // Allow multiple events\n  const events = event.split(' ');\n  // Build options\n  // Default to just the capture boolean for browsers with no passive listener support\n  let options = capture;\n\n  // If passive events listeners are supported\n  if (supportsPassiveListeners) {\n    options = {\n      // Whether the listener can be passive (i.e. default never prevented)\n      passive,\n      // Whether the listener is a capturing listener or not\n      capture,\n    };\n  }\n\n  // If a single node is passed, bind the event listener\n  events.forEach(type => {\n    if (this && this.eventListeners && toggle) {\n      // Cache event listener\n      this.eventListeners.push({ element, type, callback, options });\n    }\n\n    element[toggle ? 'addEventListener' : 'removeEventListener'](type, callback, options);\n  });\n}\n\n// Bind event handler\nexport function on(element, events = '', callback, passive = true, capture = false) {\n  toggleListener.call(this, element, events, callback, true, passive, capture);\n}\n\n// Unbind event handler\nexport function off(element, events = '', callback, passive = true, capture = false) {\n  toggleListener.call(this, element, events, callback, false, passive, capture);\n}\n\n// Bind once-only event handler\nexport function once(element, events = '', callback, passive = true, capture = false) {\n  const onceCallback = (...args) => {\n    off(element, events, onceCallback, passive, capture);\n    callback.apply(this, args);\n  };\n\n  toggleListener.call(this, element, events, onceCallback, true, passive, capture);\n}\n\n// Trigger event\nexport function triggerEvent(element, type = '', bubbles = false, detail = {}) {\n  // Bail if no element\n  if (!is.element(element) || is.empty(type)) {\n    return;\n  }\n\n  // Create and dispatch the event\n  const event = new CustomEvent(type, {\n    bubbles,\n    detail: { ...detail, plyr: this },\n  });\n\n  // Dispatch the event\n  element.dispatchEvent(event);\n}\n\n// Unbind all cached event listeners\nexport function unbindListeners() {\n  if (this && this.eventListeners) {\n    this.eventListeners.forEach(item => {\n      const { element, type, callback, options } = item;\n      element.removeEventListener(type, callback, options);\n    });\n\n    this.eventListeners = [];\n  }\n}\n\n// Run method when / if player is ready\nexport function ready() {\n  return new Promise(resolve =>\n    this.ready ? setTimeout(resolve, 0) : on.call(this, this.elements.container, 'ready', resolve),\n  ).then(() => {});\n}\n","import is from './is';\n/**\n * Silence a Promise-like object.\n * This is useful for avoiding non-harmful, but potentially confusing \"uncaught\n * play promise\" rejection error messages.\n * @param  {Object} value An object that may or may not be `Promise`-like.\n */\nexport function silencePromise(value) {\n  if (is.promise(value)) {\n    value.then(null, () => {});\n  }\n}\n\nexport default { silencePromise };\n","// ==========================================================================\n// Style utils\n// ==========================================================================\n\nimport is from './is';\n\nexport function validateRatio(input) {\n  if (!is.array(input) && (!is.string(input) || !input.includes(':'))) {\n    return false;\n  }\n\n  const ratio = is.array(input) ? input : input.split(':');\n\n  return ratio.map(Number).every(is.number);\n}\n\nexport function reduceAspectRatio(ratio) {\n  if (!is.array(ratio) || !ratio.every(is.number)) {\n    return null;\n  }\n\n  const [width, height] = ratio;\n  const getDivider = (w, h) => (h === 0 ? w : getDivider(h, w % h));\n  const divider = getDivider(width, height);\n\n  return [width / divider, height / divider];\n}\n\nexport function getAspectRatio(input) {\n  const parse = ratio => (validateRatio(ratio) ? ratio.split(':').map(Number) : null);\n  // Try provided ratio\n  let ratio = parse(input);\n\n  // Get from config\n  if (ratio === null) {\n    ratio = parse(this.config.ratio);\n  }\n\n  // Get from embed\n  if (ratio === null && !is.empty(this.embed) && is.array(this.embed.ratio)) {\n    ({ ratio } = this.embed);\n  }\n\n  // Get from HTML5 video\n  if (ratio === null && this.isHTML5) {\n    const { videoWidth, videoHeight } = this.media;\n    ratio = reduceAspectRatio([videoWidth, videoHeight]);\n  }\n\n  return ratio;\n}\n\n// Set aspect ratio for responsive container\nexport function setAspectRatio(input) {\n  if (!this.isVideo) {\n    return {};\n  }\n\n  const { wrapper } = this.elements;\n  const ratio = getAspectRatio.call(this, input);\n  const [w, h] = is.array(ratio) ? ratio : [0, 0];\n  const padding = (100 / w) * h;\n\n  wrapper.style.paddingBottom = `${padding}%`;\n\n  // For Vimeo we have an extra <div> to hide the standard controls and UI\n  if (this.isVimeo && !this.config.vimeo.premium && this.supported.ui) {\n    const height = (100 / this.media.offsetWidth) * parseInt(window.getComputedStyle(this.media).paddingBottom, 10);\n    const offset = (height - padding) / (height / 50);\n\n    this.media.style.transform = `translateY(-${offset}%)`;\n  } else if (this.isHTML5) {\n    wrapper.classList.toggle(this.config.classNames.videoFixedRatio, ratio !== null);\n  }\n\n  return { padding, ratio };\n}\n\nexport default { setAspectRatio };\n","// ==========================================================================\n// WassPlayer HTML5 helpers\n// ==========================================================================\n\nimport support from './support';\nimport { removeElement } from './utils/elements';\nimport { triggerEvent } from './utils/events';\nimport is from './utils/is';\nimport { silencePromise } from './utils/promise';\nimport { setAspectRatio } from './utils/style';\n\nconst html5 = {\n  getSources() {\n    if (!this.isHTML5) {\n      return [];\n    }\n\n    const sources = Array.from(this.media.querySelectorAll('source'));\n\n    // Filter out unsupported sources (if type is specified)\n    return sources.filter(source => {\n      const type = source.getAttribute('type');\n\n      if (is.empty(type)) {\n        return true;\n      }\n\n      return support.mime.call(this, type);\n    });\n  },\n\n  // Get quality levels\n  getQualityOptions() {\n    // Whether we're forcing all options (e.g. for streaming)\n    if (this.config.quality.forced) {\n      return this.config.quality.options;\n    }\n\n    // Get sizes from <source> elements\n    return html5.getSources\n      .call(this)\n      .map(source => Number(source.getAttribute('size')))\n      .filter(Boolean);\n  },\n\n  setup() {\n    if (!this.isHTML5) {\n      return;\n    }\n\n    const player = this;\n\n    // Set speed options from config\n    player.options.speed = player.config.speed.options;\n\n    // Set aspect ratio if fixed\n    if (!is.empty(this.config.ratio)) {\n      setAspectRatio.call(player);\n    }\n\n    // Quality\n    Object.defineProperty(player.media, 'quality', {\n      get() {\n        // Get sources\n        const sources = html5.getSources.call(player);\n        const source = sources.find(s => s.getAttribute('src') === player.source);\n\n        // Return size, if match is found\n        return source && Number(source.getAttribute('size'));\n      },\n      set(input) {\n        if (player.quality === input) {\n          return;\n        }\n\n        // If we're using an an external handler...\n        if (player.config.quality.forced && is.function(player.config.quality.onChange)) {\n          player.config.quality.onChange(input);\n        } else {\n          // Get sources\n          const sources = html5.getSources.call(player);\n          // Get first match for requested size\n          const source = sources.find(s => Number(s.getAttribute('size')) === input);\n\n          // No matching source found\n          if (!source) {\n            return;\n          }\n\n          // Get current state\n          const { currentTime, paused, preload, readyState, playbackRate } = player.media;\n\n          // Set new source\n          player.media.src = source.getAttribute('src');\n\n          // Prevent loading if preload=\"none\" and the current source isn't loaded (#1044)\n          if (preload !== 'none' || readyState) {\n            // Restore time\n            player.once('loadedmetadata', () => {\n              player.speed = playbackRate;\n              player.currentTime = currentTime;\n\n              // Resume playing\n              if (!paused) {\n                silencePromise(player.play());\n              }\n            });\n\n            // Load new source\n            player.media.load();\n          }\n        }\n\n        // Trigger change event\n        triggerEvent.call(player, player.media, 'qualitychange', false, {\n          quality: input,\n        });\n      },\n    });\n  },\n\n  // Cancel current network requests\n  // See https://github.com/sampotts/WassPlayer/issues/174\n  cancelRequests() {\n    if (!this.isHTML5) {\n      return;\n    }\n\n    // Remove child sources\n    removeElement(html5.getSources.call(this));\n\n    // Set blank video src attribute\n    // This is to prevent a MEDIA_ERR_SRC_NOT_SUPPORTED error\n    // Info: http://stackoverflow.com/questions/32231579/how-to-properly-dispose-of-an-html5-video-and-close-socket-or-connection\n    this.media.setAttribute('src', this.config.blankVideo);\n\n    // Load the new empty source\n    // This will cancel existing requests\n    // See https://github.com/sampotts/WassPlayer/issues/174\n    this.media.load();\n\n    // Debugging\n    this.debug.log('Cancelled network requests');\n  },\n};\n\nexport default html5;\n","// ==========================================================================\n// Array utils\n// ==========================================================================\n\nimport is from './is';\n\n// Remove duplicates in an array\nexport function dedupe(array) {\n  if (!is.array(array)) {\n    return array;\n  }\n\n  return array.filter((item, index) => array.indexOf(item) === index);\n}\n\n// Get the closest value in an array\nexport function closest(array, value) {\n  if (!is.array(array) || !array.length) {\n    return null;\n  }\n\n  return array.reduce((prev, curr) => (Math.abs(curr - value) < Math.abs(prev - value) ? curr : prev));\n}\n","// ==========================================================================\n// String utils\n// ==========================================================================\n\nimport is from './is';\n\n// Generate a random ID\nexport function generateId(prefix) {\n  return `${prefix}-${Math.floor(Math.random() * 10000)}`;\n}\n\n// Format string\nexport function format(input, ...args) {\n  if (is.empty(input)) {\n    return input;\n  }\n\n  return input.toString().replace(/{(\\d+)}/g, (match, i) => args[i].toString());\n}\n\n// Get percentage\nexport function getPercentage(current, max) {\n  if (current === 0 || max === 0 || Number.isNaN(current) || Number.isNaN(max)) {\n    return 0;\n  }\n\n  return ((current / max) * 100).toFixed(2);\n}\n\n// Replace all occurances of a string in a string\nexport const replaceAll = (input = '', find = '', replace = '') =>\n  input.replace(new RegExp(find.toString().replace(/([.*+?^=!:${}()|[\\]/\\\\])/g, '\\\\$1'), 'g'), replace.toString());\n\n// Convert to title case\nexport const toTitleCase = (input = '') =>\n  input.toString().replace(/\\w\\S*/g, text => text.charAt(0).toUpperCase() + text.substr(1).toLowerCase());\n\n// Convert string to pascalCase\nexport function toPascalCase(input = '') {\n  let string = input.toString();\n\n  // Convert kebab case\n  string = replaceAll(string, '-', ' ');\n\n  // Convert snake case\n  string = replaceAll(string, '_', ' ');\n\n  // Convert to title case\n  string = toTitleCase(string);\n\n  // Convert to pascal case\n  return replaceAll(string, ' ', '');\n}\n\n// Convert string to pascalCase\nexport function toCamelCase(input = '') {\n  let string = input.toString();\n\n  // Convert to pascal case\n  string = toPascalCase(string);\n\n  // Convert first character to lowercase\n  return string.charAt(0).toLowerCase() + string.slice(1);\n}\n\n// Remove HTML from a string\nexport function stripHTML(source) {\n  const fragment = document.createDocumentFragment();\n  const element = document.createElement('div');\n  fragment.appendChild(element);\n  element.innerHTML = source;\n  return fragment.firstChild.innerText;\n}\n\n// Like outerHTML, but also works for DocumentFragment\nexport function getHTML(element) {\n  const wrapper = document.createElement('div');\n  wrapper.appendChild(element);\n  return wrapper.innerHTML;\n}\n","// ==========================================================================\n// Plyr internationalization\n// ==========================================================================\n\nimport is from './is';\nimport { getDeep } from './objects';\nimport { replaceAll } from './strings';\n\n// Skip i18n for abbreviations and brand names\nconst resources = {\n  pip: 'PIP',\n  airplay: 'AirPlay',\n  html5: 'HTML5',\n  vimeo: 'Vimeo',\n  youtube: 'YouTube',\n};\n\nconst i18n = {\n  get(key = '', config = {}) {\n    if (is.empty(key) || is.empty(config)) {\n      return '';\n    }\n\n    let string = getDeep(config.i18n, key);\n\n    if (is.empty(string)) {\n      if (Object.keys(resources).includes(key)) {\n        return resources[key];\n      }\n\n      return '';\n    }\n\n    const replace = {\n      '{seektime}': config.seekTime,\n      '{title}': config.title,\n    };\n\n    Object.entries(replace).forEach(([k, v]) => {\n      string = replaceAll(string, k, v);\n    });\n\n    return string;\n  },\n};\n\nexport default i18n;\n","// ==========================================================================\n// WassPlayer storage\n// ==========================================================================\n\nimport is from './utils/is';\nimport { extend } from './utils/objects';\n\nclass Storage {\n  constructor(player) {\n    this.enabled = player.config.storage.enabled;\n    this.key = player.config.storage.key;\n  }\n\n  // Check for actual support (see if we can use it)\n  static get supported() {\n    try {\n      if (!('localStorage' in window)) {\n        return false;\n      }\n\n      const test = '___test';\n\n      // Try to use it (it might be disabled, e.g. user is in private mode)\n      // see: https://github.com/sampotts/WassPlayer/issues/131\n      window.localStorage.setItem(test, test);\n      window.localStorage.removeItem(test);\n\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  get(key) {\n    if (!Storage.supported || !this.enabled) {\n      return null;\n    }\n\n    const store = window.localStorage.getItem(this.key);\n\n    if (is.empty(store)) {\n      return null;\n    }\n\n    const json = JSON.parse(store);\n\n    return is.string(key) && key.length ? json[key] : json;\n  }\n\n  set(object) {\n    // Bail if we don't have localStorage support or it's disabled\n    if (!Storage.supported || !this.enabled) {\n      return;\n    }\n\n    // Can only store objectst\n    if (!is.object(object)) {\n      return;\n    }\n\n    // Get current storage\n    let storage = this.get();\n\n    // Default to empty object\n    if (is.empty(storage)) {\n      storage = {};\n    }\n\n    // Update the working copy of the values\n    extend(storage, object);\n\n    // Update storage\n    window.localStorage.setItem(this.key, JSON.stringify(storage));\n  }\n}\n\nexport default Storage;\n","// ==========================================================================\n// Fetch wrapper\n// Using XHR to avoid issues with older browsers\n// ==========================================================================\n\nexport default function fetch(url, responseType = 'text') {\n  return new Promise((resolve, reject) => {\n    try {\n      const request = new XMLHttpRequest();\n\n      // Check for CORS support\n      if (!('withCredentials' in request)) {\n        return;\n      }\n\n      request.addEventListener('load', () => {\n        if (responseType === 'text') {\n          try {\n            resolve(JSON.parse(request.responseText));\n          } catch (e) {\n            resolve(request.responseText);\n          }\n        } else {\n          resolve(request.response);\n        }\n      });\n\n      request.addEventListener('error', () => {\n        throw new Error(request.status);\n      });\n\n      request.open('GET', url, true);\n\n      // Set the required response type\n      request.responseType = responseType;\n\n      request.send();\n    } catch (e) {\n      reject(e);\n    }\n  });\n}\n","// ==========================================================================\n// Sprite loader\n// ==========================================================================\n\nimport Storage from '../storage';\nimport fetch from './fetch';\nimport is from './is';\n\n// Load an external SVG sprite\nexport default function loadSprite(url, id) {\n  if (!is.string(url)) {\n    return;\n  }\n\n  const prefix = 'cache';\n  const hasId = is.string(id);\n  let isCached = false;\n  const exists = () => document.getElementById(id) !== null;\n\n  const update = (container, data) => {\n    // eslint-disable-next-line no-param-reassign\n    container.innerHTML = data;\n\n    // Check again incase of race condition\n    if (hasId && exists()) {\n      return;\n    }\n\n    // Inject the SVG to the body\n    document.body.insertAdjacentElement('afterbegin', container);\n  };\n\n  // Only load once if ID set\n  if (!hasId || !exists()) {\n    const useStorage = Storage.supported;\n    // Create container\n    const container = document.createElement('div');\n    container.setAttribute('hidden', '');\n\n    if (hasId) {\n      container.setAttribute('id', id);\n    }\n\n    // Check in cache\n    if (useStorage) {\n      const cached = window.localStorage.getItem(`${prefix}-${id}`);\n      isCached = cached !== null;\n\n      if (isCached) {\n        const data = JSON.parse(cached);\n        update(container, data.content);\n      }\n    }\n\n    // Get the sprite\n    fetch(url)\n      .then(result => {\n        if (is.empty(result)) {\n          return;\n        }\n\n        if (useStorage) {\n          window.localStorage.setItem(\n            `${prefix}-${id}`,\n            JSON.stringify({\n              content: result,\n            }),\n          );\n        }\n\n        update(container, result);\n      })\n      .catch(() => {});\n  }\n}\n","// ==========================================================================\n// Time utils\n// ==========================================================================\n\nimport is from './is';\n\n// Time helpers\nexport const getHours = value => Math.trunc((value / 60 / 60) % 60, 10);\nexport const getMinutes = value => Math.trunc((value / 60) % 60, 10);\nexport const getSeconds = value => Math.trunc(value % 60, 10);\n\n// Format time to UI friendly string\nexport function formatTime(time = 0, displayHours = false, inverted = false) {\n  // Bail if the value isn't a number\n  if (!is.number(time)) {\n    return formatTime(undefined, displayHours, inverted);\n  }\n\n  // Format time component to add leading zero\n  const format = value => `0${value}`.slice(-2);\n  // Breakdown to hours, mins, secs\n  let hours = getHours(time);\n  const mins = getMinutes(time);\n  const secs = getSeconds(time);\n\n  // Do we need to display hours?\n  if (displayHours || hours > 0) {\n    hours = `${hours}:`;\n  } else {\n    hours = '';\n  }\n\n  // Render\n  return `${inverted && time > 0 ? '-' : ''}${hours}${format(mins)}:${format(secs)}`;\n}\n","// ==========================================================================\n// WassPlayer controls\n// ==========================================================================\n\nimport RangeTouch from 'rangetouch';\n\n// eslint-disable-next-line import/no-cycle\nimport captions from './captions';\nimport html5 from './html5';\nimport support from './support';\nimport { repaint, transitionEndEvent } from './utils/animation';\nimport { dedupe } from './utils/arrays';\nimport browser from './utils/browser';\nimport {\n  createElement,\n  emptyElement,\n  getAttributesFromSelector,\n  getElement,\n  getElements,\n  hasClass,\n  matches,\n  removeElement,\n  setAttributes,\n  setFocus,\n  toggleClass,\n  toggleHidden,\n} from './utils/elements';\nimport { off, on } from './utils/events';\nimport i18n from './utils/i18n';\nimport is from './utils/is';\nimport loadSprite from './utils/load-sprite';\nimport { extend } from './utils/objects';\nimport { getPercentage, replaceAll, toCamelCase, toTitleCase } from './utils/strings';\nimport { formatTime, getHours } from './utils/time';\n\n// TODO: Don't export a massive object - break down and create class\nconst controls = {\n  // Get icon URL\n  getIconUrl() {\n    const url = new URL(this.config.iconUrl, window.location);\n    const cors = url.host !== window.location.host || (browser.isIE && !window.svg4everybody);\n\n    return {\n      url: this.config.iconUrl,\n      cors,\n    };\n  },\n\n  // Find the UI controls\n  findElements() {\n    try {\n      this.elements.controls = getElement.call(this, this.config.selectors.controls.wrapper);\n\n      // Buttons\n      this.elements.buttons = {\n        play: getElements.call(this, this.config.selectors.buttons.play),\n        pause: getElement.call(this, this.config.selectors.buttons.pause),\n        restart: getElement.call(this, this.config.selectors.buttons.restart),\n        rewind: getElement.call(this, this.config.selectors.buttons.rewind),\n        fastForward: getElement.call(this, this.config.selectors.buttons.fastForward),\n        mute: getElement.call(this, this.config.selectors.buttons.mute),\n        pip: getElement.call(this, this.config.selectors.buttons.pip),\n        airplay: getElement.call(this, this.config.selectors.buttons.airplay),\n        settings: getElement.call(this, this.config.selectors.buttons.settings),\n        captions: getElement.call(this, this.config.selectors.buttons.captions),\n        fullscreen: getElement.call(this, this.config.selectors.buttons.fullscreen),\n      };\n\n      // Progress\n      this.elements.progress = getElement.call(this, this.config.selectors.progress);\n\n      // Inputs\n      this.elements.inputs = {\n        seek: getElement.call(this, this.config.selectors.inputs.seek),\n        volume: getElement.call(this, this.config.selectors.inputs.volume),\n      };\n\n      // Display\n      this.elements.display = {\n        buffer: getElement.call(this, this.config.selectors.display.buffer),\n        currentTime: getElement.call(this, this.config.selectors.display.currentTime),\n        duration: getElement.call(this, this.config.selectors.display.duration),\n      };\n\n      // Seek tooltip\n      if (is.element(this.elements.progress)) {\n        this.elements.display.seekTooltip = this.elements.progress.querySelector(`.${this.config.classNames.tooltip}`);\n      }\n\n      return true;\n    } catch (error) {\n      // Log it\n      this.debug.warn('It looks like there is a problem with your custom controls HTML', error);\n\n      // Restore native video controls\n      this.toggleNativeControls(true);\n\n      return false;\n    }\n  },\n\n  // Create <svg> icon\n  createIcon(type, attributes) {\n    const namespace = 'http://www.w3.org/2000/svg';\n    const iconUrl = controls.getIconUrl.call(this);\n    const iconPath = `${!iconUrl.cors ? iconUrl.url : ''}#${this.config.iconPrefix}`;\n    // Create <svg>\n    const icon = document.createElementNS(namespace, 'svg');\n    setAttributes(\n      icon,\n      extend(attributes, {\n        'aria-hidden': 'true',\n        focusable: 'false',\n      }),\n    );\n\n    // Create the <use> to reference sprite\n    const use = document.createElementNS(namespace, 'use');\n    const path = `${iconPath}-${type}`;\n\n    // Set `href` attributes\n    // https://github.com/sampotts/WassPlayer/issues/460\n    // https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/xlink:href\n    if ('href' in use) {\n      use.setAttributeNS('http://www.w3.org/1999/xlink', 'href', path);\n    }\n\n    // Always set the older attribute even though it's \"deprecated\" (it'll be around for ages)\n    use.setAttributeNS('http://www.w3.org/1999/xlink', 'xlink:href', path);\n\n    // Add <use> to <svg>\n    icon.appendChild(use);\n\n    return icon;\n  },\n\n  // Create hidden text label\n  createLabel(key, attr = {}) {\n    const text = i18n.get(key, this.config);\n    const attributes = { ...attr, class: [attr.class, this.config.classNames.hidden].filter(Boolean).join(' ') };\n\n    return createElement('span', attributes, text);\n  },\n\n  // Create a badge\n  createBadge(text) {\n    if (is.empty(text)) {\n      return null;\n    }\n\n    const badge = createElement('span', {\n      class: this.config.classNames.menu.value,\n    });\n\n    badge.appendChild(\n      createElement(\n        'span',\n        {\n          class: this.config.classNames.menu.badge,\n        },\n        text,\n      ),\n    );\n\n    return badge;\n  },\n\n  // Create a <button>\n  createButton(buttonType, attr) {\n    const attributes = extend({}, attr);\n    let type = toCamelCase(buttonType);\n\n    const props = {\n      element: 'button',\n      toggle: false,\n      label: null,\n      icon: null,\n      labelPressed: null,\n      iconPressed: null,\n    };\n\n    ['element', 'icon', 'label'].forEach(key => {\n      if (Object.keys(attributes).includes(key)) {\n        props[key] = attributes[key];\n        delete attributes[key];\n      }\n    });\n\n    // Default to 'button' type to prevent form submission\n    if (props.element === 'button' && !Object.keys(attributes).includes('type')) {\n      attributes.type = 'button';\n    }\n\n    // Set class name\n    if (Object.keys(attributes).includes('class')) {\n      if (!attributes.class.split(' ').some(c => c === this.config.classNames.control)) {\n        extend(attributes, {\n          class: `${attributes.class} ${this.config.classNames.control}`,\n        });\n      }\n    } else {\n      attributes.class = this.config.classNames.control;\n    }\n\n    // Large play button\n    switch (buttonType) {\n      case 'play':\n        props.toggle = true;\n        props.label = 'play';\n        props.labelPressed = 'pause';\n        props.icon = 'play';\n        props.iconPressed = 'pause';\n        break;\n\n      case 'mute':\n        props.toggle = true;\n        props.label = 'mute';\n        props.labelPressed = 'unmute';\n        props.icon = 'volume';\n        props.iconPressed = 'muted';\n        break;\n\n      case 'captions':\n        props.toggle = true;\n        props.label = 'enableCaptions';\n        props.labelPressed = 'disableCaptions';\n        props.icon = 'captions-off';\n        props.iconPressed = 'captions-on';\n        break;\n\n      case 'fullscreen':\n        props.toggle = true;\n        props.label = 'enterFullscreen';\n        props.labelPressed = 'exitFullscreen';\n        props.icon = 'enter-fullscreen';\n        props.iconPressed = 'exit-fullscreen';\n        break;\n\n      case 'play-large':\n        attributes.class += ` ${this.config.classNames.control}--overlaid`;\n        type = 'play';\n        props.label = 'play';\n        props.icon = 'play';\n        break;\n\n      default:\n        if (is.empty(props.label)) {\n          props.label = type;\n        }\n        if (is.empty(props.icon)) {\n          props.icon = buttonType;\n        }\n    }\n\n    const button = createElement(props.element);\n\n    // Setup toggle icon and labels\n    if (props.toggle) {\n      // Icon\n      button.appendChild(\n        controls.createIcon.call(this, props.iconPressed, {\n          class: 'icon--pressed',\n        }),\n      );\n      button.appendChild(\n        controls.createIcon.call(this, props.icon, {\n          class: 'icon--not-pressed',\n        }),\n      );\n\n      // Label/Tooltip\n      button.appendChild(\n        controls.createLabel.call(this, props.labelPressed, {\n          class: 'label--pressed',\n        }),\n      );\n      button.appendChild(\n        controls.createLabel.call(this, props.label, {\n          class: 'label--not-pressed',\n        }),\n      );\n    } else {\n      button.appendChild(controls.createIcon.call(this, props.icon));\n      button.appendChild(controls.createLabel.call(this, props.label));\n    }\n\n    // Merge and set attributes\n    extend(attributes, getAttributesFromSelector(this.config.selectors.buttons[type], attributes));\n    setAttributes(button, attributes);\n\n    // We have multiple play buttons\n    if (type === 'play') {\n      if (!is.array(this.elements.buttons[type])) {\n        this.elements.buttons[type] = [];\n      }\n\n      this.elements.buttons[type].push(button);\n    } else {\n      this.elements.buttons[type] = button;\n    }\n\n    return button;\n  },\n\n  // Create an <input type='range'>\n  createRange(type, attributes) {\n    // Seek input\n    const input = createElement(\n      'input',\n      extend(\n        getAttributesFromSelector(this.config.selectors.inputs[type]),\n        {\n          type: 'range',\n          min: 0,\n          max: 100,\n          step: 0.01,\n          value: 0,\n          autocomplete: 'off',\n          // A11y fixes for https://github.com/sampotts/WassPlayer/issues/905\n          role: 'slider',\n          'aria-label': i18n.get(type, this.config),\n          'aria-valuemin': 0,\n          'aria-valuemax': 100,\n          'aria-valuenow': 0,\n        },\n        attributes,\n      ),\n    );\n\n    this.elements.inputs[type] = input;\n\n    // Set the fill for webkit now\n    controls.updateRangeFill.call(this, input);\n\n    // Improve support on touch devices\n    RangeTouch.setup(input);\n\n    return input;\n  },\n\n  // Create a <progress>\n  createProgress(type, attributes) {\n    const progress = createElement(\n      'progress',\n      extend(\n        getAttributesFromSelector(this.config.selectors.display[type]),\n        {\n          min: 0,\n          max: 100,\n          value: 0,\n          role: 'progressbar',\n          'aria-hidden': true,\n        },\n        attributes,\n      ),\n    );\n\n    // Create the label inside\n    if (type !== 'volume') {\n      progress.appendChild(createElement('span', null, '0'));\n\n      const suffixKey = {\n        played: 'played',\n        buffer: 'buffered',\n      }[type];\n      const suffix = suffixKey ? i18n.get(suffixKey, this.config) : '';\n\n      progress.innerText = `% ${suffix.toLowerCase()}`;\n    }\n\n    this.elements.display[type] = progress;\n\n    return progress;\n  },\n\n  // Create time display\n  createTime(type, attrs) {\n    const attributes = getAttributesFromSelector(this.config.selectors.display[type], attrs);\n\n    const container = createElement(\n      'div',\n      extend(attributes, {\n        class: `${attributes.class ? attributes.class : ''} ${this.config.classNames.display.time} `.trim(),\n        'aria-label': i18n.get(type, this.config),\n      }),\n      '00:00',\n    );\n\n    // Reference for updates\n    this.elements.display[type] = container;\n\n    return container;\n  },\n\n  // Bind keyboard shortcuts for a menu item\n  // We have to bind to keyup otherwise Firefox triggers a click when a keydown event handler shifts focus\n  // https://bugzilla.mozilla.org/show_bug.cgi?id=1220143\n  bindMenuItemShortcuts(menuItem, type) {\n    // Navigate through menus via arrow keys and space\n    on.call(\n      this,\n      menuItem,\n      'keydown keyup',\n      event => {\n        // We only care about space and ⬆️ ⬇️️ ➡️\n        if (![32, 38, 39, 40].includes(event.which)) {\n          return;\n        }\n\n        // Prevent play / seek\n        event.preventDefault();\n        event.stopPropagation();\n\n        // We're just here to prevent the keydown bubbling\n        if (event.type === 'keydown') {\n          return;\n        }\n\n        const isRadioButton = matches(menuItem, '[role=\"menuitemradio\"]');\n\n        // Show the respective menu\n        if (!isRadioButton && [32, 39].includes(event.which)) {\n          controls.showMenuPanel.call(this, type, true);\n        } else {\n          let target;\n\n          if (event.which !== 32) {\n            if (event.which === 40 || (isRadioButton && event.which === 39)) {\n              target = menuItem.nextElementSibling;\n\n              if (!is.element(target)) {\n                target = menuItem.parentNode.firstElementChild;\n              }\n            } else {\n              target = menuItem.previousElementSibling;\n\n              if (!is.element(target)) {\n                target = menuItem.parentNode.lastElementChild;\n              }\n            }\n\n            setFocus.call(this, target, true);\n          }\n        }\n      },\n      false,\n    );\n\n    // Enter will fire a `click` event but we still need to manage focus\n    // So we bind to keyup which fires after and set focus here\n    on.call(this, menuItem, 'keyup', event => {\n      if (event.which !== 13) {\n        return;\n      }\n\n      controls.focusFirstMenuItem.call(this, null, true);\n    });\n  },\n\n  // Create a settings menu item\n  createMenuItem({ value, list, type, title, badge = null, checked = false }) {\n    const attributes = getAttributesFromSelector(this.config.selectors.inputs[type]);\n\n    const menuItem = createElement(\n      'button',\n      extend(attributes, {\n        type: 'button',\n        role: 'menuitemradio',\n        class: `${this.config.classNames.control} ${attributes.class ? attributes.class : ''}`.trim(),\n        'aria-checked': checked,\n        value,\n      }),\n    );\n\n    const flex = createElement('span');\n\n    // We have to set as HTML incase of special characters\n    flex.innerHTML = title;\n\n    if (is.element(badge)) {\n      flex.appendChild(badge);\n    }\n\n    menuItem.appendChild(flex);\n\n    // Replicate radio button behaviour\n    Object.defineProperty(menuItem, 'checked', {\n      enumerable: true,\n      get() {\n        return menuItem.getAttribute('aria-checked') === 'true';\n      },\n      set(check) {\n        // Ensure exclusivity\n        if (check) {\n          Array.from(menuItem.parentNode.children)\n            .filter(node => matches(node, '[role=\"menuitemradio\"]'))\n            .forEach(node => node.setAttribute('aria-checked', 'false'));\n        }\n\n        menuItem.setAttribute('aria-checked', check ? 'true' : 'false');\n      },\n    });\n\n    this.listeners.bind(\n      menuItem,\n      'click keyup',\n      event => {\n        if (is.keyboardEvent(event) && event.which !== 32) {\n          return;\n        }\n\n        event.preventDefault();\n        event.stopPropagation();\n\n        menuItem.checked = true;\n\n        switch (type) {\n          case 'language':\n            this.currentTrack = Number(value);\n            break;\n\n          case 'quality':\n            this.quality = value;\n            break;\n\n          case 'speed':\n            this.speed = parseFloat(value);\n            break;\n\n          default:\n            break;\n        }\n\n        controls.showMenuPanel.call(this, 'home', is.keyboardEvent(event));\n      },\n      type,\n      false,\n    );\n\n    controls.bindMenuItemShortcuts.call(this, menuItem, type);\n\n    list.appendChild(menuItem);\n  },\n\n  // Format a time for display\n  formatTime(time = 0, inverted = false) {\n    // Bail if the value isn't a number\n    if (!is.number(time)) {\n      return time;\n    }\n\n    // Always display hours if duration is over an hour\n    const forceHours = getHours(this.duration) > 0;\n\n    return formatTime(time, forceHours, inverted);\n  },\n\n  // Update the displayed time\n  updateTimeDisplay(target = null, time = 0, inverted = false) {\n    // Bail if there's no element to display or the value isn't a number\n    if (!is.element(target) || !is.number(time)) {\n      return;\n    }\n\n    // eslint-disable-next-line no-param-reassign\n    target.innerText = controls.formatTime(time, inverted);\n  },\n\n  // Update volume UI and storage\n  updateVolume() {\n    if (!this.supported.ui) {\n      return;\n    }\n\n    // Update range\n    if (is.element(this.elements.inputs.volume)) {\n      controls.setRange.call(this, this.elements.inputs.volume, this.muted ? 0 : this.volume);\n    }\n\n    // Update mute state\n    if (is.element(this.elements.buttons.mute)) {\n      this.elements.buttons.mute.pressed = this.muted || this.volume === 0;\n    }\n  },\n\n  // Update seek value and lower fill\n  setRange(target, value = 0) {\n    if (!is.element(target)) {\n      return;\n    }\n\n    // eslint-disable-next-line\n    target.value = value;\n\n    // Webkit range fill\n    controls.updateRangeFill.call(this, target);\n  },\n\n  // Update <progress> elements\n  updateProgress(event) {\n    if (!this.supported.ui || !is.event(event)) {\n      return;\n    }\n\n    let value = 0;\n\n    const setProgress = (target, input) => {\n      const val = is.number(input) ? input : 0;\n      const progress = is.element(target) ? target : this.elements.display.buffer;\n\n      // Update value and label\n      if (is.element(progress)) {\n        progress.value = val;\n\n        // Update text label inside\n        const label = progress.getElementsByTagName('span')[0];\n        if (is.element(label)) {\n          label.childNodes[0].nodeValue = val;\n        }\n      }\n    };\n\n    if (event) {\n      switch (event.type) {\n        // Video playing\n        case 'timeupdate':\n        case 'seeking':\n        case 'seeked':\n          value = getPercentage(this.currentTime, this.duration);\n\n          // Set seek range value only if it's a 'natural' time event\n          if (event.type === 'timeupdate') {\n            controls.setRange.call(this, this.elements.inputs.seek, value);\n          }\n\n          break;\n\n        // Check buffer status\n        case 'playing':\n        case 'progress':\n          setProgress(this.elements.display.buffer, this.buffered * 100);\n\n          break;\n\n        default:\n          break;\n      }\n    }\n  },\n\n  // Webkit polyfill for lower fill range\n  updateRangeFill(target) {\n    // Get range from event if event passed\n    const range = is.event(target) ? target.target : target;\n\n    // Needs to be a valid <input type='range'>\n    if (!is.element(range) || range.getAttribute('type') !== 'range') {\n      return;\n    }\n\n    // Set aria values for https://github.com/sampotts/WassPlayer/issues/905\n    if (matches(range, this.config.selectors.inputs.seek)) {\n      range.setAttribute('aria-valuenow', this.currentTime);\n      const currentTime = controls.formatTime(this.currentTime);\n      const duration = controls.formatTime(this.duration);\n      const format = i18n.get('seekLabel', this.config);\n      range.setAttribute(\n        'aria-valuetext',\n        format.replace('{currentTime}', currentTime).replace('{duration}', duration),\n      );\n    } else if (matches(range, this.config.selectors.inputs.volume)) {\n      const percent = range.value * 100;\n      range.setAttribute('aria-valuenow', percent);\n      range.setAttribute('aria-valuetext', `${percent.toFixed(1)}%`);\n    } else {\n      range.setAttribute('aria-valuenow', range.value);\n    }\n\n    // WebKit only\n    if (!browser.isWebkit) {\n      return;\n    }\n\n    // Set CSS custom property\n    range.style.setProperty('--value', `${(range.value / range.max) * 100}%`);\n  },\n\n  // Update hover tooltip for seeking\n  updateSeekTooltip(event) {\n    // Bail if setting not true\n    if (\n      !this.config.tooltips.seek ||\n      !is.element(this.elements.inputs.seek) ||\n      !is.element(this.elements.display.seekTooltip) ||\n      this.duration === 0\n    ) {\n      return;\n    }\n\n    const visible = `${this.config.classNames.tooltip}--visible`;\n    const toggle = show => toggleClass(this.elements.display.seekTooltip, visible, show);\n\n    // Hide on touch\n    if (this.touch) {\n      toggle(false);\n      return;\n    }\n\n    // Determine percentage, if already visible\n    let percent = 0;\n    const clientRect = this.elements.progress.getBoundingClientRect();\n\n    if (is.event(event)) {\n      percent = (100 / clientRect.width) * (event.pageX - clientRect.left);\n    } else if (hasClass(this.elements.display.seekTooltip, visible)) {\n      percent = parseFloat(this.elements.display.seekTooltip.style.left, 10);\n    } else {\n      return;\n    }\n\n    // Set bounds\n    if (percent < 0) {\n      percent = 0;\n    } else if (percent > 100) {\n      percent = 100;\n    }\n\n    // Display the time a click would seek to\n    controls.updateTimeDisplay.call(this, this.elements.display.seekTooltip, (this.duration / 100) * percent);\n\n    // Set position\n    this.elements.display.seekTooltip.style.left = `${percent}%`;\n\n    // Show/hide the tooltip\n    // If the event is a moues in/out and percentage is inside bounds\n    if (is.event(event) && ['mouseenter', 'mouseleave'].includes(event.type)) {\n      toggle(event.type === 'mouseenter');\n    }\n  },\n\n  // Handle time change event\n  timeUpdate(event) {\n    // Only invert if only one time element is displayed and used for both duration and currentTime\n    const invert = !is.element(this.elements.display.duration) && this.config.invertTime;\n\n    // Duration\n    controls.updateTimeDisplay.call(\n      this,\n      this.elements.display.currentTime,\n      invert ? this.duration - this.currentTime : this.currentTime,\n      invert,\n    );\n\n    // Ignore updates while seeking\n    if (event && event.type === 'timeupdate' && this.media.seeking) {\n      return;\n    }\n\n    // Playing progress\n    controls.updateProgress.call(this, event);\n  },\n\n  // Show the duration on metadataloaded or durationchange events\n  durationUpdate() {\n    // Bail if no UI or durationchange event triggered after playing/seek when invertTime is false\n    if (!this.supported.ui || (!this.config.invertTime && this.currentTime)) {\n      return;\n    }\n\n    // If duration is the 2**32 (shaka), Infinity (HLS), DASH-IF (Number.MAX_SAFE_INTEGER || Number.MAX_VALUE) indicating live we hide the currentTime and progressbar.\n    // https://github.com/video-dev/hls.js/blob/5820d29d3c4c8a46e8b75f1e3afa3e68c1a9a2db/src/controller/buffer-controller.js#L415\n    // https://github.com/google/shaka-player/blob/4d889054631f4e1cf0fbd80ddd2b71887c02e232/lib/media/streaming_engine.js#L1062\n    // https://github.com/Dash-Industry-Forum/dash.js/blob/69859f51b969645b234666800d4cb596d89c602d/src/dash/models/DashManifestModel.js#L338\n    if (this.duration >= 2 ** 32) {\n      toggleHidden(this.elements.display.currentTime, true);\n      toggleHidden(this.elements.progress, true);\n      return;\n    }\n\n    // Update ARIA values\n    if (is.element(this.elements.inputs.seek)) {\n      this.elements.inputs.seek.setAttribute('aria-valuemax', this.duration);\n    }\n\n    // If there's a spot to display duration\n    const hasDuration = is.element(this.elements.display.duration);\n\n    // If there's only one time display, display duration there\n    if (!hasDuration && this.config.displayDuration && this.paused) {\n      controls.updateTimeDisplay.call(this, this.elements.display.currentTime, this.duration);\n    }\n\n    // If there's a duration element, update content\n    if (hasDuration) {\n      controls.updateTimeDisplay.call(this, this.elements.display.duration, this.duration);\n    }\n\n    // Update the tooltip (if visible)\n    controls.updateSeekTooltip.call(this);\n  },\n\n  // Hide/show a tab\n  toggleMenuButton(setting, toggle) {\n    toggleHidden(this.elements.settings.buttons[setting], !toggle);\n  },\n\n  // Update the selected setting\n  updateSetting(setting, container, input) {\n    const pane = this.elements.settings.panels[setting];\n    let value = null;\n    let list = container;\n\n    if (setting === 'captions') {\n      value = this.currentTrack;\n    } else {\n      value = !is.empty(input) ? input : this[setting];\n\n      // Get default\n      if (is.empty(value)) {\n        value = this.config[setting].default;\n      }\n\n      // Unsupported value\n      if (!is.empty(this.options[setting]) && !this.options[setting].includes(value)) {\n        this.debug.warn(`Unsupported value of '${value}' for ${setting}`);\n        return;\n      }\n\n      // Disabled value\n      if (!this.config[setting].options.includes(value)) {\n        this.debug.warn(`Disabled value of '${value}' for ${setting}`);\n        return;\n      }\n    }\n\n    // Get the list if we need to\n    if (!is.element(list)) {\n      list = pane && pane.querySelector('[role=\"menu\"]');\n    }\n\n    // If there's no list it means it's not been rendered...\n    if (!is.element(list)) {\n      return;\n    }\n\n    // Update the label\n    const label = this.elements.settings.buttons[setting].querySelector(`.${this.config.classNames.menu.value}`);\n    label.innerHTML = controls.getLabel.call(this, setting, value);\n\n    // Find the radio option and check it\n    const target = list && list.querySelector(`[value=\"${value}\"]`);\n\n    if (is.element(target)) {\n      target.checked = true;\n    }\n  },\n\n  // Translate a value into a nice label\n  getLabel(setting, value) {\n    switch (setting) {\n      case 'speed':\n        return value === 1 ? i18n.get('normal', this.config) : `${value}&times;`;\n\n      case 'quality':\n        if (is.number(value)) {\n          const label = i18n.get(`qualityLabel.${value}`, this.config);\n\n          if (!label.length) {\n            return `${value}p`;\n          }\n\n          return label;\n        }\n\n        return toTitleCase(value);\n\n      case 'captions':\n        return captions.getLabel.call(this);\n\n      default:\n        return null;\n    }\n  },\n\n  // Set the quality menu\n  setQualityMenu(options) {\n    // Menu required\n    if (!is.element(this.elements.settings.panels.quality)) {\n      return;\n    }\n\n    const type = 'quality';\n    const list = this.elements.settings.panels.quality.querySelector('[role=\"menu\"]');\n\n    // Set options if passed and filter based on uniqueness and config\n    if (is.array(options)) {\n      this.options.quality = dedupe(options).filter(quality => this.config.quality.options.includes(quality));\n    }\n\n    // Toggle the pane and tab\n    const toggle = !is.empty(this.options.quality) && this.options.quality.length > 1;\n    controls.toggleMenuButton.call(this, type, toggle);\n\n    // Empty the menu\n    emptyElement(list);\n\n    // Check if we need to toggle the parent\n    controls.checkMenu.call(this);\n\n    // If we're hiding, nothing more to do\n    if (!toggle) {\n      return;\n    }\n\n    // Get the badge HTML for HD, 4K etc\n    const getBadge = quality => {\n      const label = i18n.get(`qualityBadge.${quality}`, this.config);\n\n      if (!label.length) {\n        return null;\n      }\n\n      return controls.createBadge.call(this, label);\n    };\n\n    // Sort options by the config and then render options\n    this.options.quality\n      .sort((a, b) => {\n        const sorting = this.config.quality.options;\n        return sorting.indexOf(a) > sorting.indexOf(b) ? 1 : -1;\n      })\n      .forEach(quality => {\n        controls.createMenuItem.call(this, {\n          value: quality,\n          list,\n          type,\n          title: controls.getLabel.call(this, 'quality', quality),\n          badge: getBadge(quality),\n        });\n      });\n\n    controls.updateSetting.call(this, type, list);\n  },\n\n  // Set the looping options\n  /* setLoopMenu() {\n        // Menu required\n        if (!is.element(this.elements.settings.panels.loop)) {\n            return;\n        }\n\n        const options = ['start', 'end', 'all', 'reset'];\n        const list = this.elements.settings.panels.loop.querySelector('[role=\"menu\"]');\n\n        // Show the pane and tab\n        toggleHidden(this.elements.settings.buttons.loop, false);\n        toggleHidden(this.elements.settings.panels.loop, false);\n\n        // Toggle the pane and tab\n        const toggle = !is.empty(this.loop.options);\n        controls.toggleMenuButton.call(this, 'loop', toggle);\n\n        // Empty the menu\n        emptyElement(list);\n\n        options.forEach(option => {\n            const item = createElement('li');\n\n            const button = createElement(\n                'button',\n                extend(getAttributesFromSelector(this.config.selectors.buttons.loop), {\n                    type: 'button',\n                    class: this.config.classNames.control,\n                    'data-wassPlayer-loop-action': option,\n                }),\n                i18n.get(option, this.config)\n            );\n\n            if (['start', 'end'].includes(option)) {\n                const badge = controls.createBadge.call(this, '00:00');\n                button.appendChild(badge);\n            }\n\n            item.appendChild(button);\n            list.appendChild(item);\n        });\n    }, */\n\n  // Get current selected caption language\n\n  // Set a list of available captions languages\n  setCaptionsMenu() {\n    // Menu required\n    if (!is.element(this.elements.settings.panels.captions)) {\n      return;\n    }\n\n    const type = 'captions';\n    const list = this.elements.settings.panels.captions.querySelector('[role=\"menu\"]');\n    const tracks = captions.getTracks.call(this);\n    const toggle = Boolean(tracks.length);\n\n    // Toggle the pane and tab\n    controls.toggleMenuButton.call(this, type, toggle);\n\n    // Empty the menu\n    emptyElement(list);\n\n    // Check if we need to toggle the parent\n    controls.checkMenu.call(this);\n\n    // If there's no captions, bail\n    if (!toggle) {\n      return;\n    }\n\n    // Generate options data\n    const options = tracks.map((track, value) => ({\n      value,\n      checked: this.captions.toggled && this.currentTrack === value,\n      title: captions.getLabel.call(this, track),\n      badge: track.language && controls.createBadge.call(this, track.language.toUpperCase()),\n      list,\n      type: 'language',\n    }));\n\n    // Add the \"Disabled\" option to turn off captions\n    options.unshift({\n      value: -1,\n      checked: !this.captions.toggled,\n      title: i18n.get('disabled', this.config),\n      list,\n      type: 'language',\n    });\n\n    // Generate options\n    options.forEach(controls.createMenuItem.bind(this));\n\n    controls.updateSetting.call(this, type, list);\n  },\n\n  // Set a list of available captions languages\n  setSpeedMenu() {\n    // Menu required\n    if (!is.element(this.elements.settings.panels.speed)) {\n      return;\n    }\n\n    const type = 'speed';\n    const list = this.elements.settings.panels.speed.querySelector('[role=\"menu\"]');\n\n    // Filter out invalid speeds\n    this.options.speed = this.options.speed.filter(o => o >= this.minimumSpeed && o <= this.maximumSpeed);\n\n    // Toggle the pane and tab\n    const toggle = !is.empty(this.options.speed) && this.options.speed.length > 1;\n    controls.toggleMenuButton.call(this, type, toggle);\n\n    // Empty the menu\n    emptyElement(list);\n\n    // Check if we need to toggle the parent\n    controls.checkMenu.call(this);\n\n    // If we're hiding, nothing more to do\n    if (!toggle) {\n      return;\n    }\n\n    // Create items\n    this.options.speed.forEach(speed => {\n      controls.createMenuItem.call(this, {\n        value: speed,\n        list,\n        type,\n        title: controls.getLabel.call(this, 'speed', speed),\n      });\n    });\n\n    controls.updateSetting.call(this, type, list);\n  },\n\n  // Check if we need to hide/show the settings menu\n  checkMenu() {\n    const { buttons } = this.elements.settings;\n    const visible = !is.empty(buttons) && Object.values(buttons).some(button => !button.hidden);\n\n    toggleHidden(this.elements.settings.menu, !visible);\n  },\n\n  // Focus the first menu item in a given (or visible) menu\n  focusFirstMenuItem(pane, tabFocus = false) {\n    if (this.elements.settings.popup.hidden) {\n      return;\n    }\n\n    let target = pane;\n\n    if (!is.element(target)) {\n      target = Object.values(this.elements.settings.panels).find(p => !p.hidden);\n    }\n\n    const firstItem = target.querySelector('[role^=\"menuitem\"]');\n\n    setFocus.call(this, firstItem, tabFocus);\n  },\n\n  // Show/hide menu\n  toggleMenu(input) {\n    const { popup } = this.elements.settings;\n    const button = this.elements.buttons.settings;\n\n    // Menu and button are required\n    if (!is.element(popup) || !is.element(button)) {\n      return;\n    }\n\n    // True toggle by default\n    const { hidden } = popup;\n    let show = hidden;\n\n    if (is.boolean(input)) {\n      show = input;\n    } else if (is.keyboardEvent(input) && input.which === 27) {\n      show = false;\n    } else if (is.event(input)) {\n      // If WassPlayer is in a shadowDOM, the event target is set to the component, instead of the\n      // Element in the shadowDOM. The path, if available, is complete.\n      const target = is.function(input.composedPath) ? input.composedPath()[0] : input.target;\n      const isMenuItem = popup.contains(target);\n\n      // If the click was inside the menu or if the click\n      // wasn't the button or menu item and we're trying to\n      // show the menu (a doc click shouldn't show the menu)\n      if (isMenuItem || (!isMenuItem && input.target !== button && show)) {\n        return;\n      }\n    }\n\n    // Set button attributes\n    button.setAttribute('aria-expanded', show);\n\n    // Show the actual popup\n    toggleHidden(popup, !show);\n\n    // Add class hook\n    toggleClass(this.elements.container, this.config.classNames.menu.open, show);\n\n    // Focus the first item if key interaction\n    if (show && is.keyboardEvent(input)) {\n      controls.focusFirstMenuItem.call(this, null, true);\n    } else if (!show && !hidden) {\n      // If closing, re-focus the button\n      setFocus.call(this, button, is.keyboardEvent(input));\n    }\n  },\n\n  // Get the natural size of a menu panel\n  getMenuSize(tab) {\n    const clone = tab.cloneNode(true);\n    clone.style.position = 'absolute';\n    clone.style.opacity = 0;\n    clone.removeAttribute('hidden');\n\n    // Append to parent so we get the \"real\" size\n    tab.parentNode.appendChild(clone);\n\n    // Get the sizes before we remove\n    const width = clone.scrollWidth;\n    const height = clone.scrollHeight;\n\n    // Remove from the DOM\n    removeElement(clone);\n\n    return {\n      width,\n      height,\n    };\n  },\n\n  // Show a panel in the menu\n  showMenuPanel(type = '', tabFocus = false) {\n    const target = this.elements.container.querySelector(`#wassPlayer-settings-${this.id}-${type}`);\n\n    // Nothing to show, bail\n    if (!is.element(target)) {\n      return;\n    }\n\n    // Hide all other panels\n    const container = target.parentNode;\n    const current = Array.from(container.children).find(node => !node.hidden);\n\n    // If we can do fancy animations, we'll animate the height/width\n    if (support.transitions && !support.reducedMotion) {\n      // Set the current width as a base\n      container.style.width = `${current.scrollWidth}px`;\n      container.style.height = `${current.scrollHeight}px`;\n\n      // Get potential sizes\n      const size = controls.getMenuSize.call(this, target);\n\n      // Restore auto height/width\n      const restore = event => {\n        // We're only bothered about height and width on the container\n        if (event.target !== container || !['width', 'height'].includes(event.propertyName)) {\n          return;\n        }\n\n        // Revert back to auto\n        container.style.width = '';\n        container.style.height = '';\n\n        // Only listen once\n        off.call(this, container, transitionEndEvent, restore);\n      };\n\n      // Listen for the transition finishing and restore auto height/width\n      on.call(this, container, transitionEndEvent, restore);\n\n      // Set dimensions to target\n      container.style.width = `${size.width}px`;\n      container.style.height = `${size.height}px`;\n    }\n\n    // Set attributes on current tab\n    toggleHidden(current, true);\n\n    // Set attributes on target\n    toggleHidden(target, false);\n\n    // Focus the first item\n    controls.focusFirstMenuItem.call(this, target, tabFocus);\n  },\n\n  // Set the download URL\n  setDownloadUrl() {\n    const button = this.elements.buttons.download;\n\n    // Bail if no button\n    if (!is.element(button)) {\n      return;\n    }\n\n    // Set attribute\n    button.setAttribute('href', this.download);\n  },\n\n  // Build the default HTML\n  create(data) {\n    const {\n      bindMenuItemShortcuts,\n      createButton,\n      createProgress,\n      createRange,\n      createTime,\n      setQualityMenu,\n      setSpeedMenu,\n      showMenuPanel,\n    } = controls;\n    this.elements.controls = null;\n\n    // Larger overlaid play button\n    if (is.array(this.config.controls) && this.config.controls.includes('play-large')) {\n      this.elements.container.appendChild(createButton.call(this, 'play-large'));\n    }\n\n    // Create the container\n    const container = createElement('div', getAttributesFromSelector(this.config.selectors.controls.wrapper));\n    this.elements.controls = container;\n\n    // Default item attributes\n    const defaultAttributes = { class: 'wassPlayer__controls__item' };\n\n    // Loop through controls in order\n    dedupe(is.array(this.config.controls) ? this.config.controls: []).forEach(control => {\n      // Restart button\n      if (control === 'restart') {\n        container.appendChild(createButton.call(this, 'restart', defaultAttributes));\n      }\n\n      // Rewind button\n      if (control === 'rewind') {\n        container.appendChild(createButton.call(this, 'rewind', defaultAttributes));\n      }\n\n      // Play/Pause button\n      if (control === 'play') {\n        container.appendChild(createButton.call(this, 'play', defaultAttributes));\n      }\n\n      // Fast forward button\n      if (control === 'fast-forward') {\n        container.appendChild(createButton.call(this, 'fast-forward', defaultAttributes));\n      }\n\n      // Progress\n      if (control === 'progress') {\n        const progressContainer = createElement('div', {\n          class: `${defaultAttributes.class} wassPlayer__progress__container`,\n        });\n\n        const progress = createElement('div', getAttributesFromSelector(this.config.selectors.progress));\n\n        // Seek range slider\n        progress.appendChild(\n          createRange.call(this, 'seek', {\n            id: `wassPlayer-seek-${data.id}`,\n          }),\n        );\n\n        // Buffer progress\n        progress.appendChild(createProgress.call(this, 'buffer'));\n\n        // Seek tooltip\n        if (this.config.tooltips.seek) {\n          const tooltip = createElement(\n            'span',\n            {\n              class: this.config.classNames.tooltip,\n            },\n            '00:00',\n          );\n\n          progress.appendChild(tooltip);\n          this.elements.display.seekTooltip = tooltip;\n        }\n\n        this.elements.progress = progress;\n        progressContainer.appendChild(this.elements.progress);\n        container.appendChild(progressContainer);\n      }\n\n      // Media current time display\n      if (control === 'current-time') {\n        container.appendChild(createTime.call(this, 'currentTime', defaultAttributes));\n      }\n\n      // Media duration display\n      if (control === 'duration') {\n        container.appendChild(createTime.call(this, 'duration', defaultAttributes));\n      }\n\n      // Volume controls\n      if (control === 'mute' || control === 'volume') {\n        let { volume } = this.elements;\n\n        // Create the volume container if needed\n        if (!is.element(volume) || !container.contains(volume)) {\n          volume = createElement(\n            'div',\n            extend({}, defaultAttributes, {\n              class: `${defaultAttributes.class} wassPlayer__volume`.trim(),\n            }),\n          );\n\n          this.elements.volume = volume;\n\n          container.appendChild(volume);\n        }\n\n        // Toggle mute button\n        if (control === 'mute') {\n          volume.appendChild(createButton.call(this, 'mute'));\n        }\n\n        // Volume range control\n        // Ignored on iOS as it's handled globally\n        // https://developer.apple.com/library/safari/documentation/AudioVideo/Conceptual/Using_HTML5_Audio_Video/Device-SpecificConsiderations/Device-SpecificConsiderations.html\n        if (control === 'volume' && !browser.isIos) {\n          // Set the attributes\n          const attributes = {\n            max: 1,\n            step: 0.05,\n            value: this.config.volume,\n          };\n\n          // Create the volume range slider\n          volume.appendChild(\n            createRange.call(\n              this,\n              'volume',\n              extend(attributes, {\n                id: `wassPlayer-volume-${data.id}`,\n              }),\n            ),\n          );\n        }\n      }\n\n      // Toggle captions button\n      if (control === 'captions') {\n        container.appendChild(createButton.call(this, 'captions', defaultAttributes));\n      }\n\n      // Settings button / menu\n      if (control === 'settings' && !is.empty(this.config.settings)) {\n        const wrapper = createElement(\n          'div',\n          extend({}, defaultAttributes, {\n            class: `${defaultAttributes.class} wassPlayer__menu`.trim(),\n            hidden: '',\n          }),\n        );\n\n        wrapper.appendChild(\n          createButton.call(this, 'settings', {\n            'aria-haspopup': true,\n            'aria-controls': `wassPlayer-settings-${data.id}`,\n            'aria-expanded': false,\n          }),\n        );\n\n        const popup = createElement('div', {\n          class: 'wassPlayer__menu__container',\n          id: `wassPlayer-settings-${data.id}`,\n          hidden: '',\n        });\n\n        const inner = createElement('div');\n\n        const home = createElement('div', {\n          id: `wassPlayer-settings-${data.id}-home`,\n        });\n\n        // Create the menu\n        const menu = createElement('div', {\n          role: 'menu',\n        });\n\n        home.appendChild(menu);\n        inner.appendChild(home);\n        this.elements.settings.panels.home = home;\n\n        // Build the menu items\n        this.config.settings.forEach(type => {\n          const menuItem = createElement(\n            'button',\n            extend(getAttributesFromSelector(this.config.selectors.buttons.settings), {\n              type: 'button',\n              class: `${this.config.classNames.control} ${this.config.classNames.control}--forward`,\n              role: 'menuitem',\n              'aria-haspopup': true,\n              hidden: '',\n            }),\n          );\n\n          // Bind menu shortcuts for keyboard users\n          bindMenuItemShortcuts.call(this, menuItem, type);\n\n          // Show menu on click\n          on.call(this, menuItem, 'click', () => {\n            showMenuPanel.call(this, type, false);\n          });\n\n          const flex = createElement('span', null, i18n.get(type, this.config));\n\n          const value = createElement('span', {\n            class: this.config.classNames.menu.value,\n          });\n\n          // Speed contains HTML entities\n          value.innerHTML = data[type];\n\n          flex.appendChild(value);\n          menuItem.appendChild(flex);\n          menu.appendChild(menuItem);\n\n          // Build the panes\n          const pane = createElement('div', {\n            id: `wassPlayer-settings-${data.id}-${type}`,\n            hidden: '',\n          });\n\n          // Back button\n          const backButton = createElement('button', {\n            type: 'button',\n            class: `${this.config.classNames.control} ${this.config.classNames.control}--back`,\n          });\n\n          // Visible label\n          backButton.appendChild(\n            createElement(\n              'span',\n              {\n                'aria-hidden': true,\n              },\n              i18n.get(type, this.config),\n            ),\n          );\n\n          // Screen reader label\n          backButton.appendChild(\n            createElement(\n              'span',\n              {\n                class: this.config.classNames.hidden,\n              },\n              i18n.get('menuBack', this.config),\n            ),\n          );\n\n          // Go back via keyboard\n          on.call(\n            this,\n            pane,\n            'keydown',\n            event => {\n              // We only care about <-\n              if (event.which !== 37) {\n                return;\n              }\n\n              // Prevent seek\n              event.preventDefault();\n              event.stopPropagation();\n\n              // Show the respective menu\n              showMenuPanel.call(this, 'home', true);\n            },\n            false,\n          );\n\n          // Go back via button click\n          on.call(this, backButton, 'click', () => {\n            showMenuPanel.call(this, 'home', false);\n          });\n\n          // Add to pane\n          pane.appendChild(backButton);\n\n          // Menu\n          pane.appendChild(\n            createElement('div', {\n              role: 'menu',\n            }),\n          );\n\n          inner.appendChild(pane);\n\n          this.elements.settings.buttons[type] = menuItem;\n          this.elements.settings.panels[type] = pane;\n        });\n\n        popup.appendChild(inner);\n        wrapper.appendChild(popup);\n        container.appendChild(wrapper);\n\n        this.elements.settings.popup = popup;\n        this.elements.settings.menu = wrapper;\n      }\n\n      // Picture in picture button\n      if (control === 'pip' && support.pip) {\n        container.appendChild(createButton.call(this, 'pip', defaultAttributes));\n      }\n\n      // Airplay button\n      if (control === 'airplay' && support.airplay) {\n        container.appendChild(createButton.call(this, 'airplay', defaultAttributes));\n      }\n\n      // Download button\n      if (control === 'download') {\n        const attributes = extend({}, defaultAttributes, {\n          element: 'a',\n          href: this.download,\n          target: '_blank',\n        });\n\n        // Set download attribute for HTML5 only\n        if (this.isHTML5) {\n          attributes.download = '';\n        }\n\n        const { download } = this.config.urls;\n\n        if (!is.url(download) && this.isEmbed) {\n          extend(attributes, {\n            icon: `logo-${this.provider}`,\n            label: this.provider,\n          });\n        }\n\n        container.appendChild(createButton.call(this, 'download', attributes));\n      }\n\n      // Toggle fullscreen button\n      if (control === 'fullscreen') {\n        container.appendChild(createButton.call(this, 'fullscreen', defaultAttributes));\n      }\n    });\n\n    // Set available quality levels\n    if (this.isHTML5) {\n      setQualityMenu.call(this, html5.getQualityOptions.call(this));\n    }\n\n    setSpeedMenu.call(this);\n\n    return container;\n  },\n\n  // Insert controls\n  inject() {\n    // Sprite\n    if (this.config.loadSprite) {\n      const icon = controls.getIconUrl.call(this);\n\n      // Only load external sprite using AJAX\n      if (icon.cors) {\n        loadSprite(icon.url, 'sprite-wassPlayer');\n      }\n    }\n\n    // Create a unique ID\n    this.id = Math.floor(Math.random() * 10000);\n\n    // Null by default\n    let container = null;\n    this.elements.controls = null;\n\n    // Set template properties\n    const props = {\n      id: this.id,\n      seektime: this.config.seekTime,\n      title: this.config.title,\n    };\n    let update = true;\n\n    // If function, run it and use output\n    if (is.function(this.config.controls)) {\n      this.config.controls = this.config.controls.call(this, props);\n    }\n\n    // Convert falsy controls to empty array (primarily for empty strings)\n    if (!this.config.controls) {\n      this.config.controls = [];\n    }\n\n    if (is.element(this.config.controls) || is.string(this.config.controls)) {\n      // HTMLElement or Non-empty string passed as the option\n      container = this.config.controls;\n    } else {\n      // Create controls\n      container = controls.create.call(this, {\n        id: this.id,\n        seektime: this.config.seekTime,\n        speed: this.speed,\n        quality: this.quality,\n        captions: captions.getLabel.call(this),\n        // loop: 'None',\n      });\n      update = false;\n    }\n\n    // Replace props with their value\n    const replace = input => {\n      let result = input;\n\n      Object.entries(props).forEach(([key, value]) => {\n        result = replaceAll(result, `{${key}}`, value);\n      });\n\n      return result;\n    };\n\n    // Update markup\n    if (update) {\n      if (is.string(this.config.controls)) {\n        container = replace(container);\n      }\n    }\n\n    // Controls container\n    let target;\n\n    // Inject to custom location\n    if (is.string(this.config.selectors.controls.container)) {\n      target = document.querySelector(this.config.selectors.controls.container);\n    }\n\n    // Inject into the container by default\n    if (!is.element(target)) {\n      target = this.elements.container;\n    }\n\n    // Inject controls HTML (needs to be before captions, hence \"afterbegin\")\n    const insertMethod = is.element(container) ? 'insertAdjacentElement' : 'insertAdjacentHTML';\n    target[insertMethod]('afterbegin', container);\n\n    // Find the elements if need be\n    if (!is.element(this.elements.controls)) {\n      controls.findElements.call(this);\n    }\n\n    // Add pressed property to buttons\n    if (!is.empty(this.elements.buttons)) {\n      const addProperty = button => {\n        const className = this.config.classNames.controlPressed;\n        Object.defineProperty(button, 'pressed', {\n          enumerable: true,\n          get() {\n            return hasClass(button, className);\n          },\n          set(pressed = false) {\n            toggleClass(button, className, pressed);\n          },\n        });\n      };\n\n      // Toggle classname when pressed property is set\n      Object.values(this.elements.buttons)\n        .filter(Boolean)\n        .forEach(button => {\n          if (is.array(button) || is.nodeList(button)) {\n            Array.from(button)\n              .filter(Boolean)\n              .forEach(addProperty);\n          } else {\n            addProperty(button);\n          }\n        });\n    }\n\n    // Edge sometimes doesn't finish the paint so force a repaint\n    if (browser.isEdge) {\n      repaint(target);\n    }\n\n    // Setup tooltips\n    if (this.config.tooltips.controls) {\n      const { classNames, selectors } = this.config;\n      const selector = `${selectors.controls.wrapper} ${selectors.labels} .${classNames.hidden}`;\n      const labels = getElements.call(this, selector);\n\n      Array.from(labels).forEach(label => {\n        toggleClass(label, this.config.classNames.hidden, false);\n        toggleClass(label, this.config.classNames.tooltip, true);\n      });\n    }\n  },\n};\n\nexport default controls;\n","// ==========================================================================\n// URL utils\n// ==========================================================================\n\nimport is from './is';\n\n/**\n * Parse a string to a URL object\n * @param {String} input - the URL to be parsed\n * @param {Boolean} safe - failsafe parsing\n */\nexport function parseUrl(input, safe = true) {\n  let url = input;\n\n  if (safe) {\n    const parser = document.createElement('a');\n    parser.href = url;\n    url = parser.href;\n  }\n\n  try {\n    return new URL(url);\n  } catch (e) {\n    return null;\n  }\n}\n\n// Convert object to URLSearchParams\nexport function buildUrlParams(input) {\n  const params = new URLSearchParams();\n\n  if (is.object(input)) {\n    Object.entries(input).forEach(([key, value]) => {\n      params.set(key, value);\n    });\n  }\n\n  return params;\n}\n","// ==========================================================================\n// WassPlayer Captions\n// ==========================================================================\n\n// eslint-disable-next-line import/no-cycle\nimport controls from './controls';\nimport support from './support';\nimport { dedupe } from './utils/arrays';\nimport browser from './utils/browser';\nimport {\n  createElement,\n  emptyElement,\n  getAttributesFromSelector,\n  insertAfter,\n  removeElement,\n  toggleClass,\n} from './utils/elements';\nimport { on, triggerEvent } from './utils/events';\nimport fetch from './utils/fetch';\nimport i18n from './utils/i18n';\nimport is from './utils/is';\nimport { getHTML } from './utils/strings';\nimport { parseUrl } from './utils/urls';\n\nconst captions = {\n  // Setup captions\n  setup() {\n    // Requires UI support\n    if (!this.supported.ui) {\n      return;\n    }\n\n    // Only Vimeo and HTML5 video supported at this point\n    if (!this.isVideo || this.isYouTube || (this.isHTML5 && !support.textTracks)) {\n      // Clear menu and hide\n      if (\n        is.array(this.config.controls) &&\n        this.config.controls.includes('settings') &&\n        this.config.settings.includes('captions')\n      ) {\n        controls.setCaptionsMenu.call(this);\n      }\n\n      return;\n    }\n\n    // Inject the container\n    if (!is.element(this.elements.captions)) {\n      this.elements.captions = createElement('div', getAttributesFromSelector(this.config.selectors.captions));\n\n      insertAfter(this.elements.captions, this.elements.wrapper);\n    }\n\n    // Fix IE captions if CORS is used\n    // Fetch captions and inject as blobs instead (data URIs not supported!)\n    if (browser.isIE && window.URL) {\n      const elements = this.media.querySelectorAll('track');\n\n      Array.from(elements).forEach(track => {\n        const src = track.getAttribute('src');\n        const url = parseUrl(src);\n\n        if (\n          url !== null &&\n          url.hostname !== window.location.href.hostname &&\n          ['http:', 'https:'].includes(url.protocol)\n        ) {\n          fetch(src, 'blob')\n            .then(blob => {\n              track.setAttribute('src', window.URL.createObjectURL(blob));\n            })\n            .catch(() => {\n              removeElement(track);\n            });\n        }\n      });\n    }\n\n    const browserLanguages = navigator.languages || [navigator.language || navigator.userLanguage || 'en'];\n    const languages = dedupe(browserLanguages.map(language => language.split('-')[0]));\n    let language = (this.storage.get('language') || this.config.captions.language || 'auto').toLowerCase();\n\n    // Use first browser language when language is 'auto'\n    if (language === 'auto') {\n      [language] = languages;\n    }\n\n    let active = this.storage.get('captions');\n    if (!is.boolean(active)) {\n      ({ active } = this.config.captions);\n    }\n\n    Object.assign(this.captions, {\n      toggled: false,\n      active,\n      language,\n      languages,\n    });\n\n    // Watch changes to textTracks and update captions menu\n    if (this.isHTML5) {\n      const trackEvents = this.config.captions.update ? 'addtrack removetrack' : 'removetrack';\n      on.call(this, this.media.textTracks, trackEvents, captions.update.bind(this));\n    }\n\n    // Update available languages in list next tick (the event must not be triggered before the listeners)\n    setTimeout(captions.update.bind(this), 0);\n  },\n\n  // Update available language options in settings based on tracks\n  update() {\n    const tracks = captions.getTracks.call(this, true);\n    // Get the wanted language\n    const { active, language, meta, currentTrackNode } = this.captions;\n    const languageExists = Boolean(tracks.find(track => track.language === language));\n\n    // Handle tracks (add event listener and \"pseudo\"-default)\n    if (this.isHTML5 && this.isVideo) {\n      tracks\n        .filter(track => !meta.get(track))\n        .forEach(track => {\n          this.debug.log('Track added', track);\n\n          // Attempt to store if the original dom element was \"default\"\n          meta.set(track, {\n            default: track.mode === 'showing',\n          });\n\n          // eslint-disable-next-line no-param-reassign\n          if (track.mode === 'showing') {\n            // eslint-disable-next-line no-param-reassign\n            track.mode = 'hidden';\n          }\n\n          // Add event listener for cue changes\n          on.call(this, track, 'cuechange', () => captions.updateCues.call(this));\n        });\n    }\n\n    // Update language first time it matches, or if the previous matching track was removed\n    if ((languageExists && this.language !== language) || !tracks.includes(currentTrackNode)) {\n      captions.setLanguage.call(this, language);\n      captions.toggle.call(this, active && languageExists);\n    }\n\n    // Enable or disable captions based on track length\n    toggleClass(this.elements.container, this.config.classNames.captions.enabled, !is.empty(tracks));\n\n    // Update available languages in list\n    if (\n      is.array(this.config.controls) &&\n      this.config.controls.includes('settings') &&\n      this.config.settings.includes('captions')\n    ) {\n      controls.setCaptionsMenu.call(this);\n    }\n  },\n\n  // Toggle captions display\n  // Used internally for the toggleCaptions method, with the passive option forced to false\n  toggle(input, passive = true) {\n    // If there's no full support\n    if (!this.supported.ui) {\n      return;\n    }\n\n    const { toggled } = this.captions; // Current state\n    const activeClass = this.config.classNames.captions.active;\n    // Get the next state\n    // If the method is called without parameter, toggle based on current value\n    const active = is.nullOrUndefined(input) ? !toggled : input;\n\n    // Update state and trigger event\n    if (active !== toggled) {\n      // When passive, don't override user preferences\n      if (!passive) {\n        this.captions.active = active;\n        this.storage.set({ captions: active });\n      }\n\n      // Force language if the call isn't passive and there is no matching language to toggle to\n      if (!this.language && active && !passive) {\n        const tracks = captions.getTracks.call(this);\n        const track = captions.findTrack.call(this, [this.captions.language, ...this.captions.languages], true);\n\n        // Override user preferences to avoid switching languages if a matching track is added\n        this.captions.language = track.language;\n\n        // Set caption, but don't store in localStorage as user preference\n        captions.set.call(this, tracks.indexOf(track));\n        return;\n      }\n\n      // Toggle button if it's enabled\n      if (this.elements.buttons.captions) {\n        this.elements.buttons.captions.pressed = active;\n      }\n\n      // Add class hook\n      toggleClass(this.elements.container, activeClass, active);\n\n      this.captions.toggled = active;\n\n      // Update settings menu\n      controls.updateSetting.call(this, 'captions');\n\n      // Trigger event (not used internally)\n      triggerEvent.call(this, this.media, active ? 'captionsenabled' : 'captionsdisabled');\n    }\n\n    // on the active track - forcing the browser to download it\n    setTimeout(() => {\n      if (active && this.captions.toggled) {\n        this.captions.currentTrackNode.mode = 'hidden';\n      }\n    });\n  },\n\n  // Set captions by track index\n  // Used internally for the currentTrack setter with the passive option forced to false\n  set(index, passive = true) {\n    const tracks = captions.getTracks.call(this);\n\n    // Disable captions if setting to -1\n    if (index === -1) {\n      captions.toggle.call(this, false, passive);\n      return;\n    }\n\n    if (!is.number(index)) {\n      this.debug.warn('Invalid caption argument', index);\n      return;\n    }\n\n    if (!(index in tracks)) {\n      this.debug.warn('Track not found', index);\n      return;\n    }\n\n    if (this.captions.currentTrack !== index) {\n      this.captions.currentTrack = index;\n      const track = tracks[index];\n      const { language } = track || {};\n\n      // Store reference to node for invalidation on remove\n      this.captions.currentTrackNode = track;\n\n      // Update settings menu\n      controls.updateSetting.call(this, 'captions');\n\n      // When passive, don't override user preferences\n      if (!passive) {\n        this.captions.language = language;\n        this.storage.set({ language });\n      }\n\n      // Handle Vimeo captions\n      if (this.isVimeo) {\n        this.embed.enableTextTrack(language);\n      }\n\n      // Trigger event\n      triggerEvent.call(this, this.media, 'languagechange');\n    }\n\n    // Show captions\n    captions.toggle.call(this, true, passive);\n\n    if (this.isHTML5 && this.isVideo) {\n      // If we change the active track while a cue is already displayed we need to update it\n      captions.updateCues.call(this);\n    }\n  },\n\n  // Set captions by language\n  // Used internally for the language setter with the passive option forced to false\n  setLanguage(input, passive = true) {\n    if (!is.string(input)) {\n      this.debug.warn('Invalid language argument', input);\n      return;\n    }\n    // Normalize\n    const language = input.toLowerCase();\n    this.captions.language = language;\n\n    // Set currentTrack\n    const tracks = captions.getTracks.call(this);\n    const track = captions.findTrack.call(this, [language]);\n    captions.set.call(this, tracks.indexOf(track), passive);\n  },\n\n  // Get current valid caption tracks\n  // If update is false it will also ignore tracks without metadata\n  // This is used to \"freeze\" the language options when captions.update is false\n  getTracks(update = false) {\n    // Handle media or textTracks missing or null\n    const tracks = Array.from((this.media || {}).textTracks || []);\n    // For HTML5, use cache instead of current tracks when it exists (if captions.update is false)\n    // Filter out removed tracks and tracks that aren't captions/subtitles (for example metadata)\n    return tracks\n      .filter(track => !this.isHTML5 || update || this.captions.meta.has(track))\n      .filter(track => ['captions', 'subtitles'].includes(track.kind));\n  },\n\n  // Match tracks based on languages and get the first\n  findTrack(languages, force = false) {\n    const tracks = captions.getTracks.call(this);\n    const sortIsDefault = track => Number((this.captions.meta.get(track) || {}).default);\n    const sorted = Array.from(tracks).sort((a, b) => sortIsDefault(b) - sortIsDefault(a));\n    let track;\n\n    languages.every(language => {\n      track = sorted.find(t => t.language === language);\n      return !track; // Break iteration if there is a match\n    });\n\n    // If no match is found but is required, get first\n    return track || (force ? sorted[0] : undefined);\n  },\n\n  // Get the current track\n  getCurrentTrack() {\n    return captions.getTracks.call(this)[this.currentTrack];\n  },\n\n  // Get UI label for track\n  getLabel(track) {\n    let currentTrack = track;\n\n    if (!is.track(currentTrack) && support.textTracks && this.captions.toggled) {\n      currentTrack = captions.getCurrentTrack.call(this);\n    }\n\n    if (is.track(currentTrack)) {\n      if (!is.empty(currentTrack.label)) {\n        return currentTrack.label;\n      }\n\n      if (!is.empty(currentTrack.language)) {\n        return track.language.toUpperCase();\n      }\n\n      return i18n.get('enabled', this.config);\n    }\n\n    return i18n.get('disabled', this.config);\n  },\n\n  // Update captions using current track's active cues\n  // Also optional array argument in case there isn't any track (ex: vimeo)\n  updateCues(input) {\n    // Requires UI\n    if (!this.supported.ui) {\n      return;\n    }\n\n    if (!is.element(this.elements.captions)) {\n      this.debug.warn('No captions element to render to');\n      return;\n    }\n\n    // Only accept array or empty input\n    if (!is.nullOrUndefined(input) && !Array.isArray(input)) {\n      this.debug.warn('updateCues: Invalid input', input);\n      return;\n    }\n\n    let cues = input;\n\n    // Get cues from track\n    if (!cues) {\n      const track = captions.getCurrentTrack.call(this);\n\n      cues = Array.from((track || {}).activeCues || [])\n        .map(cue => cue.getCueAsHTML())\n        .map(getHTML);\n    }\n\n    // Set new caption text\n    const content = cues.map(cueText => cueText.trim()).join('\\n');\n    const changed = content !== this.elements.captions.innerHTML;\n\n    if (changed) {\n      // Empty the container and create a new child element\n      emptyElement(this.elements.captions);\n      const caption = createElement('span', getAttributesFromSelector(this.config.selectors.caption));\n      caption.innerHTML = content;\n      this.elements.captions.appendChild(caption);\n\n      // Trigger event\n      triggerEvent.call(this, this.media, 'cuechange');\n    }\n  },\n};\n\nexport default captions;\n","// ==========================================================================\n// WassPlayer default config file\n// ==========================================================================\n\nconst defaults = {\n  // Disable\n  enabled: true,\n\n  // Custom media title\n  title: '',\n\n  // Logging to console\n  debug: false,\n\n  // Auto play (if supported)\n  autoplay: false,\n\n  // Only allow one media playing at once\n  autopause: true,\n\n  // Allow inline playback on iOS\n  playsinline: true,\n\n  // Default time to skip when rewind/fast forward\n  seekTime: 10,\n\n  // Default volume\n  volume: 1,\n  muted: false,\n\n  // Pass a custom duration\n  duration: null,\n\n  // Display the media duration on load in the current time position\n  // If you have opted to display both duration and currentTime, this is ignored\n  displayDuration: true,\n\n  // Invert the current time to be a countdown\n  invertTime: true,\n\n  // Clicking the currentTime inverts it's value to show time left rather than elapsed\n  toggleInvert: true,\n\n  // Force an aspect ratio\n  // The format must be `'w:h'` (e.g. `'16:9'`)\n  ratio: null,\n\n  // Click video container to play/pause\n  clickToPlay: true,\n\n  // Auto hide the controls\n  hideControls: true,\n\n  // Reset to start when playback ended\n  resetOnEnd: false,\n\n  // Disable the standard context menu\n  disableContextMenu: true,\n\n  // Sprite (for icons)\n  loadSprite: true,\n  iconPrefix: 'wassPlayer',\n  iconUrl: 'http://code4stack.com/wassplayer.svg',\n\n  // Quality default\n  quality: {\n    default: 576,\n    // The options to display in the UI, if available for the source media\n    options: [4320, 2880, 2160, 1440, 1080, 720, 576, 480, 360, 240],\n    forced: false,\n    onChange: null,\n  },\n\n  // Set loops\n  loop: {\n    active: false,\n    // start: null,\n    // end: null,\n  },\n\n  // Speed default and options to display\n  speed: {\n    selected: 1,\n    // The options to display in the UI, if available for the source media\n    options: [0.5, 0.75, 1, 1.25, 1.5, 1.75, 2, 4],\n  },\n\n  // Keyboard shortcut settings\n  keyboard: {\n    focused: true,\n    global: false,\n  },\n\n  // Display tooltips\n  tooltips: {\n    controls: false,\n    seek: true,\n  },\n\n  // Captions settings\n  captions: {\n    active: false,\n    language: 'auto',\n    // Listen to new tracks added after Plyr is initialized.\n    // This is needed for streaming captions, but may result in unselectable options\n    update: false,\n  },\n\n  // Fullscreen settings\n  fullscreen: {\n    enabled: true, // Allow fullscreen?\n    fallback: true, // Fallback using full viewport/window\n    iosNative: false, // Use the native fullscreen in iOS (disables custom controls)\n    // Selector for the fullscreen container so contextual / non-player content can remain visible in fullscreen mode\n    // Non-ancestors of the player element will be ignored\n    // container: null, // defaults to the player element\n  },\n\n  // Local storage\n  storage: {\n    enabled: true,\n    key: 'wassPlayer',\n  },\n\n  // Default controls\n  controls: [\n    'play-large',\n    // 'restart',\n    'rewind',\n    'play',\n    'fast-forward',\n    'progress',\n    'current-time',\n    // 'duration',\n    'mute',\n    'volume',\n    'captions',\n    'settings',\n    'pip',\n    'airplay',\n    // 'download',\n    'fullscreen',\n  ],\n  settings: ['captions', 'quality', 'speed'],\n\n  // Localisation\n  i18n: {\n    restart: 'Restart',\n    rewind: 'Rewind {seektime}s',\n    play: 'Play',\n    pause: 'Pause',\n    fastForward: 'Forward {seektime}s',\n    seek: 'Seek',\n    seekLabel: '{currentTime} of {duration}',\n    played: 'Played',\n    buffered: 'Buffered',\n    currentTime: 'Current time',\n    duration: 'Duration',\n    volume: 'Volume',\n    mute: 'Mute',\n    unmute: 'Unmute',\n    enableCaptions: 'Enable captions',\n    disableCaptions: 'Disable captions',\n    download: 'Download',\n    enterFullscreen: 'Enter fullscreen',\n    exitFullscreen: 'Exit fullscreen',\n    frameTitle: 'Player for {title}',\n    captions: 'Captions',\n    settings: 'Settings',\n    pip: 'PIP',\n    menuBack: 'Go back to previous menu',\n    speed: 'Speed',\n    normal: 'Normal',\n    quality: 'Quality',\n    loop: 'Loop',\n    start: 'Start',\n    end: 'End',\n    all: 'All',\n    reset: 'Reset',\n    disabled: 'Disabled',\n    enabled: 'Enabled',\n    advertisement: 'Ad',\n    qualityBadge: {\n      2160: '4K',\n      1440: 'HD',\n      1080: 'HD',\n      720: 'HD',\n      576: 'SD',\n      480: 'SD',\n    },\n  },\n\n  // Custom control listeners\n  listeners: {\n    seek: null,\n    play: null,\n    pause: null,\n    restart: null,\n    rewind: null,\n    fastForward: null,\n    mute: null,\n    volume: null,\n    captions: null,\n    download: null,\n    fullscreen: null,\n    pip: null,\n    airplay: null,\n    speed: null,\n    quality: null,\n    loop: null,\n    language: null,\n  },\n\n  // Events to watch and bubble\n  events: [\n    // Events to watch on HTML5 media elements and bubble\n    // https://developer.mozilla.org/en/docs/Web/Guide/Events/Media_events\n    'ended',\n    'progress',\n    'stalled',\n    'playing',\n    'waiting',\n    'canplay',\n    'canplaythrough',\n    'loadstart',\n    'loadeddata',\n    'loadedmetadata',\n    'timeupdate',\n    'volumechange',\n    'play',\n    'pause',\n    'error',\n    'seeking',\n    'seeked',\n    'emptied',\n    'ratechange',\n    'cuechange',\n\n    // Custom events\n    'download',\n    'enterfullscreen',\n    'exitfullscreen',\n    'captionsenabled',\n    'captionsdisabled',\n    'languagechange',\n    'controlshidden',\n    'controlsshown',\n    'ready',\n\n    // Quality\n    'qualitychange',\n  ],\n\n  // Selectors\n  // Change these to match your template if using custom HTML\n  selectors: {\n    editable: 'input, textarea, select, [contenteditable]',\n    container: '.wassPlayer',\n    controls: {\n      container: null,\n      wrapper: '.wassPlayer__controls',\n    },\n    labels: '[data-wassPlayer]',\n    buttons: {\n      play: '[data-wassPlayer=\"play\"]',\n      pause: '[data-wassPlayer=\"pause\"]',\n      restart: '[data-wassPlayer=\"restart\"]',\n      rewind: '[data-wassPlayer=\"rewind\"]',\n      fastForward: '[data-wassPlayer=\"fast-forward\"]',\n      mute: '[data-wassPlayer=\"mute\"]',\n      captions: '[data-wassPlayer=\"captions\"]',\n      download: '[data-wassPlayer=\"download\"]',\n      fullscreen: '[data-wassPlayer=\"fullscreen\"]',\n      pip: '[data-wassPlayer=\"pip\"]',\n      airplay: '[data-wassPlayer=\"airplay\"]',\n      settings: '[data-wassPlayer=\"settings\"]',\n      loop: '[data-wassPlayer=\"loop\"]',\n    },\n    inputs: {\n      seek: '[data-wassPlayer=\"seek\"]',\n      volume: '[data-wassPlayer=\"volume\"]',\n      speed: '[data-wassPlayer=\"speed\"]',\n      language: '[data-wassPlayer=\"language\"]',\n      quality: '[data-wassPlayer=\"quality\"]',\n    },\n    display: {\n      currentTime: '.wassPlayer__time--current',\n      duration: '.wassPlayer__time--duration',\n      buffer: '.wassPlayer__progress__buffer',\n      loop: '.wassPlayer__progress__loop', // Used later\n      volume: '.wassPlayer__volume--display',\n    },\n    progress: '.wassPlayer__progress',\n    captions: '.wassPlayer__captions',\n    caption: '.wassPlayer__caption',\n  },\n\n  // Class hooks added to the player in different states\n  classNames: {\n    type: 'wassPlayer--{0}',\n    provider: 'wassPlayer--{0}',\n    video: 'wassPlayer__video-wrapper',\n    embed: 'wassPlayer__video-embed',\n    videoFixedRatio: 'wassPlayer__video-wrapper--fixed-ratio',\n    embedContainer: 'wassPlayer__video-embed__container',\n    poster: 'wassPlayer__poster',\n    posterEnabled: 'wassPlayer__poster-enabled',\n    control: 'wassPlayer__control',\n    controlPressed: 'wassPlayer__control--pressed',\n    playing: 'wassPlayer--playing',\n    paused: 'wassPlayer--paused',\n    stopped: 'wassPlayer--stopped',\n    loading: 'wassPlayer--loading',\n    hover: 'wassPlayer--hover',\n    tooltip: 'wassPlayer__tooltip',\n    cues: 'wassPlayer__cues',\n    hidden: 'wassPlayer__sr-only',\n    hideControls: 'wassPlayer--hide-controls',\n    isIos: 'wassPlayer--is-ios',\n    isTouch: 'wassPlayer--is-touch',\n    uiSupported: 'wassPlayer--full-ui',\n    noTransition: 'wassPlayer--no-transition',\n    display: {\n      time: 'wassPlayer__time',\n    },\n    menu: {\n      value: 'wassPlayer__menu__value',\n      badge: 'wassPlayer__badge',\n      open: 'wassPlayer--menu-open',\n    },\n    captions: {\n      enabled: 'wassPlayer--captions-enabled',\n      active: 'wassPlayer--captions-active',\n    },\n    fullscreen: {\n      enabled: 'wassPlayer--fullscreen-enabled',\n      fallback: 'wassPlayer--fullscreen-fallback',\n    },\n    pip: {\n      supported: 'wassPlayer--pip-supported',\n      active: 'wassPlayer--pip-active',\n    },\n    airplay: {\n      supported: 'wassPlayer--airplay-supported',\n      active: 'wassPlayer--airplay-active',\n    },\n    tabFocus: 'wassPlayer__tab-focus',\n    previewThumbnails: {\n      // Tooltip thumbs\n      thumbContainer: 'wassPlayer__preview-thumb',\n      thumbContainerShown: 'wassPlayer__preview-thumb--is-shown',\n      imageContainer: 'wassPlayer__preview-thumb__image-container',\n      timeContainer: 'wassPlayer__preview-thumb__time-container',\n      // Scrubbing\n      scrubbingContainer: 'wassPlayer__preview-scrubbing',\n      scrubbingContainerShown: 'wassPlayer__preview-scrubbing--is-shown',\n    },\n  },\n\n  // Embed attributes\n  attributes: {\n    embed: {\n      provider: 'data-wassPlayer-provider',\n      id: 'data-wassPlayer-embed-id',\n    },\n  },\n\n  // Preview Thumbnails plugin\n  previewThumbnails: {\n    enabled: false,\n    src: '',\n  },\n};\n\nexport default defaults;\n","// ==========================================================================\n// WassPlayer states\n// ==========================================================================\n\nexport const pip = {\n  active: 'picture-in-picture',\n  inactive: 'inline',\n};\n\nexport default { pip };\n","// ==========================================================================\n// WassPlayer supported types and providers\n// ==========================================================================\n\nexport const providers = {\n  html5: 'html5',\n};\n\nexport const types = {\n  video: 'video',\n};\n\n/**\n * Get provider by URL\n * @param {String} url\n */\nexport function getProviderByUrl() {\n  return null;\n}\n\nexport default { providers, types };\n","// ==========================================================================\n// Console wrapper\n// ==========================================================================\n\nconst noop = () => {};\n\nexport default class Console {\n  constructor(enabled = false) {\n    this.enabled = window.console && enabled;\n\n    if (this.enabled) {\n      this.log('Debugging enabled');\n    }\n  }\n\n  get log() {\n    // eslint-disable-next-line no-console\n    return this.enabled ? Function.prototype.bind.call(console.log, console) : noop;\n  }\n\n  get warn() {\n    // eslint-disable-next-line no-console\n    return this.enabled ? Function.prototype.bind.call(console.warn, console) : noop;\n  }\n\n  get error() {\n    // eslint-disable-next-line no-console\n    return this.enabled ? Function.prototype.bind.call(console.error, console) : noop;\n  }\n}\n","// ==========================================================================\n// Fullscreen wrapper\n// https://developer.mozilla.org/en-US/docs/Web/API/Fullscreen_API#prefixing\n// https://webkit.org/blog/7929/designing-websites-for-iphone-x/\n// ==========================================================================\n\nimport browser from './utils/browser';\nimport { closest,getElements, hasClass, toggleClass } from './utils/elements';\nimport { on, triggerEvent } from './utils/events';\nimport is from './utils/is';\nimport { silencePromise } from './utils/promise';\n\nclass Fullscreen {\n  constructor(player) {\n    // Keep reference to parent\n    this.player = player;\n\n    // Get prefix\n    this.prefix = Fullscreen.prefix;\n    this.property = Fullscreen.property;\n\n    // Scroll position\n    this.scrollPosition = { x: 0, y: 0 };\n\n    // Force the use of 'full window/browser' rather than fullscreen\n    this.forceFallback = player.config.fullscreen.fallback === 'force';\n\n    // Get the fullscreen element\n    // Checks container is an ancestor, defaults to null\n    this.player.elements.fullscreen =\n      player.config.fullscreen.container && closest(this.player.elements.container, player.config.fullscreen.container);\n\n    // Register event listeners\n    // Handle event (incase user presses escape etc)\n    on.call(\n      this.player,\n      document,\n      this.prefix === 'ms' ? 'MSFullscreenChange' : `${this.prefix}fullscreenchange`,\n      () => {\n        this.onChange();\n      },\n    );\n\n    // Fullscreen toggle on double click\n    on.call(this.player, this.player.elements.container, 'dblclick', event => {\n      // Ignore double click in controls\n      if (is.element(this.player.elements.controls) && this.player.elements.controls.contains(event.target)) {\n        return;\n      }\n\n      this.toggle();\n    });\n\n    // Tap focus when in fullscreen\n    on.call(this, this.player.elements.container, 'keydown', event => this.trapFocus(event));\n\n    // Update the UI\n    this.update();\n  }\n\n  // Determine if native supported\n  static get native() {\n    return !!(\n      document.fullscreenEnabled ||\n      document.webkitFullscreenEnabled ||\n      document.mozFullScreenEnabled ||\n      document.msFullscreenEnabled\n    );\n  }\n\n  // If we're actually using native\n  get usingNative() {\n    return Fullscreen.native && !this.forceFallback;\n  }\n\n  // Get the prefix for handlers\n  static get prefix() {\n    // No prefix\n    if (is.function(document.exitFullscreen)) {\n      return '';\n    }\n\n    // Check for fullscreen support by vendor prefix\n    let value = '';\n    const prefixes = ['webkit', 'moz', 'ms'];\n\n    prefixes.some(pre => {\n      if (is.function(document[`${pre}ExitFullscreen`]) || is.function(document[`${pre}CancelFullScreen`])) {\n        value = pre;\n        return true;\n      }\n\n      return false;\n    });\n\n    return value;\n  }\n\n  static get property() {\n    return this.prefix === 'moz' ? 'FullScreen' : 'Fullscreen';\n  }\n\n  // Determine if fullscreen is enabled\n  get enabled() {\n    return (\n      (Fullscreen.native || this.player.config.fullscreen.fallback) &&\n      this.player.config.fullscreen.enabled &&\n      this.player.supported.ui &&\n      this.player.isVideo\n    );\n  }\n\n  // Get active state\n  get active() {\n    if (!this.enabled) {\n      return false;\n    }\n\n    // Fallback using classname\n    if (!Fullscreen.native || this.forceFallback) {\n      return hasClass(this.target, this.player.config.classNames.fullscreen.fallback);\n    }\n\n    const element = !this.prefix ? document.fullscreenElement : document[`${this.prefix}${this.property}Element`];\n\n    return element && element.shadowRoot ? element === this.target.getRootNode().host : element === this.target;\n  }\n\n  // Get target element\n  get target() {\n    return browser.isIos && this.player.config.fullscreen.iosNative ? this.player.media\n      : this.player.elements.fullscreen || this.player.elements.container;\n  }\n\n  onChange() {\n    if (!this.enabled) {\n      return;\n    }\n\n    // Update toggle button\n    const button = this.player.elements.buttons.fullscreen;\n    if (is.element(button)) {\n      button.pressed = this.active;\n    }\n\n    // Trigger an event\n    triggerEvent.call(this.player, this.target, this.active ? 'enterfullscreen' : 'exitfullscreen', true);\n  }\n\n  toggleFallback(toggle = false) {\n    // Store or restore scroll position\n    if (toggle) {\n      this.scrollPosition = {\n        x: window.scrollX || 0,\n        y: window.scrollY || 0,\n      };\n    } else {\n      window.scrollTo(this.scrollPosition.x, this.scrollPosition.y);\n    }\n\n    // Toggle scroll\n    document.body.style.overflow = toggle ? 'hidden' : '';\n\n    // Toggle class hook\n    toggleClass(this.target, this.player.config.classNames.fullscreen.fallback, toggle);\n\n    // Force full viewport on iPhone X+\n    if (browser.isIos) {\n      let viewport = document.head.querySelector('meta[name=\"viewport\"]');\n      const property = 'viewport-fit=cover';\n\n      // Inject the viewport meta if required\n      if (!viewport) {\n        viewport = document.createElement('meta');\n        viewport.setAttribute('name', 'viewport');\n      }\n\n      // Check if the property already exists\n      const hasProperty = is.string(viewport.content) && viewport.content.includes(property);\n\n      if (toggle) {\n        this.cleanupViewport = !hasProperty;\n\n        if (!hasProperty) {\n          viewport.content += `,${property}`;\n        }\n      } else if (this.cleanupViewport) {\n        viewport.content = viewport.content\n          .split(',')\n          .filter(part => part.trim() !== property)\n          .join(',');\n      }\n    }\n\n    // Toggle button and fire events\n    this.onChange();\n  }\n\n  // Trap focus inside container\n  trapFocus(event) {\n    // Bail if iOS, not active, not the tab key\n    if (browser.isIos || !this.active || event.key !== 'Tab' || event.keyCode !== 9) {\n      return;\n    }\n\n    // Get the current focused element\n    const focused = document.activeElement;\n    const focusable = getElements.call(this.player, 'a[href], button:not(:disabled), input:not(:disabled), [tabindex]');\n    const [first] = focusable;\n    const last = focusable[focusable.length - 1];\n\n    if (focused === last && !event.shiftKey) {\n      // Move focus to first element that can be tabbed if Shift isn't used\n      first.focus();\n      event.preventDefault();\n    } else if (focused === first && event.shiftKey) {\n      // Move focus to last element that can be tabbed if Shift is used\n      last.focus();\n      event.preventDefault();\n    }\n  }\n\n  // Update UI\n  update() {\n    if (this.enabled) {\n      let mode;\n\n      if (this.forceFallback) {\n        mode = 'Fallback (forced)';\n      } else if (Fullscreen.native) {\n        mode = 'Native';\n      } else {\n        mode = 'Fallback';\n      }\n\n      this.player.debug.log(`${mode} fullscreen enabled`);\n    } else {\n      this.player.debug.log('Fullscreen not supported and fallback disabled');\n    }\n\n    // Add styling hook to show button\n    toggleClass(this.player.elements.container, this.player.config.classNames.fullscreen.enabled, this.enabled);\n  }\n\n  // Make an element fullscreen\n  enter() {\n    if (!this.enabled) {\n      return;\n    }\n\n    // iOS native fullscreen doesn't need the request step\n    if (browser.isIos && this.player.config.fullscreen.iosNative) {\n      this.target.webkitEnterFullscreen();\n    } else if (!Fullscreen.native || this.forceFallback) {\n      this.toggleFallback(true);\n    } else if (!this.prefix) {\n      this.target.requestFullscreen({ navigationUI: 'hide' });\n    } else if (!is.empty(this.prefix)) {\n      this.target[`${this.prefix}Request${this.property}`]();\n    }\n  }\n\n  // Bail from fullscreen\n  exit() {\n    if (!this.enabled) {\n      return;\n    }\n\n    // iOS native fullscreen\n    if (browser.isIos && this.player.config.fullscreen.iosNative) {\n      this.target.webkitExitFullscreen();\n      silencePromise(this.player.play());\n    } else if (!Fullscreen.native || this.forceFallback) {\n      this.toggleFallback(false);\n    } else if (!this.prefix) {\n      (document.cancelFullScreen || document.exitFullscreen).call(document);\n    } else if (!is.empty(this.prefix)) {\n      const action = this.prefix === 'moz' ? 'Cancel' : 'Exit';\n      document[`${this.prefix}${action}${this.property}`]();\n    }\n  }\n\n  // Toggle state\n  toggle() {\n    if (!this.active) {\n      this.enter();\n    } else {\n      this.exit();\n    }\n  }\n}\n\nexport default Fullscreen;\n","// ==========================================================================\n// Load image avoiding xhr/fetch CORS issues\n// Server status can't be obtained this way unfortunately, so this uses \"naturalWidth\" to determine if the image has loaded\n// By default it checks if it is at least 1px, but you can add a second argument to change this\n// ==========================================================================\n\nexport default function loadImage(src, minWidth = 1) {\n  return new Promise((resolve, reject) => {\n    const image = new Image();\n\n    const handler = () => {\n      delete image.onload;\n      delete image.onerror;\n      (image.naturalWidth >= minWidth ? resolve : reject)(image);\n    };\n\n    Object.assign(image, { onload: handler, onerror: handler, src });\n  });\n}\n","// ==========================================================================\n// WassPlayer UI\n// ==========================================================================\n\nimport captions from './captions';\nimport controls from './controls';\nimport support from './support';\nimport browser from './utils/browser';\nimport { getElement, toggleClass } from './utils/elements';\nimport { ready, triggerEvent } from './utils/events';\nimport i18n from './utils/i18n';\nimport is from './utils/is';\nimport loadImage from './utils/load-image';\n\nconst ui = {\n  addStyleHook() {\n    toggleClass(this.elements.container, this.config.selectors.container.replace('.', ''), true);\n    toggleClass(this.elements.container, this.config.classNames.uiSupported, this.supported.ui);\n  },\n\n  // Toggle native HTML5 media controls\n  toggleNativeControls(toggle = false) {\n    if (toggle && this.isHTML5) {\n      this.media.setAttribute('controls', '');\n    } else {\n      this.media.removeAttribute('controls');\n    }\n  },\n\n  // Setup the UI\n  build() {\n    // Re-attach media element listeners\n    // TODO: Use event bubbling?\n    this.listeners.media();\n\n    // Don't setup interface if no support\n    if (!this.supported.ui) {\n      this.debug.warn(`Basic support only for ${this.provider} ${this.type}`);\n\n      // Restore native controls\n      ui.toggleNativeControls.call(this, true);\n\n      // Bail\n      return;\n    }\n\n    // Inject custom controls if not present\n    if (!is.element(this.elements.controls)) {\n      // Inject custom controls\n      controls.inject.call(this);\n\n      // Re-attach control listeners\n      this.listeners.controls();\n    }\n\n    // Remove native controls\n    ui.toggleNativeControls.call(this);\n\n    // Setup captions for HTML5\n    if (this.isHTML5) {\n      captions.setup.call(this);\n    }\n\n    // Reset volume\n    this.volume = null;\n\n    // Reset mute state\n    this.muted = null;\n\n    // Reset loop state\n    this.loop = null;\n\n    // Reset quality setting\n    this.quality = null;\n\n    // Reset speed\n    this.speed = null;\n\n    // Reset volume display\n    controls.updateVolume.call(this);\n\n    // Reset time display\n    controls.timeUpdate.call(this);\n\n    // Update the UI\n    ui.checkPlaying.call(this);\n\n    // Check for picture-in-picture support\n    toggleClass(\n      this.elements.container,\n      this.config.classNames.pip.supported,\n      support.pip && this.isHTML5 && this.isVideo,\n    );\n\n    // Check for airplay support\n    toggleClass(this.elements.container, this.config.classNames.airplay.supported, support.airplay && this.isHTML5);\n\n    // Add iOS class\n    toggleClass(this.elements.container, this.config.classNames.isIos, browser.isIos);\n\n    // Add touch class\n    toggleClass(this.elements.container, this.config.classNames.isTouch, this.touch);\n\n    // Ready for API calls\n    this.ready = true;\n\n    // Ready event at end of execution stack\n    setTimeout(() => {\n      triggerEvent.call(this, this.media, 'ready');\n    }, 0);\n\n    // Set the title\n    ui.setTitle.call(this);\n\n    // Assure the poster image is set, if the property was added before the element was created\n    if (this.poster) {\n      ui.setPoster.call(this, this.poster, false).catch(() => {});\n    }\n\n    // Manually set the duration if user has overridden it.\n    // The event listeners for it doesn't get called if preload is disabled (#701)\n    if (this.config.duration) {\n      controls.durationUpdate.call(this);\n    }\n  },\n\n  // Setup aria attribute for play and iframe title\n  setTitle() {\n    // Find the current text\n    let label = i18n.get('play', this.config);\n\n    // If there's a media title set, use that for the label\n    if (is.string(this.config.title) && !is.empty(this.config.title)) {\n      label += `, ${this.config.title}`;\n    }\n\n    // If there's a play button, set label\n    Array.from(this.elements.buttons.play || []).forEach(button => {\n      button.setAttribute('aria-label', label);\n    });\n\n    // Set iframe title\n    // https://github.com/sampotts/WassPlayer/issues/124\n    if (this.isEmbed) {\n      const iframe = getElement.call(this, 'iframe');\n\n      if (!is.element(iframe)) {\n        return;\n      }\n\n      // Default to media type\n      const title = !is.empty(this.config.title) ? this.config.title : 'video';\n      const format = i18n.get('frameTitle', this.config);\n\n      iframe.setAttribute('title', format.replace('{title}', title));\n    }\n  },\n\n  // Toggle poster\n  togglePoster(enable) {\n    toggleClass(this.elements.container, this.config.classNames.posterEnabled, enable);\n  },\n\n  // Set the poster image (async)\n  // Used internally for the poster setter, with the passive option forced to false\n  setPoster(poster, passive = true) {\n    // Don't override if call is passive\n    if (passive && this.poster) {\n      return Promise.reject(new Error('Poster already set'));\n    }\n\n    // Set property synchronously to respect the call order\n    this.media.setAttribute('data-poster', poster);\n\n    // Wait until ui is ready\n    return (\n      ready\n        .call(this)\n        // Load image\n        .then(() => loadImage(poster))\n        .catch(err => {\n          // Hide poster on error unless it's been set by another call\n          if (poster === this.poster) {\n            ui.togglePoster.call(this, false);\n          }\n          // Rethrow\n          throw err;\n        })\n        .then(() => {\n          // Prevent race conditions\n          if (poster !== this.poster) {\n            throw new Error('setPoster cancelled by later call to setPoster');\n          }\n        })\n        .then(() => {\n          Object.assign(this.elements.poster.style, {\n            backgroundImage: `url('${poster}')`,\n            // Reset backgroundSize as well (since it can be set to \"cover\" for padded thumbnails for youtube)\n            backgroundSize: '',\n          });\n\n          ui.togglePoster.call(this, true);\n\n          return poster;\n        })\n    );\n  },\n\n  // Check playing state\n  checkPlaying(event) {\n    // Class hooks\n    toggleClass(this.elements.container, this.config.classNames.playing, this.playing);\n    toggleClass(this.elements.container, this.config.classNames.paused, this.paused);\n    toggleClass(this.elements.container, this.config.classNames.stopped, this.stopped);\n\n    // Set state\n    Array.from(this.elements.buttons.play || []).forEach(target => {\n      Object.assign(target, { pressed: this.playing });\n      target.setAttribute('aria-label', i18n.get(this.playing ? 'pause' : 'play', this.config));\n    });\n\n    // Only update controls on non timeupdate events\n    if (is.event(event) && event.type === 'timeupdate') {\n      return;\n    }\n\n    // Toggle controls\n    ui.toggleControls.call(this);\n  },\n\n  // Check if media is loading\n  checkLoading(event) {\n    this.loading = ['stalled', 'waiting'].includes(event.type);\n\n    // Clear timer\n    clearTimeout(this.timers.loading);\n\n    // Timer to prevent flicker when seeking\n    this.timers.loading = setTimeout(\n      () => {\n        // Update progress bar loading class state\n        toggleClass(this.elements.container, this.config.classNames.loading, this.loading);\n\n        // Update controls visibility\n        ui.toggleControls.call(this);\n      },\n      this.loading ? 250 : 0,\n    );\n  },\n\n  // Toggle controls based on state and `force` argument\n  toggleControls(force) {\n    const { controls: controlsElement } = this.elements;\n\n    if (controlsElement && this.config.hideControls) {\n      // Don't hide controls if a touch-device user recently seeked. (Must be limited to touch devices, or it occasionally prevents desktop controls from hiding.)\n      const recentTouchSeek = this.touch && this.lastSeekTime + 2000 > Date.now();\n\n      // Show controls if force, loading, paused, button interaction, or recent seek, otherwise hide\n      this.toggleControls(\n        Boolean(\n          force || this.loading || this.paused || controlsElement.pressed || controlsElement.hover || recentTouchSeek,\n        ),\n      );\n    }\n  },\n\n  // Migrate any custom properties from the media to the parent\n  migrateStyles() {\n    // Loop through values (as they are the keys when the object is spread 🤔)\n    Object.values({ ...this.media.style })\n      // We're only fussed about WassPlayer specific properties\n      .filter(key => !is.empty(key) && key.startsWith('--wassPlayer'))\n      .forEach(key => {\n        // Set on the container\n        this.elements.container.style.setProperty(key, this.media.style.getPropertyValue(key));\n\n        // Clean up from media element\n        this.media.style.removeProperty(key);\n      });\n\n    // Remove attribute if empty\n    if (is.empty(this.media.style)) {\n      this.media.removeAttribute('style');\n    }\n  },\n};\n\nexport default ui;\n","// ==========================================================================\n// WassPlayer Event Listeners\n// ==========================================================================\n\nimport controls from './controls';\nimport ui from './ui';\nimport { repaint } from './utils/animation';\nimport browser from './utils/browser';\nimport { getElement, getElements, matches, toggleClass } from './utils/elements';\nimport { off, on, once, toggleListener, triggerEvent } from './utils/events';\nimport is from './utils/is';\nimport { silencePromise } from './utils/promise';\nimport { getAspectRatio, setAspectRatio } from './utils/style';\n\nclass Listeners {\n  constructor(player) {\n    this.player = player;\n    this.lastKey = null;\n    this.focusTimer = null;\n    this.lastKeyDown = null;\n\n    this.handleKey = this.handleKey.bind(this);\n    this.toggleMenu = this.toggleMenu.bind(this);\n    this.setTabFocus = this.setTabFocus.bind(this);\n    this.firstTouch = this.firstTouch.bind(this);\n  }\n\n  // Handle key presses\n  handleKey(event) {\n    const { player } = this;\n    const { elements } = player;\n    const code = event.keyCode ? event.keyCode : event.which;\n    const pressed = event.type === 'keydown';\n    const repeat = pressed && code === this.lastKey;\n\n    // Bail if a modifier key is set\n    if (event.altKey || event.ctrlKey || event.metaKey || event.shiftKey) {\n      return;\n    }\n\n    // If the event is bubbled from the media element\n    // Firefox doesn't get the keycode for whatever reason\n    if (!is.number(code)) {\n      return;\n    }\n\n    // Seek by the number keys\n    const seekByKey = () => {\n      // Divide the max duration into 10th's and times by the number value\n      player.currentTime = (player.duration / 10) * (code - 48);\n    };\n\n    // Handle the key on keydown\n    // Reset on keyup\n    if (pressed) {\n      // Check focused element\n      // and if the focused element is not editable (e.g. text input)\n      // and any that accept key input http://webaim.org/techniques/keyboard/\n      const focused = document.activeElement;\n      if (is.element(focused)) {\n        const { editable } = player.config.selectors;\n        const { seek } = elements.inputs;\n\n        if (focused !== seek && matches(focused, editable)) {\n          return;\n        }\n\n        if (event.which === 32 && matches(focused, 'button, [role^=\"menuitem\"]')) {\n          return;\n        }\n      }\n\n      // Which keycodes should we prevent default\n      const preventDefault = [32, 37, 38, 39, 40, 48, 49, 50, 51, 52, 53, 54, 56, 57, 67, 70, 73, 75, 76, 77, 79];\n\n      // If the code is found prevent default (e.g. prevent scrolling for arrows)\n      if (preventDefault.includes(code)) {\n        event.preventDefault();\n        event.stopPropagation();\n      }\n\n      switch (code) {\n        case 48:\n        case 49:\n        case 50:\n        case 51:\n        case 52:\n        case 53:\n        case 54:\n        case 55:\n        case 56:\n        case 57:\n          // 0-9\n          if (!repeat) {\n            seekByKey();\n          }\n          break;\n\n        case 32:\n        case 75:\n          // Space and K key\n          if (!repeat) {\n            silencePromise(player.togglePlay());\n          }\n          break;\n\n        case 38:\n          // Arrow up\n          player.increaseVolume(0.1);\n          break;\n\n        case 40:\n          // Arrow down\n          player.decreaseVolume(0.1);\n          break;\n\n        case 77:\n          // M key\n          if (!repeat) {\n            player.muted = !player.muted;\n          }\n          break;\n\n        case 39:\n          // Arrow forward\n          player.forward();\n          break;\n\n        case 37:\n          // Arrow back\n          player.rewind();\n          break;\n\n        case 70:\n          // F key\n          player.fullscreen.toggle();\n          break;\n\n        case 67:\n          // C key\n          if (!repeat) {\n            player.toggleCaptions();\n          }\n          break;\n\n        case 76:\n          // L key\n          player.loop = !player.loop;\n          break;\n\n        /* case 73:\n                    this.setLoop('start');\n                    break;\n\n                case 76:\n                    this.setLoop();\n                    break;\n\n                case 79:\n                    this.setLoop('end');\n                    break; */\n\n        default:\n          break;\n      }\n\n      // Escape is handle natively when in full screen\n      // So we only need to worry about non native\n      if (code === 27 && !player.fullscreen.usingNative && player.fullscreen.active) {\n        player.fullscreen.toggle();\n      }\n\n      // Store last code for next cycle\n      this.lastKey = code;\n    } else {\n      this.lastKey = null;\n    }\n  }\n\n  // Toggle menu\n  toggleMenu(event) {\n    controls.toggleMenu.call(this.player, event);\n  }\n\n  // Device is touch enabled\n  firstTouch() {\n    const { player } = this;\n    const { elements } = player;\n\n    player.touch = true;\n\n    // Add touch class\n    toggleClass(elements.container, player.config.classNames.isTouch, true);\n  }\n\n  setTabFocus(event) {\n    const { player } = this;\n    const { elements } = player;\n\n    clearTimeout(this.focusTimer);\n\n    // Ignore any key other than tab\n    if (event.type === 'keydown' && event.which !== 9) {\n      return;\n    }\n\n    // Store reference to event timeStamp\n    if (event.type === 'keydown') {\n      this.lastKeyDown = event.timeStamp;\n    }\n\n    // Remove current classes\n    const removeCurrent = () => {\n      const className = player.config.classNames.tabFocus;\n      const current = getElements.call(player, `.${className}`);\n      toggleClass(current, className, false);\n    };\n\n    // Determine if a key was pressed to trigger this event\n    const wasKeyDown = event.timeStamp - this.lastKeyDown <= 20;\n\n    // Ignore focus events if a key was pressed prior\n    if (event.type === 'focus' && !wasKeyDown) {\n      return;\n    }\n\n    // Remove all current\n    removeCurrent();\n\n    // Delay the adding of classname until the focus has changed\n    // This event fires before the focusin event\n    if (event.type !== 'focusout') {\n      this.focusTimer = setTimeout(() => {\n        const focused = document.activeElement;\n\n        // Ignore if current focus element isn't inside the player\n        if (!elements.container.contains(focused)) {\n          return;\n        }\n\n        toggleClass(document.activeElement, player.config.classNames.tabFocus, true);\n      }, 10);\n    }\n  }\n\n  // Global window & document listeners\n  global(toggle = true) {\n    const { player } = this;\n\n    // Keyboard shortcuts\n    if (player.config.keyboard.global) {\n      toggleListener.call(player, window, 'keydown keyup', this.handleKey, toggle, false);\n    }\n\n    // Click anywhere closes menu\n    toggleListener.call(player, document.body, 'click', this.toggleMenu, toggle);\n\n    // Detect touch by events\n    once.call(player, document.body, 'touchstart', this.firstTouch);\n\n    // Tab focus detection\n    toggleListener.call(player, document.body, 'keydown focus blur focusout', this.setTabFocus, toggle, false, true);\n  }\n\n  // Container listeners\n  container() {\n    const { player } = this;\n    const { config, elements, timers } = player;\n\n    // Keyboard shortcuts\n    if (!config.keyboard.global && config.keyboard.focused) {\n      on.call(player, elements.container, 'keydown keyup', this.handleKey, false);\n    }\n\n    // Toggle controls on mouse events and entering fullscreen\n    on.call(\n      player,\n      elements.container,\n      'mousemove mouseleave touchstart touchmove enterfullscreen exitfullscreen',\n      event => {\n        const { controls: controlsElement } = elements;\n\n        // Remove button states for fullscreen\n        if (controlsElement && event.type === 'enterfullscreen') {\n          controlsElement.pressed = false;\n          controlsElement.hover = false;\n        }\n\n        // Show, then hide after a timeout unless another control event occurs\n        const show = ['touchstart', 'touchmove', 'mousemove'].includes(event.type);\n        let delay = 0;\n\n        if (show) {\n          ui.toggleControls.call(player, true);\n          // Use longer timeout for touch devices\n          delay = player.touch ? 3000 : 2000;\n        }\n\n        // Clear timer\n        clearTimeout(timers.controls);\n\n        // Set new timer to prevent flicker when seeking\n        timers.controls = setTimeout(() => ui.toggleControls.call(player, false), delay);\n      },\n    );\n\n    // Set a gutter for Vimeo\n    const setGutter = (ratio, padding, toggle) => {\n      if (!player.isVimeo || player.config.vimeo.premium) {\n        return;\n      }\n\n      const target = player.elements.wrapper.firstChild;\n      const [, y] = ratio;\n      const [videoX, videoY] = getAspectRatio.call(player);\n\n      target.style.maxWidth = toggle ? `${(y / videoY) * videoX}px` : null;\n      target.style.margin = toggle ? '0 auto' : null;\n    };\n\n    // Resize on fullscreen change\n    const setPlayerSize = measure => {\n      // If we don't need to measure the viewport\n      if (!measure) {\n        return setAspectRatio.call(player);\n      }\n\n      const rect = elements.container.getBoundingClientRect();\n      const { width, height } = rect;\n\n      return setAspectRatio.call(player, `${width}:${height}`);\n    };\n\n    const resized = () => {\n      clearTimeout(timers.resized);\n      timers.resized = setTimeout(setPlayerSize, 50);\n    };\n\n    on.call(player, elements.container, 'enterfullscreen exitfullscreen', event => {\n      const { target, usingNative } = player.fullscreen;\n\n      // Ignore events not from target\n      if (target !== elements.container) {\n        return;\n      }\n\n      // If it's not an embed and no ratio specified\n      if (!player.isEmbed && is.empty(player.config.ratio)) {\n        return;\n      }\n\n      const isEnter = event.type === 'enterfullscreen';\n      // Set the player size when entering fullscreen to viewport size\n      const { padding, ratio } = setPlayerSize(isEnter);\n\n      // Set Vimeo gutter\n      setGutter(ratio, padding, isEnter);\n\n      // If not using native browser fullscreen API, we need to check for resizes of viewport\n      if (!usingNative) {\n        if (isEnter) {\n          on.call(player, window, 'resize', resized);\n        } else {\n          off.call(player, window, 'resize', resized);\n        }\n      }\n    });\n  }\n\n  // Listen for media events\n  media() {\n    const { player } = this;\n    const { elements } = player;\n\n    // Time change on media\n    on.call(player, player.media, 'timeupdate seeking seeked', event => controls.timeUpdate.call(player, event));\n\n    // Display duration\n    on.call(player, player.media, 'durationchange loadeddata loadedmetadata', event =>\n      controls.durationUpdate.call(player, event),\n    );\n\n    // Handle the media finishing\n    on.call(player, player.media, 'ended', () => {\n      // Show poster on end\n      if (player.isHTML5 && player.isVideo && player.config.resetOnEnd) {\n        // Restart\n        player.restart();\n\n        // Call pause otherwise IE11 will start playing the video again\n        player.pause();\n      }\n    });\n\n    // Check for buffer progress\n    on.call(player, player.media, 'progress playing seeking seeked', event =>\n      controls.updateProgress.call(player, event),\n    );\n\n    // Handle volume changes\n    on.call(player, player.media, 'volumechange', event => controls.updateVolume.call(player, event));\n\n    // Handle play/pause\n    on.call(player, player.media, 'playing play pause ended emptied timeupdate', event =>\n      ui.checkPlaying.call(player, event),\n    );\n\n    // Loading state\n    on.call(player, player.media, 'waiting canplay seeked playing', event => ui.checkLoading.call(player, event));\n\n    // Click video\n    if (player.supported.ui && player.config.clickToPlay && !player.isAudio) {\n      // Re-fetch the wrapper\n      const wrapper = getElement.call(player, `.${player.config.classNames.video}`);\n\n      // Bail if there's no wrapper (this should never happen)\n      if (!is.element(wrapper)) {\n        return;\n      }\n\n      // On click play, pause or restart\n      on.call(player, elements.container, 'click', event => {\n        const targets = [elements.container, wrapper];\n\n        // Ignore if click if not container or in video wrapper\n        if (!targets.includes(event.target) && !wrapper.contains(event.target)) {\n          return;\n        }\n\n        // Touch devices will just show controls (if hidden)\n        if (player.touch && player.config.hideControls) {\n          return;\n        }\n\n        if (player.ended) {\n          this.proxy(event, player.restart, 'restart');\n          this.proxy(\n            event,\n            () => {\n              silencePromise(player.play());\n            },\n            'play',\n          );\n        } else {\n          this.proxy(\n            event,\n            () => {\n              silencePromise(player.togglePlay());\n            },\n            'play',\n          );\n        }\n      });\n    }\n\n    // Disable right click\n    if (player.supported.ui && player.config.disableContextMenu) {\n      on.call(\n        player,\n        elements.wrapper,\n        'contextmenu',\n        event => {\n          event.preventDefault();\n        },\n        false,\n      );\n    }\n\n    // Volume change\n    on.call(player, player.media, 'volumechange', () => {\n      // Save to storage\n      player.storage.set({\n        volume: player.volume,\n        muted: player.muted,\n      });\n    });\n\n    // Speed change\n    on.call(player, player.media, 'ratechange', () => {\n      // Update UI\n      controls.updateSetting.call(player, 'speed');\n\n      // Save to storage\n      player.storage.set({ speed: player.speed });\n    });\n\n    // Quality change\n    on.call(player, player.media, 'qualitychange', event => {\n      // Update UI\n      controls.updateSetting.call(player, 'quality', null, event.detail.quality);\n    });\n\n    // Update download link when ready and if quality changes\n    on.call(player, player.media, 'ready qualitychange', () => {\n      controls.setDownloadUrl.call(player);\n    });\n\n    // Proxy events to container\n    // Bubble up key events for Edge\n    const proxyEvents = player.config.events.concat(['keyup', 'keydown']).join(' ');\n\n    on.call(player, player.media, proxyEvents, event => {\n      let { detail = {} } = event;\n\n      // Get error details from media\n      if (event.type === 'error') {\n        detail = player.media.error;\n      }\n\n      triggerEvent.call(player, elements.container, event.type, true, detail);\n    });\n  }\n\n  // Run default and custom handlers\n  proxy(event, defaultHandler, customHandlerKey) {\n    const { player } = this;\n    const customHandler = player.config.listeners[customHandlerKey];\n    const hasCustomHandler = is.function(customHandler);\n    let returned = true;\n\n    // Execute custom handler\n    if (hasCustomHandler) {\n      returned = customHandler.call(player, event);\n    }\n\n    // Only call default handler if not prevented in custom handler\n    if (returned !== false && is.function(defaultHandler)) {\n      defaultHandler.call(player, event);\n    }\n  }\n\n  // Trigger custom and default handlers\n  bind(element, type, defaultHandler, customHandlerKey, passive = true) {\n    const { player } = this;\n    const customHandler = player.config.listeners[customHandlerKey];\n    const hasCustomHandler = is.function(customHandler);\n\n    on.call(\n      player,\n      element,\n      type,\n      event => this.proxy(event, defaultHandler, customHandlerKey),\n      passive && !hasCustomHandler,\n    );\n  }\n\n  // Listen for control events\n  controls() {\n    const { player } = this;\n    const { elements } = player;\n    // IE doesn't support input event, so we fallback to change\n    const inputEvent = browser.isIE ? 'change' : 'input';\n\n    // Play/pause toggle\n    if (elements.buttons.play) {\n      Array.from(elements.buttons.play).forEach(button => {\n        this.bind(\n          button,\n          'click',\n          () => {\n            silencePromise(player.togglePlay());\n          },\n          'play',\n        );\n      });\n    }\n\n    // Pause\n    this.bind(elements.buttons.restart, 'click', player.restart, 'restart');\n\n    // Rewind\n    this.bind(elements.buttons.rewind, 'click', player.rewind, 'rewind');\n\n    // Rewind\n    this.bind(elements.buttons.fastForward, 'click', player.forward, 'fastForward');\n\n    // Mute toggle\n    this.bind(\n      elements.buttons.mute,\n      'click',\n      () => {\n        player.muted = !player.muted;\n      },\n      'mute',\n    );\n\n    // Captions toggle\n    this.bind(elements.buttons.captions, 'click', () => player.toggleCaptions());\n\n    // Download\n    this.bind(\n      elements.buttons.download,\n      'click',\n      () => {\n        triggerEvent.call(player, player.media, 'download');\n      },\n      'download',\n    );\n\n    // Fullscreen toggle\n    this.bind(\n      elements.buttons.fullscreen,\n      'click',\n      () => {\n        player.fullscreen.toggle();\n      },\n      'fullscreen',\n    );\n\n    // Picture-in-Picture\n    this.bind(\n      elements.buttons.pip,\n      'click',\n      () => {\n        player.pip = 'toggle';\n      },\n      'pip',\n    );\n\n    // Airplay\n    this.bind(elements.buttons.airplay, 'click', player.airplay, 'airplay');\n\n    // Settings menu - click toggle\n    this.bind(\n      elements.buttons.settings,\n      'click',\n      event => {\n        // Prevent the document click listener closing the menu\n        event.stopPropagation();\n        event.preventDefault();\n\n        controls.toggleMenu.call(player, event);\n      },\n      null,\n      false,\n    ); // Can't be passive as we're preventing default\n\n    // Settings menu - keyboard toggle\n    // We have to bind to keyup otherwise Firefox triggers a click when a keydown event handler shifts focus\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=1220143\n    this.bind(\n      elements.buttons.settings,\n      'keyup',\n      event => {\n        const code = event.which;\n\n        // We only care about space and return\n        if (![13, 32].includes(code)) {\n          return;\n        }\n\n        // Because return triggers a click anyway, all we need to do is set focus\n        if (code === 13) {\n          controls.focusFirstMenuItem.call(player, null, true);\n          return;\n        }\n\n        // Prevent scroll\n        event.preventDefault();\n\n        // Prevent playing video (Firefox)\n        event.stopPropagation();\n\n        // Toggle menu\n        controls.toggleMenu.call(player, event);\n      },\n      null,\n      false, // Can't be passive as we're preventing default\n    );\n\n    // Escape closes menu\n    this.bind(elements.settings.menu, 'keydown', event => {\n      if (event.which === 27) {\n        controls.toggleMenu.call(player, event);\n      }\n    });\n\n    // Set range input alternative \"value\", which matches the tooltip time (#954)\n    this.bind(elements.inputs.seek, 'mousedown mousemove', event => {\n      const rect = elements.progress.getBoundingClientRect();\n      const percent = (100 / rect.width) * (event.pageX - rect.left);\n      event.currentTarget.setAttribute('seek-value', percent);\n    });\n\n    // Pause while seeking\n    this.bind(elements.inputs.seek, 'mousedown mouseup keydown keyup touchstart touchend', event => {\n      const seek = event.currentTarget;\n      const code = event.keyCode ? event.keyCode : event.which;\n      const attribute = 'play-on-seeked';\n\n      if (is.keyboardEvent(event) && code !== 39 && code !== 37) {\n        return;\n      }\n\n      // Record seek time so we can prevent hiding controls for a few seconds after seek\n      player.lastSeekTime = Date.now();\n\n      // Was playing before?\n      const play = seek.hasAttribute(attribute);\n      // Done seeking\n      const done = ['mouseup', 'touchend', 'keyup'].includes(event.type);\n\n      // If we're done seeking and it was playing, resume playback\n      if (play && done) {\n        seek.removeAttribute(attribute);\n        silencePromise(player.play());\n      } else if (!done && player.playing) {\n        seek.setAttribute(attribute, '');\n        player.pause();\n      }\n    });\n\n    // Fix range inputs on iOS\n    // Super weird iOS bug where after you interact with an <input type=\"range\">,\n    // it takes over further interactions on the page. This is a hack\n    if (browser.isIos) {\n      const inputs = getElements.call(player, 'input[type=\"range\"]');\n      Array.from(inputs).forEach(input => this.bind(input, inputEvent, event => repaint(event.target)));\n    }\n\n    // Seek\n    this.bind(\n      elements.inputs.seek,\n      inputEvent,\n      event => {\n        const seek = event.currentTarget;\n        // If it exists, use seek-value instead of \"value\" for consistency with tooltip time (#954)\n        let seekTo = seek.getAttribute('seek-value');\n\n        if (is.empty(seekTo)) {\n          seekTo = seek.value;\n        }\n\n        seek.removeAttribute('seek-value');\n\n        player.currentTime = (seekTo / seek.max) * player.duration;\n      },\n      'seek',\n    );\n\n    // Seek tooltip\n    this.bind(elements.progress, 'mouseenter mouseleave mousemove', event =>\n      controls.updateSeekTooltip.call(player, event),\n    );\n\n    // Preview thumbnails plugin\n    this.bind(elements.progress, 'mousemove touchmove', event => {\n      const { previewThumbnails } = player;\n\n      if (previewThumbnails && previewThumbnails.loaded) {\n        previewThumbnails.startMove(event);\n      }\n    });\n\n    // Hide thumbnail preview - on mouse click, mouse leave, and video play/seek. All four are required, e.g., for buffering\n    this.bind(elements.progress, 'mouseleave touchend click', () => {\n      const { previewThumbnails } = player;\n\n      if (previewThumbnails && previewThumbnails.loaded) {\n        previewThumbnails.endMove(false, true);\n      }\n    });\n\n    // Show scrubbing preview\n    this.bind(elements.progress, 'mousedown touchstart', event => {\n      const { previewThumbnails } = player;\n\n      if (previewThumbnails && previewThumbnails.loaded) {\n        previewThumbnails.startScrubbing(event);\n      }\n    });\n\n    this.bind(elements.progress, 'mouseup touchend', event => {\n      const { previewThumbnails } = player;\n\n      if (previewThumbnails && previewThumbnails.loaded) {\n        previewThumbnails.endScrubbing(event);\n      }\n    });\n\n    // Polyfill for lower fill in <input type=\"range\"> for webkit\n    if (browser.isWebkit) {\n      Array.from(getElements.call(player, 'input[type=\"range\"]')).forEach(element => {\n        this.bind(element, 'input', event => controls.updateRangeFill.call(player, event.target));\n      });\n    }\n\n    // Current time invert\n    // Only if one time element is used for both currentTime and duration\n    if (player.config.toggleInvert && !is.element(elements.display.duration)) {\n      this.bind(elements.display.currentTime, 'click', () => {\n        // Do nothing if we're at the start\n        if (player.currentTime === 0) {\n          return;\n        }\n\n        player.config.invertTime = !player.config.invertTime;\n\n        controls.timeUpdate.call(player);\n      });\n    }\n\n    // Volume\n    this.bind(\n      elements.inputs.volume,\n      inputEvent,\n      event => {\n        player.volume = event.target.value;\n      },\n      'volume',\n    );\n\n    // Update controls.hover state (used for ui.toggleControls to avoid hiding when interacting)\n    this.bind(elements.controls, 'mouseenter mouseleave', event => {\n      elements.controls.hover = !player.touch && event.type === 'mouseenter';\n    });\n\n    // Also update controls.hover state for any non-player children of fullscreen element (as above)\n    if (elements.fullscreen) {\n      Array.from(elements.fullscreen.children)\n        .filter(c => !c.contains(elements.container))\n        .forEach(child => {\n          this.bind(child, 'mouseenter mouseleave', event => {\n            elements.controls.hover = !player.touch && event.type === 'mouseenter';\n          });\n        });\n    }\n\n    // Update controls.pressed state (used for ui.toggleControls to avoid hiding when interacting)\n    this.bind(elements.controls, 'mousedown mouseup touchstart touchend touchcancel', event => {\n      elements.controls.pressed = ['mousedown', 'touchstart'].includes(event.type);\n    });\n\n    // Show controls when they receive focus (e.g., when using keyboard tab key)\n    this.bind(elements.controls, 'focusin', () => {\n      const { config, timers } = player;\n\n      // Skip transition to prevent focus from scrolling the parent element\n      toggleClass(elements.controls, config.classNames.noTransition, true);\n\n      // Toggle\n      ui.toggleControls.call(player, true);\n\n      // Restore transition\n      setTimeout(() => {\n        toggleClass(elements.controls, config.classNames.noTransition, false);\n      }, 0);\n\n      // Delay a little more for mouse users\n      const delay = this.touch ? 3000 : 4000;\n\n      // Clear timer\n      clearTimeout(timers.controls);\n\n      // Hide again after delay\n      timers.controls = setTimeout(() => ui.toggleControls.call(player, false), delay);\n    });\n\n    // Mouse wheel for volume\n    this.bind(\n      elements.inputs.volume,\n      'wheel',\n      event => {\n        // Detect \"natural\" scroll - suppored on OS X Safari only\n        // Other browsers on OS X will be inverted until support improves\n        const inverted = event.webkitDirectionInvertedFromDevice;\n        // Get delta from event. Invert if `inverted` is true\n        const [x, y] = [event.deltaX, -event.deltaY].map(value => (inverted ? -value : value));\n        // Using the biggest delta, normalize to 1 or -1 (or 0 if no delta)\n        const direction = Math.sign(Math.abs(x) > Math.abs(y) ? x : y);\n\n        // Change the volume by 2%\n        player.increaseVolume(direction / 50);\n\n        // Don't break page scrolling at max and min\n        const { volume } = player.media;\n        if ((direction === 1 && volume < 1) || (direction === -1 && volume > 0)) {\n          event.preventDefault();\n        }\n      },\n      'volume',\n      false,\n    );\n  }\n}\n\nexport default Listeners;\n","// ==========================================================================\n// WassPlayer Media\n// ==========================================================================\n\nimport html5 from './html5';\nimport { createElement, toggleClass, wrap } from './utils/elements';\n\nconst media = {\n  // Setup media\n  setup() {\n    // If there's no media, bail\n    if (!this.media) {\n      this.debug.warn('No media element found!');\n      return;\n    }\n\n    // Add type class\n    toggleClass(this.elements.container, this.config.classNames.type.replace('{0}', this.type), true);\n\n    // Add provider class\n    toggleClass(this.elements.container, this.config.classNames.provider.replace('{0}', this.provider), true);\n\n    // Add video class for embeds\n    // This will require changes if audio embeds are added\n    if (this.isEmbed) {\n      toggleClass(this.elements.container, this.config.classNames.type.replace('{0}', 'video'), true);\n    }\n\n    // Inject the player wrapper\n    if (this.isVideo) {\n      // Create the wrapper div\n      this.elements.wrapper = createElement('div', {\n        class: this.config.classNames.video,\n      });\n\n      // Wrap the video in a container\n      wrap(this.media, this.elements.wrapper);\n\n      // Poster image container\n      this.elements.poster = createElement('div', {\n        class: this.config.classNames.poster,\n      });\n\n      this.elements.wrapper.appendChild(this.elements.poster);\n    }\n\n    if (this.isHTML5) {\n      html5.setup.call(this);\n    }\n  },\n};\n\nexport default media;\n","import { createElement } from '../utils/elements';\nimport { once } from '../utils/events';\nimport fetch from '../utils/fetch';\nimport is from '../utils/is';\nimport { formatTime } from '../utils/time';\n\n// Arg: vttDataString example: \"WEBVTT\\n\\n1\\n00:00:05.000 --> 00:00:10.000\\n1080p-00001.jpg\"\nconst parseVtt = vttDataString => {\n  const processedList = [];\n  const frames = vttDataString.split(/\\r\\n\\r\\n|\\n\\n|\\r\\r/);\n\n  frames.forEach(frame => {\n    const result = {};\n    const lines = frame.split(/\\r\\n|\\n|\\r/);\n\n    lines.forEach(line => {\n      if (!is.number(result.startTime)) {\n        // The line with start and end times on it is the first line of interest\n        const matchTimes = line.match(\n          /([0-9]{2})?:?([0-9]{2}):([0-9]{2}).([0-9]{2,3})( ?--> ?)([0-9]{2})?:?([0-9]{2}):([0-9]{2}).([0-9]{2,3})/,\n        ); // Note that this currently ignores caption formatting directives that are optionally on the end of this line - fine for non-captions VTT\n\n        if (matchTimes) {\n          result.startTime =\n            Number(matchTimes[1] || 0) * 60 * 60 +\n            Number(matchTimes[2]) * 60 +\n            Number(matchTimes[3]) +\n            Number(`0.${matchTimes[4]}`);\n          result.endTime =\n            Number(matchTimes[6] || 0) * 60 * 60 +\n            Number(matchTimes[7]) * 60 +\n            Number(matchTimes[8]) +\n            Number(`0.${matchTimes[9]}`);\n        }\n      } else if (!is.empty(line.trim()) && is.empty(result.text)) {\n        // If we already have the startTime, then we're definitely up to the text line(s)\n        const lineSplit = line.trim().split('#xywh=');\n        [result.text] = lineSplit;\n\n        // If there's content in lineSplit[1], then we have sprites. If not, then it's just one frame per image\n        if (lineSplit[1]) {\n          [result.x, result.y, result.w, result.h] = lineSplit[1].split(',');\n        }\n      }\n    });\n\n    if (result.text) {\n      processedList.push(result);\n    }\n  });\n\n  return processedList;\n};\n\nconst fitRatio = (ratio, outer) => {\n  const targetRatio = outer.width / outer.height;\n  const result = {};\n  if (ratio > targetRatio) {\n    result.width = outer.width;\n    result.height = (1 / ratio) * outer.width;\n  } else {\n    result.height = outer.height;\n    result.width = ratio * outer.height;\n  }\n\n  return result;\n};\n\nclass PreviewThumbnails {\n  /**\n   * PreviewThumbnails constructor.\n   * @param {wassPlayer} player\n   * @return {PreviewThumbnails}\n   */\n  constructor(player) {\n    this.player = player;\n    this.thumbnails = [];\n    this.loaded = false;\n    this.lastMouseMoveTime = Date.now();\n    this.mouseDown = false;\n    this.loadedImages = [];\n\n    this.elements = {\n      thumb: {},\n      scrubbing: {},\n    };\n\n    this.load();\n  }\n\n  get enabled() {\n    return this.player.isHTML5 && this.player.isVideo && this.player.config.previewThumbnails.enabled;\n  }\n\n  load() {\n    // Toggle the regular seek tooltip\n    if (this.player.elements.display.seekTooltip) {\n      this.player.elements.display.seekTooltip.hidden = this.enabled;\n    }\n\n    if (!this.enabled) {\n      return;\n    }\n\n    this.getThumbnails().then(() => {\n      if (!this.enabled) {\n        return;\n      }\n\n      // Render DOM elements\n      this.render();\n\n      // Check to see if thumb container size was specified manually in CSS\n      this.determineContainerAutoSizing();\n\n      this.loaded = true;\n    });\n  }\n\n  // Download VTT files and parse them\n  getThumbnails() {\n    return new Promise(resolve => {\n      const { src } = this.player.config.previewThumbnails;\n\n      if (is.empty(src)) {\n        throw new Error('Missing previewThumbnails.src config attribute');\n      }\n\n      // Resolve promise\n      const sortAndResolve = () => {\n        // Sort smallest to biggest (e.g., [120p, 480p, 1080p])\n        this.thumbnails.sort((x, y) => x.height - y.height);\n\n        this.player.debug.log('Preview thumbnails', this.thumbnails);\n\n        resolve();\n      };\n\n      // Via callback()\n      if (is.function(src)) {\n        src(thumbnails => {\n          this.thumbnails = thumbnails;\n          sortAndResolve();\n        });\n      }\n      // VTT urls\n      else {\n        // If string, convert into single-element list\n        const urls = is.string(src) ? [src] : src;\n        // Loop through each src URL. Download and process the VTT file, storing the resulting data in this.thumbnails\n        const promises = urls.map(u => this.getThumbnail(u));\n        // Resolve\n        Promise.all(promises).then(sortAndResolve);\n      }\n    });\n  }\n\n  // Process individual VTT file\n  getThumbnail(url) {\n    return new Promise(resolve => {\n      fetch(url).then(response => {\n        const thumbnail = {\n          frames: parseVtt(response),\n          height: null,\n          urlPrefix: '',\n        };\n\n        if (\n          !thumbnail.frames[0].text.startsWith('/') &&\n          !thumbnail.frames[0].text.startsWith('http://') &&\n          !thumbnail.frames[0].text.startsWith('https://')\n        ) {\n          thumbnail.urlPrefix = url.substring(0, url.lastIndexOf('/') + 1);\n        }\n\n        // Download the first frame, so that we can determine/set the height of this thumbnailsDef\n        const tempImage = new Image();\n\n        tempImage.onload = () => {\n          thumbnail.height = tempImage.naturalHeight;\n          thumbnail.width = tempImage.naturalWidth;\n\n          this.thumbnails.push(thumbnail);\n\n          resolve();\n        };\n\n        tempImage.src = thumbnail.urlPrefix + thumbnail.frames[0].text;\n      });\n    });\n  }\n\n  startMove(event) {\n    if (!this.loaded) {\n      return;\n    }\n\n    if (!is.event(event) || !['touchmove', 'mousemove'].includes(event.type)) {\n      return;\n    }\n\n    // Wait until media has a duration\n    if (!this.player.media.duration) {\n      return;\n    }\n\n    if (event.type === 'touchmove') {\n      // Calculate seek hover position as approx video seconds\n      this.seekTime = this.player.media.duration * (this.player.elements.inputs.seek.value / 100);\n    } else {\n      // Calculate seek hover position as approx video seconds\n      const clientRect = this.player.elements.progress.getBoundingClientRect();\n      const percentage = (100 / clientRect.width) * (event.pageX - clientRect.left);\n      this.seekTime = this.player.media.duration * (percentage / 100);\n\n      if (this.seekTime < 0) {\n        // The mousemove fires for 10+px out to the left\n        this.seekTime = 0;\n      }\n\n      if (this.seekTime > this.player.media.duration - 1) {\n        // Took 1 second off the duration for safety, because different players can disagree on the real duration of a video\n        this.seekTime = this.player.media.duration - 1;\n      }\n\n      this.mousePosX = event.pageX;\n\n      // Set time text inside image container\n      this.elements.thumb.time.innerText = formatTime(this.seekTime);\n    }\n\n    // Download and show image\n    this.showImageAtCurrentTime();\n  }\n\n  endMove() {\n    this.toggleThumbContainer(false, true);\n  }\n\n  startScrubbing(event) {\n    // Only act on left mouse button (0), or touch device (event.button does not exist or is false)\n    if (is.nullOrUndefined(event.button) || event.button === false || event.button === 0) {\n      this.mouseDown = true;\n\n      // Wait until media has a duration\n      if (this.player.media.duration) {\n        this.toggleScrubbingContainer(true);\n        this.toggleThumbContainer(false, true);\n\n        // Download and show image\n        this.showImageAtCurrentTime();\n      }\n    }\n  }\n\n  endScrubbing() {\n    this.mouseDown = false;\n\n    // Hide scrubbing preview. But wait until the video has successfully seeked before hiding the scrubbing preview\n    if (Math.ceil(this.lastTime) === Math.ceil(this.player.media.currentTime)) {\n      // The video was already seeked/loaded at the chosen time - hide immediately\n      this.toggleScrubbingContainer(false);\n    } else {\n      // The video hasn't seeked yet. Wait for that\n      once.call(this.player, this.player.media, 'timeupdate', () => {\n        // Re-check mousedown - we might have already started scrubbing again\n        if (!this.mouseDown) {\n          this.toggleScrubbingContainer(false);\n        }\n      });\n    }\n  }\n\n  /**\n   * Setup hooks for wassPlayer and window events\n   */\n  listeners() {\n    this.player.on('play', () => {\n      this.toggleThumbContainer(false, true);\n    });\n\n    this.player.on('seeked', () => {\n      this.toggleThumbContainer(false);\n    });\n\n    this.player.on('timeupdate', () => {\n      this.lastTime = this.player.media.currentTime;\n    });\n  }\n\n  /**\n   * Create HTML elements for image containers\n   */\n  render() {\n    // Create HTML element: wassPlayer__preview-thumbnail-container\n    this.elements.thumb.container = createElement('div', {\n      class: this.player.config.classNames.previewThumbnails.thumbContainer,\n    });\n\n    // Wrapper for the image for styling\n    this.elements.thumb.imageContainer = createElement('div', {\n      class: this.player.config.classNames.previewThumbnails.imageContainer,\n    });\n    this.elements.thumb.container.appendChild(this.elements.thumb.imageContainer);\n\n    // Create HTML element, parent+span: time text (e.g., 01:32:00)\n    const timeContainer = createElement('div', {\n      class: this.player.config.classNames.previewThumbnails.timeContainer,\n    });\n\n    this.elements.thumb.time = createElement('span', {}, '00:00');\n    timeContainer.appendChild(this.elements.thumb.time);\n\n    this.elements.thumb.container.appendChild(timeContainer);\n\n    // Inject the whole thumb\n    if (is.element(this.player.elements.progress)) {\n      this.player.elements.progress.appendChild(this.elements.thumb.container);\n    }\n\n    // Create HTML element: wassPlayer__preview-scrubbing-container\n    this.elements.scrubbing.container = createElement('div', {\n      class: this.player.config.classNames.previewThumbnails.scrubbingContainer,\n    });\n\n    this.player.elements.wrapper.appendChild(this.elements.scrubbing.container);\n  }\n\n  destroy() {\n    if (this.elements.thumb.container) {\n      this.elements.thumb.container.remove();\n    }\n    if (this.elements.scrubbing.container) {\n      this.elements.scrubbing.container.remove();\n    }\n  }\n\n  showImageAtCurrentTime() {\n    if (this.mouseDown) {\n      this.setScrubbingContainerSize();\n    } else {\n      this.setThumbContainerSizeAndPos();\n    }\n\n    // Find the desired thumbnail index\n    const thumbNum = this.thumbnails[0].frames.findIndex(\n      frame => this.seekTime >= frame.startTime && this.seekTime <= frame.endTime,\n    );\n    const hasThumb = thumbNum >= 0;\n    let qualityIndex = 0;\n\n    // Show the thumb container if we're not scrubbing\n    if (!this.mouseDown) {\n      this.toggleThumbContainer(hasThumb);\n    }\n\n    // No matching thumb found\n    if (!hasThumb) {\n      return;\n    }\n\n    // Check to see if we've already downloaded higher quality versions of this image\n    this.thumbnails.forEach((thumbnail, index) => {\n      if (this.loadedImages.includes(thumbnail.frames[thumbNum].text)) {\n        qualityIndex = index;\n      }\n    });\n\n    // Only proceed if either thumbnum or thumbfilename has changed\n    if (thumbNum !== this.showingThumb) {\n      this.showingThumb = thumbNum;\n      this.loadImage(qualityIndex);\n    }\n  }\n\n  // Show the image that's currently specified in this.showingThumb\n  loadImage(qualityIndex = 0) {\n    const thumbNum = this.showingThumb;\n    const thumbnail = this.thumbnails[qualityIndex];\n    const { urlPrefix } = thumbnail;\n    const frame = thumbnail.frames[thumbNum];\n    const thumbFilename = thumbnail.frames[thumbNum].text;\n    const thumbUrl = urlPrefix + thumbFilename;\n\n    if (!this.currentImageElement || this.currentImageElement.dataset.filename !== thumbFilename) {\n      if (this.loadingImage && this.usingSprites) {\n        this.loadingImage.onload = null;\n      }\n\n      const previewImage = new Image();\n      previewImage.src = thumbUrl;\n      previewImage.dataset.index = thumbNum;\n      previewImage.dataset.filename = thumbFilename;\n      this.showingThumbFilename = thumbFilename;\n\n      this.player.debug.log(`Loading image: ${thumbUrl}`);\n\n      // For some reason, passing the named function directly causes it to execute immediately. So I've wrapped it in an anonymous function...\n      previewImage.onload = () => this.showImage(previewImage, frame, qualityIndex, thumbNum, thumbFilename, true);\n      this.loadingImage = previewImage;\n      this.removeOldImages(previewImage);\n    } else {\n      // Update the existing image\n      this.showImage(this.currentImageElement, frame, qualityIndex, thumbNum, thumbFilename, false);\n      this.currentImageElement.dataset.index = thumbNum;\n      this.removeOldImages(this.currentImageElement);\n    }\n  }\n\n  showImage(previewImage, frame, qualityIndex, thumbNum, thumbFilename, newImage = true) {\n    this.player.debug.log(\n      `Showing thumb: ${thumbFilename}. num: ${thumbNum}. qual: ${qualityIndex}. newimg: ${newImage}`,\n    );\n    this.setImageSizeAndOffset(previewImage, frame);\n\n    if (newImage) {\n      this.currentImageContainer.appendChild(previewImage);\n      this.currentImageElement = previewImage;\n\n      if (!this.loadedImages.includes(thumbFilename)) {\n        this.loadedImages.push(thumbFilename);\n      }\n    }\n\n    this.preloadNearby(thumbNum, true)\n      .then(this.preloadNearby(thumbNum, false))\n      .then(this.getHigherQuality(qualityIndex, previewImage, frame, thumbFilename));\n  }\n\n  // Remove all preview images that aren't the designated current image\n  removeOldImages(currentImage) {\n    // Get a list of all images, convert it from a DOM list to an array\n    Array.from(this.currentImageContainer.children).forEach(image => {\n      if (image.tagName.toLowerCase() !== 'img') {\n        return;\n      }\n\n      const removeDelay = this.usingSprites ? 500 : 1000;\n\n      if (image.dataset.index !== currentImage.dataset.index && !image.dataset.deleting) {\n        // eslint-disable-next-line no-param-reassign\n        image.dataset.deleting = true;\n\n        // This has to be set before the timeout - to prevent issues switching between hover and scrub\n        const { currentImageContainer } = this;\n\n        setTimeout(() => {\n          currentImageContainer.removeChild(image);\n          this.player.debug.log(`Removing thumb: ${image.dataset.filename}`);\n        }, removeDelay);\n      }\n    });\n  }\n\n  // Preload images before and after the current one. Only if the user is still hovering/seeking the same frame\n  // This will only preload the lowest quality\n  preloadNearby(thumbNum, forward = true) {\n    return new Promise(resolve => {\n      setTimeout(() => {\n        const oldThumbFilename = this.thumbnails[0].frames[thumbNum].text;\n\n        if (this.showingThumbFilename === oldThumbFilename) {\n          // Find the nearest thumbs with different filenames. Sometimes it'll be the next index, but in the case of sprites, it might be 100+ away\n          let thumbnailsClone;\n          if (forward) {\n            thumbnailsClone = this.thumbnails[0].frames.slice(thumbNum);\n          } else {\n            thumbnailsClone = this.thumbnails[0].frames.slice(0, thumbNum).reverse();\n          }\n\n          let foundOne = false;\n\n          thumbnailsClone.forEach(frame => {\n            const newThumbFilename = frame.text;\n\n            if (newThumbFilename !== oldThumbFilename) {\n              // Found one with a different filename. Make sure it hasn't already been loaded on this page visit\n              if (!this.loadedImages.includes(newThumbFilename)) {\n                foundOne = true;\n                this.player.debug.log(`Preloading thumb filename: ${newThumbFilename}`);\n\n                const { urlPrefix } = this.thumbnails[0];\n                const thumbURL = urlPrefix + newThumbFilename;\n                const previewImage = new Image();\n                previewImage.src = thumbURL;\n                previewImage.onload = () => {\n                  this.player.debug.log(`Preloaded thumb filename: ${newThumbFilename}`);\n                  if (!this.loadedImages.includes(newThumbFilename)) this.loadedImages.push(newThumbFilename);\n\n                  // We don't resolve until the thumb is loaded\n                  resolve();\n                };\n              }\n            }\n          });\n\n          // If there are none to preload then we want to resolve immediately\n          if (!foundOne) {\n            resolve();\n          }\n        }\n      }, 300);\n    });\n  }\n\n  // If user has been hovering current image for half a second, look for a higher quality one\n  getHigherQuality(currentQualityIndex, previewImage, frame, thumbFilename) {\n    if (currentQualityIndex < this.thumbnails.length - 1) {\n      // Only use the higher quality version if it's going to look any better - if the current thumb is of a lower pixel density than the thumbnail container\n      let previewImageHeight = previewImage.naturalHeight;\n\n      if (this.usingSprites) {\n        previewImageHeight = frame.h;\n      }\n\n      if (previewImageHeight < this.thumbContainerHeight) {\n        // Recurse back to the loadImage function - show a higher quality one, but only if the viewer is on this frame for a while\n        setTimeout(() => {\n          // Make sure the mouse hasn't already moved on and started hovering at another image\n          if (this.showingThumbFilename === thumbFilename) {\n            this.player.debug.log(`Showing higher quality thumb for: ${thumbFilename}`);\n            this.loadImage(currentQualityIndex + 1);\n          }\n        }, 300);\n      }\n    }\n  }\n\n  get currentImageContainer() {\n    if (this.mouseDown) {\n      return this.elements.scrubbing.container;\n    }\n\n    return this.elements.thumb.imageContainer;\n  }\n\n  get usingSprites() {\n    return Object.keys(this.thumbnails[0].frames[0]).includes('w');\n  }\n\n  get thumbAspectRatio() {\n    if (this.usingSprites) {\n      return this.thumbnails[0].frames[0].w / this.thumbnails[0].frames[0].h;\n    }\n\n    return this.thumbnails[0].width / this.thumbnails[0].height;\n  }\n\n  get thumbContainerHeight() {\n    if (this.mouseDown) {\n      const { height } = fitRatio(this.thumbAspectRatio, {\n        width: this.player.media.clientWidth,\n        height: this.player.media.clientHeight,\n      });\n      return height;\n    }\n\n    // If css is used this needs to return the css height for sprites to work (see setImageSizeAndOffset)\n    if (this.sizeSpecifiedInCSS) {\n      return this.elements.thumb.imageContainer.clientHeight;\n    }\n\n    return Math.floor(this.player.media.clientWidth / this.thumbAspectRatio / 4);\n  }\n\n  get currentImageElement() {\n    if (this.mouseDown) {\n      return this.currentScrubbingImageElement;\n    }\n\n    return this.currentThumbnailImageElement;\n  }\n\n  set currentImageElement(element) {\n    if (this.mouseDown) {\n      this.currentScrubbingImageElement = element;\n    } else {\n      this.currentThumbnailImageElement = element;\n    }\n  }\n\n  toggleThumbContainer(toggle = false, clearShowing = false) {\n    const className = this.player.config.classNames.previewThumbnails.thumbContainerShown;\n    this.elements.thumb.container.classList.toggle(className, toggle);\n\n    if (!toggle && clearShowing) {\n      this.showingThumb = null;\n      this.showingThumbFilename = null;\n    }\n  }\n\n  toggleScrubbingContainer(toggle = false) {\n    const className = this.player.config.classNames.previewThumbnails.scrubbingContainerShown;\n    this.elements.scrubbing.container.classList.toggle(className, toggle);\n\n    if (!toggle) {\n      this.showingThumb = null;\n      this.showingThumbFilename = null;\n    }\n  }\n\n  determineContainerAutoSizing() {\n    if (this.elements.thumb.imageContainer.clientHeight > 20 || this.elements.thumb.imageContainer.clientWidth > 20) {\n      // This will prevent auto sizing in this.setThumbContainerSizeAndPos()\n      this.sizeSpecifiedInCSS = true;\n    }\n  }\n\n  // Set the size to be about a quarter of the size of video. Unless option dynamicSize === false, in which case it needs to be set in CSS\n  setThumbContainerSizeAndPos() {\n    if (!this.sizeSpecifiedInCSS) {\n      const thumbWidth = Math.floor(this.thumbContainerHeight * this.thumbAspectRatio);\n      this.elements.thumb.imageContainer.style.height = `${this.thumbContainerHeight}px`;\n      this.elements.thumb.imageContainer.style.width = `${thumbWidth}px`;\n    } else if (\n      this.elements.thumb.imageContainer.clientHeight > 20 &&\n      this.elements.thumb.imageContainer.clientWidth < 20\n    ) {\n      const thumbWidth = Math.floor(this.elements.thumb.imageContainer.clientHeight * this.thumbAspectRatio);\n      this.elements.thumb.imageContainer.style.width = `${thumbWidth}px`;\n    } else if (\n      this.elements.thumb.imageContainer.clientHeight < 20 &&\n      this.elements.thumb.imageContainer.clientWidth > 20\n    ) {\n      const thumbHeight = Math.floor(this.elements.thumb.imageContainer.clientWidth / this.thumbAspectRatio);\n      this.elements.thumb.imageContainer.style.height = `${thumbHeight}px`;\n    }\n\n    this.setThumbContainerPos();\n  }\n\n  setThumbContainerPos() {\n    const seekbarRect = this.player.elements.progress.getBoundingClientRect();\n    const wassPlayerRect = this.player.elements.container.getBoundingClientRect();\n    const { container } = this.elements.thumb;\n    // Find the lowest and highest desired left-position, so we don't slide out the side of the video container\n    const minVal = wassPlayerRect.left - seekbarRect.left + 10;\n    const maxVal = wassPlayerRect.right - seekbarRect.left - container.clientWidth - 10;\n    // Set preview container position to: mousepos, minus seekbar.left, minus half of previewContainer.clientWidth\n    let previewPos = this.mousePosX - seekbarRect.left - container.clientWidth / 2;\n\n    if (previewPos < minVal) {\n      previewPos = minVal;\n    }\n\n    if (previewPos > maxVal) {\n      previewPos = maxVal;\n    }\n\n    container.style.left = `${previewPos}px`;\n  }\n\n  // Can't use 100% width, in case the video is a different aspect ratio to the video container\n  setScrubbingContainerSize() {\n    const { width, height } = fitRatio(this.thumbAspectRatio, {\n      width: this.player.media.clientWidth,\n      height: this.player.media.clientHeight,\n    });\n    this.elements.scrubbing.container.style.width = `${width}px`;\n    this.elements.scrubbing.container.style.height = `${height}px`;\n  }\n\n  // Sprites need to be offset to the correct location\n  setImageSizeAndOffset(previewImage, frame) {\n    if (!this.usingSprites) {\n      return;\n    }\n\n    // Find difference between height and preview container height\n    const multiplier = this.thumbContainerHeight / frame.h;\n\n    // eslint-disable-next-line no-param-reassign\n    previewImage.style.height = `${previewImage.naturalHeight * multiplier}px`;\n    // eslint-disable-next-line no-param-reassign\n    previewImage.style.width = `${previewImage.naturalWidth * multiplier}px`;\n    // eslint-disable-next-line no-param-reassign\n    previewImage.style.left = `-${frame.x * multiplier}px`;\n    // eslint-disable-next-line no-param-reassign\n    previewImage.style.top = `-${frame.y * multiplier}px`;\n  }\n}\n\nexport default PreviewThumbnails;\n","// ==========================================================================\n// WassPlayer source update\n// ==========================================================================\n\nimport { providers } from './config/types';\nimport html5 from './html5';\nimport media from './media';\nimport PreviewThumbnails from './plugins/preview-thumbnails';\nimport support from './support';\nimport ui from './ui';\nimport { createElement, insertElement, removeElement } from './utils/elements';\nimport is from './utils/is';\nimport { getDeep } from './utils/objects';\n\nconst source = {\n  // Add elements to HTML5 media (source, tracks, etc)\n  insertElements(type, attributes) {\n    if (is.string(attributes)) {\n      insertElement(type, this.media, {\n        src: attributes,\n      });\n    } else if (is.array(attributes)) {\n      attributes.forEach(attribute => {\n        insertElement(type, this.media, attribute);\n      });\n    }\n  },\n\n  // Update source\n  // Sources are not checked for support so be careful\n  change(input) {\n    if (!getDeep(input, 'sources.length')) {\n      this.debug.warn('Invalid source format');\n      return;\n    }\n\n    // Cancel current network requests\n    html5.cancelRequests.call(this);\n\n    // Destroy instance and re-setup\n    this.destroy.call(\n      this,\n      () => {\n        // Reset quality options\n        this.options.quality = [];\n\n        // Remove elements\n        removeElement(this.media);\n        this.media = null;\n\n        // Reset class name\n        if (is.element(this.elements.container)) {\n          this.elements.container.removeAttribute('class');\n        }\n\n        // Set the type and provider\n        const { sources, type } = input;\n        const [{ provider = providers.html5, src }] = sources;\n        const tagName = provider === 'html5' ? type : 'div';\n        const attributes = provider === 'html5' ? {} : { src };\n\n        Object.assign(this, {\n          provider,\n          type,\n          // Check for support\n          supported: support.check(type, provider, this.config.playsinline),\n          // Create new element\n          media: createElement(tagName, attributes),\n        });\n\n        // Inject the new element\n        this.elements.container.appendChild(this.media);\n\n        // Autoplay the new source?\n        if (is.boolean(input.autoplay)) {\n          this.config.autoplay = input.autoplay;\n        }\n\n        // Set attributes for audio and video\n        if (this.isHTML5) {\n          if (this.config.crossorigin) {\n            this.media.setAttribute('crossorigin', '');\n          }\n          if (this.config.autoplay) {\n            this.media.setAttribute('autoplay', '');\n          }\n          if (!is.empty(input.poster)) {\n            this.poster = input.poster;\n          }\n          if (this.config.loop.active) {\n            this.media.setAttribute('loop', '');\n          }\n          if (this.config.muted) {\n            this.media.setAttribute('muted', '');\n          }\n          if (this.config.playsinline) {\n            this.media.setAttribute('playsinline', '');\n          }\n        }\n\n        // Restore class hook\n        ui.addStyleHook.call(this);\n\n        // Set new sources for html5\n        if (this.isHTML5) {\n          source.insertElements.call(this, 'source', sources);\n        }\n\n        // Set video title\n        this.config.title = input.title;\n\n        // Set up from scratch\n        media.setup.call(this);\n\n        // HTML5 stuff\n        if (this.isHTML5) {\n          // Setup captions\n          if (Object.keys(input).includes('tracks')) {\n            source.insertElements.call(this, 'track', input.tracks);\n          }\n        }\n\n        // If HTML5 or embed but not fully supported, setupInterface and call ready now\n        if (this.isHTML5 || (this.isEmbed && !this.supported.ui)) {\n          // Setup interface\n          ui.build.call(this);\n        }\n\n        // Load HTML5 sources\n        if (this.isHTML5) {\n          this.media.load();\n        }\n\n        // Update previewThumbnails config & reload plugin\n        if (!is.empty(input.previewThumbnails)) {\n          Object.assign(this.config.previewThumbnails, input.previewThumbnails);\n\n          // Cleanup previewThumbnails plugin if it was loaded\n          if (this.previewThumbnails && this.previewThumbnails.loaded) {\n            this.previewThumbnails.destroy();\n            this.previewThumbnails = null;\n          }\n\n          // Create new instance if it is still enabled\n          if (this.config.previewThumbnails.enabled) {\n            this.previewThumbnails = new PreviewThumbnails(this);\n          }\n        }\n\n        // Update the fullscreen support\n        this.fullscreen.update();\n      },\n      true,\n    );\n  },\n};\n\nexport default source;\n","/**\n * Returns a number whose value is limited to the given range.\n *\n * Example: limit the output of this computation to between 0 and 255\n * (x * 255).clamp(0, 255)\n *\n * @param {Number} input\n * @param {Number} min The lower boundary of the output range\n * @param {Number} max The upper boundary of the output range\n * @returns A number in the range [min, max]\n * @type Number\n */\nexport function clamp(input = 0, min = 0, max = 255) {\n  return Math.min(Math.max(input, min), max);\n}\n\nexport default { clamp };\n","// ==========================================================================\n// WassPlayer\n// WassPlayer.js v3.6.2\n// https://github.com/sampotts/WassPlayer\n// License: The MIT License (MIT)\n// ==========================================================================\n\nimport captions from './captions';\nimport defaults from './config/defaults';\nimport { pip } from './config/states';\nimport { getProviderByUrl, providers, types } from './config/types';\nimport Console from './console';\nimport controls from './controls';\nimport Fullscreen from './fullscreen';\nimport Listeners from './listeners';\nimport media from './media';\nimport PreviewThumbnails from './plugins/preview-thumbnails';\nimport source from './source';\nimport Storage from './storage';\nimport support from './support';\nimport ui from './ui';\nimport { closest } from './utils/arrays';\nimport { createElement, hasClass, removeElement, replaceElement, toggleClass, wrap } from './utils/elements';\nimport { off, on, once, triggerEvent, unbindListeners } from './utils/events';\nimport is from './utils/is';\nimport loadSprite from './utils/load-sprite';\nimport { clamp } from './utils/numbers';\nimport { cloneDeep, extend } from './utils/objects';\nimport { silencePromise } from './utils/promise';\nimport { getAspectRatio, reduceAspectRatio, setAspectRatio, validateRatio } from './utils/style';\nimport { parseUrl } from './utils/urls';\n\n// WassPlayer instance\nclass WassPlayer {\n  constructor(target, options) {\n    this.timers = {};\n\n    // State\n    this.ready = false;\n    this.loading = false;\n    this.failed = false;\n\n    // Touch device\n    this.touch = support.touch;\n\n    // Set the media element\n    this.media = target;\n\n    // String selector passed\n    if (is.string(this.media)) {\n      this.media = document.querySelectorAll(this.media);\n    }\n\n    // jQuery, NodeList or Array passed, use first element\n    if ((window.jQuery && this.media instanceof jQuery) || is.nodeList(this.media) || is.array(this.media)) {\n      // eslint-disable-next-line\n      this.media = this.media[0];\n    }\n\n    // Set config\n    this.config = extend(\n      {},\n      defaults,\n      WassPlayer.defaults,\n      options || {},\n      (() => {\n        try {\n          return JSON.parse(this.media.getAttribute('data-wassPlayer-config'));\n        } catch (e) {\n          return {};\n        }\n      })(),\n    );\n\n    // Elements cache\n    this.elements = {\n      container: null,\n      fullscreen: null,\n      captions: null,\n      buttons: {},\n      display: {},\n      progress: {},\n      inputs: {},\n      settings: {\n        popup: null,\n        menu: null,\n        panels: {},\n        buttons: {},\n      },\n    };\n\n    // Captions\n    this.captions = {\n      active: null,\n      currentTrack: -1,\n      meta: new WeakMap(),\n    };\n\n    // Fullscreen\n    this.fullscreen = {\n      active: false,\n    };\n\n    // Options\n    this.options = {\n      speed: [],\n      quality: [],\n    };\n\n    // Debugging\n    // TODO: move to globals\n    this.debug = new Console(this.config.debug);\n\n    // Log config options and support\n    this.debug.log('Config', this.config);\n    this.debug.log('Support', support);\n\n    // We need an element to setup\n    if (is.nullOrUndefined(this.media) || !is.element(this.media)) {\n      this.debug.error('Setup failed: no suitable element passed');\n      return;\n    }\n\n    // Bail if the element is initialized\n    if (this.media.wassPlayer) {\n      this.debug.warn('Target already setup');\n      return;\n    }\n\n    // Bail if not enabled\n    if (!this.config.enabled) {\n      this.debug.error('Setup failed: disabled by config');\n      return;\n    }\n\n    // Bail if disabled or no basic support\n    // You may want to disable certain UAs etc\n    if (!support.check().api) {\n      this.debug.error('Setup failed: no support');\n      return;\n    }\n\n    // Cache original element state for .destroy()\n    const clone = this.media.cloneNode(true);\n    clone.autoplay = false;\n    this.elements.original = clone;\n\n    // Set media type based on tag or data attribute\n    // Supported: video\n    const type = this.media.tagName.toLowerCase();\n    // Embed properties\n    let iframe = null;\n    let url = null;\n\n    // Different setup based on type\n    switch (type) {\n      case 'div':\n        // Find the frame\n        iframe = this.media.querySelector('iframe');\n\n        // <iframe> type\n        if (is.element(iframe)) {\n          // Detect provider\n          url = parseUrl(iframe.getAttribute('src'));\n          this.provider = getProviderByUrl(url.toString());\n\n          // Rework elements\n          this.elements.container = this.media;\n          this.media = iframe;\n\n          // Reset classname\n          this.elements.container.className = '';\n\n          // Get attributes from URL and set config\n          if (url.search.length) {\n            const truthy = ['1', 'true'];\n\n            if (truthy.includes(url.searchParams.get('autoplay'))) {\n              this.config.autoplay = true;\n            }\n            if (truthy.includes(url.searchParams.get('loop'))) {\n              this.config.loop.active = true;\n            }\n\n            this.config.playsinline = true;\n          }\n        } else {\n          // <div> with attributes\n          this.provider = this.media.getAttribute(this.config.attributes.embed.provider);\n\n          // Remove attribute\n          this.media.removeAttribute(this.config.attributes.embed.provider);\n        }\n\n        // Unsupported or missing provider\n        if (is.empty(this.provider) || !Object.keys(providers).includes(this.provider)) {\n          this.debug.error('Setup failed: Invalid provider');\n          return;\n        }\n\n        // Audio will come later for external providers\n        this.type = types.video;\n\n        break;\n\n      case 'video':\n      case 'audio':\n        this.type = type;\n        this.provider = providers.html5;\n\n        // Get config from attributes\n        if (this.media.hasAttribute('crossorigin')) {\n          this.config.crossorigin = true;\n        }\n        if (this.media.hasAttribute('autoplay')) {\n          this.config.autoplay = true;\n        }\n        if (this.media.hasAttribute('playsinline') || this.media.hasAttribute('webkit-playsinline')) {\n          this.config.playsinline = true;\n        }\n        if (this.media.hasAttribute('muted')) {\n          this.config.muted = true;\n        }\n        if (this.media.hasAttribute('loop')) {\n          this.config.loop.active = true;\n        }\n\n        break;\n\n      default:\n        this.debug.error('Setup failed: unsupported type');\n        return;\n    }\n\n    // Check for support again but with type\n    this.supported = support.check(this.type, this.provider, this.config.playsinline);\n\n    // If no support for even API, bail\n    if (!this.supported.api) {\n      this.debug.error('Setup failed: no support');\n      return;\n    }\n\n    this.eventListeners = [];\n\n    // Create listeners\n    this.listeners = new Listeners(this);\n\n    // Setup local storage for user settings\n    this.storage = new Storage(this);\n\n    // Store reference\n    this.media.wassPlayer = this;\n\n    // Wrap media\n    if (!is.element(this.elements.container)) {\n      this.elements.container = createElement('div', { tabindex: 0 });\n      wrap(this.media, this.elements.container);\n    }\n\n    // Migrate custom properties from media to container (so they work 😉)\n    ui.migrateStyles.call(this);\n\n    // Add style hook\n    ui.addStyleHook.call(this);\n\n    // Setup media\n    media.setup.call(this);\n\n    // Listen for events if debugging\n    if (this.config.debug) {\n      on.call(this, this.elements.container, this.config.events.join(' '), event => {\n        this.debug.log(`event: ${event.type}`);\n      });\n    }\n\n    // Setup fullscreen\n    this.fullscreen = new Fullscreen(this);\n\n    // Setup interface\n    // If embed but not fully supported, build interface now to avoid flash of controls\n    if (this.isHTML5 || (this.isEmbed && !this.supported.ui)) {\n      ui.build.call(this);\n    }\n\n    // Container listeners\n    this.listeners.container();\n\n    // Global listeners\n    this.listeners.global();\n\n    // Autoplay if required\n    if (this.isHTML5 && this.config.autoplay) {\n      setTimeout(() => silencePromise(this.play()), 10);\n    }\n\n    // Seek time will be recorded (in listeners.js) so we can prevent hiding controls for a few seconds after seek\n    this.lastSeekTime = 0;\n\n    // Setup preview thumbnails if enabled\n    if (this.config.previewThumbnails.enabled) {\n      this.previewThumbnails = new PreviewThumbnails(this);\n    }\n  }\n\n  // ---------------------------------------\n  // API\n  // ---------------------------------------\n\n  /**\n   * Types and provider helpers\n   */\n  get isHTML5() {\n    return this.provider === providers.html5;\n  }\n\n  get isVideo() {\n    return this.type === types.video;\n  }\n\n  /**\n   * Play the media, or play the advertisement (if they are not blocked)\n   */\n  play() {\n    if (!is.function(this.media.play)) {\n      return null;\n    }\n\n    // Return the promise (for HTML5)\n    return this.media.play();\n  }\n\n  /**\n   * Pause the media\n   */\n  pause() {\n    if (!this.playing || !is.function(this.media.pause)) {\n      return null;\n    }\n\n    return this.media.pause();\n  }\n\n  /**\n   * Get playing state\n   */\n  get playing() {\n    return Boolean(this.ready && !this.paused && !this.ended);\n  }\n\n  /**\n   * Get paused state\n   */\n  get paused() {\n    return Boolean(this.media.paused);\n  }\n\n  /**\n   * Get stopped state\n   */\n  get stopped() {\n    return Boolean(this.paused && this.currentTime === 0);\n  }\n\n  /**\n   * Get ended state\n   */\n  get ended() {\n    return Boolean(this.media.ended);\n  }\n\n  /**\n   * Toggle playback based on current status\n   * @param {Boolean} input\n   */\n  togglePlay(input) {\n    // Toggle based on current state if nothing passed\n    const toggle = is.boolean(input) ? input : !this.playing;\n\n    if (toggle) {\n      return this.play();\n    }\n\n    return this.pause();\n  }\n\n  /**\n   * Stop playback\n   */\n  stop() {\n    if (this.isHTML5) {\n      this.pause();\n      this.restart();\n    } else if (is.function(this.media.stop)) {\n      this.media.stop();\n    }\n  }\n\n  /**\n   * Restart playback\n   */\n  restart() {\n    this.currentTime = 0;\n  }\n\n  /**\n   * Rewind\n   * @param {Number} seekTime - how far to rewind in seconds. Defaults to the config.seekTime\n   */\n  rewind(seekTime) {\n    this.currentTime -= is.number(seekTime) ? seekTime : this.config.seekTime;\n  }\n\n  /**\n   * Fast forward\n   * @param {Number} seekTime - how far to fast forward in seconds. Defaults to the config.seekTime\n   */\n  forward(seekTime) {\n    this.currentTime += is.number(seekTime) ? seekTime : this.config.seekTime;\n  }\n\n  /**\n   * Seek to a time\n   * @param {Number} input - where to seek to in seconds. Defaults to 0 (the start)\n   */\n  set currentTime(input) {\n    // Bail if media duration isn't available yet\n    if (!this.duration) {\n      return;\n    }\n\n    // Validate input\n    const inputIsValid = is.number(input) && input > 0;\n\n    // Set\n    this.media.currentTime = inputIsValid ? Math.min(input, this.duration) : 0;\n\n    // Logging\n    this.debug.log(`Seeking to ${this.currentTime} seconds`);\n  }\n\n  /**\n   * Get current time\n   */\n  get currentTime() {\n    return Number(this.media.currentTime);\n  }\n\n  /**\n   * Get buffered\n   */\n  get buffered() {\n    const { buffered } = this.media;\n\n    if (is.number(buffered)) {\n      return buffered;\n    }\n\n    // HTML5\n    // (i.e. seek to another section buffers only that section)\n    if (buffered && buffered.length && this.duration > 0) {\n      return buffered.end(0) / this.duration;\n    }\n\n    return 0;\n  }\n\n  /**\n   * Get seeking status\n   */\n  get seeking() {\n    return Boolean(this.media.seeking);\n  }\n\n  /**\n   * Get the duration of the current media\n   */\n  get duration() {\n    // Faux duration set via config\n    const fauxDuration = parseFloat(this.config.duration);\n    // Media duration can be NaN or Infinity before the media has loaded\n    const realDuration = (this.media || {}).duration;\n    const duration = !is.number(realDuration) || realDuration === Infinity ? 0 : realDuration;\n\n    // If config duration is funky, use regular duration\n    return fauxDuration || duration;\n  }\n\n  /**\n   * Set the player volume\n   * @param {Number} value - must be between 0 and 1. Defaults to the value from local storage and config.volume if not set in storage\n   */\n  set volume(value) {\n    let volume = value;\n    const max = 1;\n    const min = 0;\n\n    if (is.string(volume)) {\n      volume = Number(volume);\n    }\n\n    // Load volume from storage if no value specified\n    if (!is.number(volume)) {\n      volume = this.storage.get('volume');\n    }\n\n    // Use config if all else fails\n    if (!is.number(volume)) {\n      ({ volume } = this.config);\n    }\n\n    // Maximum is volumeMax\n    if (volume > max) {\n      volume = max;\n    }\n    // Minimum is volumeMin\n    if (volume < min) {\n      volume = min;\n    }\n\n    // Update config\n    this.config.volume = volume;\n\n    // Set the player volume\n    this.media.volume = volume;\n\n    // If muted, and we're increasing volume manually, reset muted state\n    if (!is.empty(value) && this.muted && volume > 0) {\n      this.muted = false;\n    }\n  }\n\n  /**\n   * Get the current player volume\n   */\n  get volume() {\n    return Number(this.media.volume);\n  }\n\n  /**\n   * Increase volume\n   * @param {Boolean} step - How much to decrease by (between 0 and 1)\n   */\n  increaseVolume(step) {\n    const volume = this.media.muted ? 0 : this.volume;\n    this.volume = volume + (is.number(step) ? step : 0);\n  }\n\n  /**\n   * Decrease volume\n   * @param {Boolean} step - How much to decrease by (between 0 and 1)\n   */\n  decreaseVolume(step) {\n    this.increaseVolume(-step);\n  }\n\n  /**\n   * Set muted state\n   * @param {Boolean} mute\n   */\n  set muted(mute) {\n    let toggle = mute;\n\n    // Load muted state from storage\n    if (!is.boolean(toggle)) {\n      toggle = this.storage.get('muted');\n    }\n\n    // Use config if all else fails\n    if (!is.boolean(toggle)) {\n      toggle = this.config.muted;\n    }\n\n    // Update config\n    this.config.muted = toggle;\n\n    // Set mute on the player\n    this.media.muted = toggle;\n  }\n\n  /**\n   * Get current muted state\n   */\n  get muted() {\n    return Boolean(this.media.muted);\n  }\n\n  /**\n   * Check if the media has audio\n   */\n  get hasAudio() {\n    // Assume yes for all non HTML5 (as we can't tell...)\n    if (!this.isHTML5) {\n      return true;\n    }\n\n    if (this.isAudio) {\n      return true;\n    }\n\n    // Get audio tracks\n    return (\n      Boolean(this.media.mozHasAudio) ||\n      Boolean(this.media.webkitAudioDecodedByteCount) ||\n      Boolean(this.media.audioTracks && this.media.audioTracks.length)\n    );\n  }\n\n  /**\n   * Set playback speed\n   * @param {Number} speed - the speed of playback (0.5-2.0)\n   */\n  set speed(input) {\n    let speed = null;\n\n    if (is.number(input)) {\n      speed = input;\n    }\n\n    if (!is.number(speed)) {\n      speed = this.storage.get('speed');\n    }\n\n    if (!is.number(speed)) {\n      speed = this.config.speed.selected;\n    }\n\n    // Clamp to min/max\n    const { minimumSpeed: min, maximumSpeed: max } = this;\n    speed = clamp(speed, min, max);\n\n    // Update config\n    this.config.speed.selected = speed;\n\n    // Set media speed\n    setTimeout(() => {\n      this.media.playbackRate = speed;\n    }, 0);\n  }\n\n  /**\n   * Get current playback speed\n   */\n  get speed() {\n    return Number(this.media.playbackRate);\n  }\n\n  /**\n   * Get the minimum allowed speed\n   */\n  // eslint-disable-next-line class-methods-use-this\n  get minimumSpeed() {\n    return 0.0625;\n  }\n\n  /**\n   * Get the maximum allowed speed\n   */\n  // eslint-disable-next-line class-methods-use-this\n  get maximumSpeed() {\n    return 16;\n  }\n\n  /**\n   * Set playback quality\n   * Currently HTML5 only\n   * @param {Number} input - Quality level\n   */\n  set quality(input) {\n    const config = this.config.quality;\n    const options = this.options.quality;\n\n    if (!options.length) {\n      return;\n    }\n\n    let quality = [\n      !is.empty(input) && Number(input),\n      this.storage.get('quality'),\n      config.selected,\n      config.default,\n    ].find(is.number);\n\n    let updateStorage = true;\n\n    if (!options.includes(quality)) {\n      const value = closest(options, quality);\n      this.debug.warn(`Unsupported quality option: ${quality}, using ${value} instead`);\n      quality = value;\n\n      // Don't update storage if quality is not supported\n      updateStorage = false;\n    }\n\n    // Update config\n    config.selected = quality;\n\n    // Set quality\n    this.media.quality = quality;\n\n    // Save to storage\n    if (updateStorage) {\n      this.storage.set({ quality });\n    }\n  }\n\n  /**\n   * Get current quality level\n   */\n  get quality() {\n    return this.media.quality;\n  }\n\n  /**\n   * Toggle loop\n   * @param {Boolean} input - Whether to loop or not\n   */\n  set loop(input) {\n    const toggle = is.boolean(input) ? input : this.config.loop.active;\n    this.config.loop.active = toggle;\n    this.media.loop = toggle;\n\n    // Set default to be a true toggle\n    /* const type = ['start', 'end', 'all', 'none', 'toggle'].includes(input) ? input : 'toggle';\n\n        switch (type) {\n            case 'start':\n                if (this.config.loop.end && this.config.loop.end <= this.currentTime) {\n                    this.config.loop.end = null;\n                }\n                this.config.loop.start = this.currentTime;\n                // this.config.loop.indicator.start = this.elements.display.played.value;\n                break;\n\n            case 'end':\n                if (this.config.loop.start >= this.currentTime) {\n                    return this;\n                }\n                this.config.loop.end = this.currentTime;\n                // this.config.loop.indicator.end = this.elements.display.played.value;\n                break;\n\n            case 'all':\n                this.config.loop.start = 0;\n                this.config.loop.end = this.duration - 2;\n                this.config.loop.indicator.start = 0;\n                this.config.loop.indicator.end = 100;\n                break;\n\n            case 'toggle':\n                if (this.config.loop.active) {\n                    this.config.loop.start = 0;\n                    this.config.loop.end = null;\n                } else {\n                    this.config.loop.start = 0;\n                    this.config.loop.end = this.duration - 2;\n                }\n                break;\n\n            default:\n                this.config.loop.start = 0;\n                this.config.loop.end = null;\n                break;\n        } */\n  }\n\n  /**\n   * Get current loop state\n   */\n  get loop() {\n    return Boolean(this.media.loop);\n  }\n\n  /**\n   * Set new media source\n   * @param {Object} input - The new source object (see docs)\n   */\n  set source(input) {\n    source.change.call(this, input);\n  }\n\n  /**\n   * Get current source\n   */\n  get source() {\n    return this.media.currentSrc;\n  }\n\n  /**\n   * Get a download URL (either source or custom)\n   */\n  get download() {\n    const { download } = this.config.urls;\n\n    return is.url(download) ? download : this.source;\n  }\n\n  /**\n   * Set the download URL\n   */\n  set download(input) {\n    if (!is.url(input)) {\n      return;\n    }\n\n    this.config.urls.download = input;\n\n    controls.setDownloadUrl.call(this);\n  }\n\n  /**\n   * Set the poster image for a video\n   * @param {String} input - the URL for the new poster image\n   */\n  set poster(input) {\n    if (!this.isVideo) {\n      this.debug.warn('Poster can only be set for video');\n      return;\n    }\n\n    ui.setPoster.call(this, input, false).catch(() => {});\n  }\n\n  /**\n   * Get the current poster image\n   */\n  get poster() {\n    if (!this.isVideo) {\n      return null;\n    }\n\n    return this.media.getAttribute('poster') || this.media.getAttribute('data-poster');\n  }\n\n  /**\n   * Get the current aspect ratio in use\n   */\n  get ratio() {\n    if (!this.isVideo) {\n      return null;\n    }\n\n    const ratio = reduceAspectRatio(getAspectRatio.call(this));\n\n    return is.array(ratio) ? ratio.join(':') : ratio;\n  }\n\n  /**\n   * Set video aspect ratio\n   */\n  set ratio(input) {\n    if (!this.isVideo) {\n      this.debug.warn('Aspect ratio can only be set for video');\n      return;\n    }\n\n    if (!is.string(input) || !validateRatio(input)) {\n      this.debug.error(`Invalid aspect ratio specified (${input})`);\n      return;\n    }\n\n    this.config.ratio = input;\n\n    setAspectRatio.call(this);\n  }\n\n  /**\n   * Set the autoplay state\n   * @param {Boolean} input - Whether to autoplay or not\n   */\n  set autoplay(input) {\n    const toggle = is.boolean(input) ? input : this.config.autoplay;\n    this.config.autoplay = toggle;\n  }\n\n  /**\n   * Get the current autoplay state\n   */\n  get autoplay() {\n    return Boolean(this.config.autoplay);\n  }\n\n  /**\n   * Toggle captions\n   * @param {Boolean} input - Whether to enable captions\n   */\n  toggleCaptions(input) {\n    captions.toggle.call(this, input, false);\n  }\n\n  /**\n   * Set the caption track by index\n   * @param {Number} - Caption index\n   */\n  set currentTrack(input) {\n    captions.set.call(this, input, false);\n  }\n\n  /**\n   * Get the current caption track index (-1 if disabled)\n   */\n  get currentTrack() {\n    const { toggled, currentTrack } = this.captions;\n    return toggled ? currentTrack : -1;\n  }\n\n  /**\n   * Set the wanted language for captions\n   * Since tracks can be added later it won't update the actual caption track until there is a matching track\n   * @param {String} - Two character ISO language code (e.g. EN, FR, PT, etc)\n   */\n  set language(input) {\n    captions.setLanguage.call(this, input, false);\n  }\n\n  /**\n   * Get the current track's language\n   */\n  get language() {\n    return (captions.getCurrentTrack.call(this) || {}).language;\n  }\n\n  /**\n   * Toggle picture-in-picture playback on WebKit/MacOS\n   */\n  set pip(input) {\n    // Bail if no support\n    if (!support.pip) {\n      return;\n    }\n\n    // Toggle based on current state if not passed\n    const toggle = is.boolean(input) ? input : !this.pip;\n\n    // Toggle based on current state\n    // Safari\n    if (is.function(this.media.webkitSetPresentationMode)) {\n      this.media.webkitSetPresentationMode(toggle ? pip.active : pip.inactive);\n    }\n\n    // Chrome\n    if (is.function(this.media.requestPictureInPicture)) {\n      if (!this.pip && toggle) {\n        this.media.requestPictureInPicture();\n      } else if (this.pip && !toggle) {\n        document.exitPictureInPicture();\n      }\n    }\n  }\n\n  /**\n   * Get the current picture-in-picture state\n   */\n  get pip() {\n    if (!support.pip) {\n      return null;\n    }\n\n    // Safari\n    if (!is.empty(this.media.webkitPresentationMode)) {\n      return this.media.webkitPresentationMode === pip.active;\n    }\n\n    // Chrome\n    return this.media === document.pictureInPictureElement;\n  }\n\n  /**\n   * Trigger the airplay dialog\n   */\n  airplay() {\n    // Show dialog if supported\n    if (support.airplay) {\n      this.media.webkitShowPlaybackTargetPicker();\n    }\n  }\n\n  /**\n   * Toggle the player controls\n   * @param {Boolean} [toggle] - Whether to show the controls\n   */\n  toggleControls(toggle) {\n    // Don't toggle if missing UI support or if it's audio\n    if (this.supported.ui && !this.isAudio) {\n      // Get state before change\n      const isHidden = hasClass(this.elements.container, this.config.classNames.hideControls);\n      // Negate the argument if not undefined since adding the class to hides the controls\n      const force = typeof toggle === 'undefined' ? undefined : !toggle;\n      // Apply and get updated state\n      const hiding = toggleClass(this.elements.container, this.config.classNames.hideControls, force);\n\n      // Close menu\n      if (hiding && is.array(this.config.controls) && this.config.controls.includes('settings') && !is.empty(this.config.settings)) {\n        controls.toggleMenu.call(this, false);\n      }\n\n      // Trigger event on change\n      if (hiding !== isHidden) {\n        const eventName = hiding ? 'controlshidden' : 'controlsshown';\n        triggerEvent.call(this, this.media, eventName);\n      }\n\n      return !hiding;\n    }\n\n    return false;\n  }\n\n  /**\n   * Add event listeners\n   * @param {String} event - Event type\n   * @param {Function} callback - Callback for when event occurs\n   */\n  on(event, callback) {\n    on.call(this, this.elements.container, event, callback);\n  }\n\n  /**\n   * Add event listeners once\n   * @param {String} event - Event type\n   * @param {Function} callback - Callback for when event occurs\n   */\n  once(event, callback) {\n    once.call(this, this.elements.container, event, callback);\n  }\n\n  /**\n   * Remove event listeners\n   * @param {String} event - Event type\n   * @param {Function} callback - Callback for when event occurs\n   */\n  off(event, callback) {\n    off(this.elements.container, event, callback);\n  }\n\n  /**\n   * Destroy an instance\n   * Event listeners are removed when elements are removed\n   * http://stackoverflow.com/questions/12528049/if-a-dom-element-is-removed-are-its-listeners-also-removed-from-memory\n   * @param {Function} callback - Callback for when destroy is complete\n   * @param {Boolean} soft - Whether it's a soft destroy (for source changes etc)\n   */\n  destroy(callback, soft = false) {\n    if (!this.ready) {\n      return;\n    }\n\n    const done = () => {\n      // Reset overflow (incase destroyed while in fullscreen)\n      document.body.style.overflow = '';\n\n      // GC for embed\n      this.embed = null;\n\n      // If it's a soft destroy, make minimal changes\n      if (soft) {\n        if (Object.keys(this.elements).length) {\n          // Remove elements\n          removeElement(this.elements.buttons.play);\n          removeElement(this.elements.captions);\n          removeElement(this.elements.controls);\n          removeElement(this.elements.wrapper);\n\n          // Clear for GC\n          this.elements.buttons.play = null;\n          this.elements.captions = null;\n          this.elements.controls = null;\n          this.elements.wrapper = null;\n        }\n\n        // Callback\n        if (is.function(callback)) {\n          callback();\n        }\n      } else {\n        // Unbind listeners\n        unbindListeners.call(this);\n\n        // Replace the container with the original element provided\n        replaceElement(this.elements.original, this.elements.container);\n\n        // Event\n        triggerEvent.call(this, this.elements.original, 'destroyed', true);\n\n        // Callback\n        if (is.function(callback)) {\n          callback.call(this.elements.original);\n        }\n\n        // Reset state\n        this.ready = false;\n\n        // Clear for garbage collection\n        setTimeout(() => {\n          this.elements = null;\n          this.media = null;\n        }, 200);\n      }\n    };\n\n    // Stop playback\n    this.stop();\n\n    // Clear timeouts\n    clearTimeout(this.timers.loading);\n    clearTimeout(this.timers.controls);\n    clearTimeout(this.timers.resized);\n\n    // Provider specific stuff\n    if (this.isHTML5) {\n      // Restore native video controls\n      ui.toggleNativeControls.call(this, true);\n\n      // Clean up\n      done();\n    }\n  }\n\n  /**\n   * Check for support for a mime type (HTML5 only)\n   * @param {String} type - Mime type\n   */\n  supports(type) {\n    return support.mime.call(this, type);\n  }\n\n  /**\n   * Check for support\n   * @param {String} type - Player type (video)\n   * @param {String} provider - Provider (html5)\n   * @param {Boolean} inline - Where player has `playsinline` sttribute\n   */\n  static supported(type, provider, inline) {\n    return support.check(type, provider, inline);\n  }\n\n  /**\n   * Load an SVG sprite into the page\n   * @param {String} url - URL for the SVG sprite\n   * @param {String} [id] - Unique ID\n   */\n  static loadSprite(url, id) {\n    return loadSprite(url, id);\n  }\n\n  /**\n   * Setup multiple instances\n   * @param {*} selector\n   * @param {Object} options\n   */\n  static setup(selector, options = {}) {\n    let targets = null;\n\n    if (is.string(selector)) {\n      targets = Array.from(document.querySelectorAll(selector));\n    } else if (is.nodeList(selector)) {\n      targets = Array.from(selector);\n    } else if (is.array(selector)) {\n      targets = selector.filter(is.element);\n    }\n\n    if (is.empty(targets)) {\n      return null;\n    }\n\n    return targets.map(t => new WassPlayer(t, options));\n  }\n}\n\nWassPlayer.defaults = cloneDeep(defaults);\n\nexport default WassPlayer;\n"]}